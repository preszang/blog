{"posts":[{"title":"Python Faker库常用操作 函数","content":"Python Faker 库常用操作 函数 Python Faker 库常用操作 函数 country()：国家 province()：省份 city_suffix()：市，县 district()：区 street_address()：街道地址 street_name()：街道名 street_suffix()：街、路 country_code()：国家编码 postcode()：邮编 geo_coordinate()：地理坐标 longitude()：经度 latitude()：纬度 lexify()：替换所有问号？带有随机事件 numerify()：生成三位随机数 random_digit()：生成 0~9 随机数 random_digit_not_null()：生成 1~9 的随机数 random_element()：生成随机字母 random_int()：随机数字，默认 0~9999，可通过 min,max 参数修改 random_letter()：随机字母 random_number()：随机数字，参数 digits 设置生成的数字位数 color_name()：随机颜色名 hex_color()：随机 HEX 颜色 rgb_color()：随机 RGB 颜色 safe_color_name()：随机安全色名 safe_hex_color()：随机安全 HEX 颜色 bs()：随机公司服务名 company()：随机公司名（长） company_prefix()：随机公司名（短） company_suffix()：公司性质 credit_card_expire()：随机信用卡到期日 credit_card_full()：生成完整信用卡信息 credit_card_number()：信用卡号 credit_card_provider()：信用卡类型 credit_card_security_code()：信用卡安全码 currency_code()：货币编码 am_pm()：AM/PM century()：随机世纪 date()：随机日期 date_between()：随机生成指定范围内日期，参数：start_date，end_date date_between_dates()：随机生成指定范围内日期，用法同上 date_object()：随机生产从 1970-1-1 到指定日期的随机日期。 date_this_month()： date_this_year()： date_time()：随机生成指定时间（1970 年 1 月 1 日至今） date_time_ad()：生成公元 1 年到现在的随机时间 date_time_between()：用法同 dates future_date()：未来日期 future_datetime()：未来时间 month()：随机月份 month_name()：随机月份（英文） past_date()：随机生成已经过去的日期 past_datetime()：随机生成已经过去的时间 time()：随机 24 小时时间 timedelta()：随机获取时间差 time_object()：随机 24 小时时间，time 对象 time_series()：随机 TimeSeries 对象 timezone()：随机时区 unix_time()：随机 Unix 时间 year()：随机年份 file_extension()：随机文件扩展名 file_name()：随机文件名（包含扩展名，不包含路径） file_path()：随机文件路径（包含文件名，扩展名） mime_type()：随机 mime Type ascii_company_email()：随机 ASCII 公司邮箱名 ascii_email()：随机 ASCII 邮箱 ascii_free_email()： ascii_safe_email()： company_email()： domain_name()：生成域名 domain_word()：域词(即，不包含后缀) email()： free_email()： free_email_domain()： f.safe_email()：安全邮箱 f.image_url()：随机 URL 地址 ipv4()：随机 IP4 地址 ipv6()：随机 IP6 地址 mac_address()：随机 MAC 地址 tld()：网址域名后缀 uri()：随机 URI 地址 uri_extension()：网址文件后缀 uri_page()：网址文件（不包含后缀） uri_path()：网址文件路径（不包含文件名） url()：随机 URL 地址 user_name()：随机用户名 isbn10()：随机 ISBN（10 位） isbn13()：随机 ISBN（13 位） job()：随机职位 paragraph()：随机生成一个段落 paragraphs()：随机生成多个段落，通过参数 nb 来控制段落数，返回数组 sentence()：随机生成一句话 sentences()：随机生成多句话，与段落类似 text()：随机生成一篇文章 word()：随机生成词语 words()：随机生成多个词语，用法与段落，句子，类似 binary()：随机生成二进制编码 boolean()：True/False language_code()：随机生成两位语言编码 locale()：随机生成语言/国际 信息 md5()：随机生成 MD5 null_boolean()：NULL/True/False password()：随机生成密码,可选参数：length：密码长度；special_chars：是否能使用特殊字符；digits：是否包含数字 upper_case：是否包含大写字母；lower_case：是否包含小写字母 sha1()：随机 SHA1 sha256()：随机 SHA256 uuid4()：随机 UUID first_name()： first_name_female()：女性名 first_name_male()：男性名 first_romanized_name()：罗马名 last_name()： last_name_female()：女 last_name_male()：男 last_romanized_name()： name()：随机生成姓名 name_female()：男性姓名 name_male()：女性姓名 romanized_name()：罗马名 msisdn()：移动台国际用户识别码，即移动用户的 ISDN 号码 phone_number()：随机生成手机号 phonenumber_prefix()：随机生成手机号段 profile()：随机生成档案信息 simple_profile()：随机生成简单档案信息 pybool()： pydecimal()： pydict()： pyfloat()：left_digits=2 #生成的整数位数, right_digits=1 #生成的小数位数, positive=True #是否只有正数 pyint()： pyiterable() pylist() pyset() pystr() pystruct() pytuple() ssn()：生成身份证号 chrome()：随机生成 Chrome 的浏览器 user_agent 信息 firefox()：随机生成 FireFox 的浏览器 user_agent 信息 internet_explorer()：随机生成 IE 的浏览器 user_agent 信息 opera()：随机生成 Opera 的浏览器 user_agent 信息 safari()：随机生成 Safari 的浏览器 user_agent 信息 linux_platform_token()：随机 Linux 信息 user_agent()：随机 user_agent 信息 ","link":"https://preszang.github.io/post/K6Iq63FrK/"},{"title":"使用yagmail发送邮件，就几行代码","content":" yagmail可以更简单的来实现自动发邮件功能。 github项目地址: https://github.com/kootenpv/yagmail 安装 pip install yagmail 简单例子 import yagmail # 链接邮箱服务器 yag = yagmail.SMTP(user=&quot;user@126.com&quot;, password=&quot;1234&quot;, host='smtp.126.com') #邮箱正文 contents = ['This is the body, and here is just text http://somedomain/image.png', 'You can find an audio file attached.', '/local/path/song.mp3'] # 发送邮件 yag.send('taaa@126.com', 'subject', contents) # 给多个用户发送邮件 只需要将接收邮箱 变成一个list即可。 yag.send(['aa@126.com','bb@qq.com','cc@gmail.com'], 'subject', contents) # 发送带附件的邮件只需要添加要发送的附件列表即可。 yag.send('aaaa@126.com', '发送附件', contents, [&quot;d://log.txt&quot;,&quot;d://baidu_img.jpg&quot;]) ","link":"https://preszang.github.io/post/8CoDqKwKu/"},{"title":"Python 调用钉钉和企业微信机器人发送消息","content":"Python 调用钉钉和企业企业微信机器人发送消息 企业微信 在终端某个群组添加机器人之后，可以获取到webhook地址，然后开发者用户按以下说明构造post data向这个地址发起HTTP POST 请求，即可实现给该群组发送消息。特别特别要注意：一定要保护好机器人的webhook地址，避免泄漏！ 以下是用 python 往群组推送文本消息的示例（注意要将url 替换成你的机器人webhook地址）： import json import requests # 向企业微信机器人发消息 def sendQyWechat(msg): token = '这是token' url = f'https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key={token}' data = {&quot;msgtype&quot;: &quot;text&quot;, &quot;text&quot;: {&quot;content&quot;: msg}} res = requests.post(url, json.dumps(data)) res.encoding = 'utf-8' return res.text 当前自定义机器人支持文本（text）、markdown（markdown）两种消息类型。 每个机器人发送的消息不能超过 20 条/分钟。 消息类型和数据格式 文本类型 { &quot;msgtype&quot;: &quot;text&quot;, &quot;text&quot;: { &quot;content&quot;: &quot;广州今日天气：29度，大部分多云，降雨概率：60%&quot;, &quot;mentioned_list&quot;: [&quot;wangqing&quot;, &quot;@all&quot;], &quot;mentioned_mobile_list&quot;: [&quot;13800001111&quot;, &quot;@all&quot;] } } 参数 是否必填 说明 msgtype 是 消息类型，此时固定为text content 是 文本内容，最长不超过 2048 个字节，必须是utf8编码 mentioned_list 否 userid的列表，提醒群中的指定成员(@某个成员)，@all 表示提醒所有人，如果开发者获取不到userid，可以使用mentioned_mobile_list mentioned_mobile_list 否 手机号列表，提醒手机号对应的群成员(@某个成员)，@all 表示提醒所有人 markdown 类型 { &quot;msgtype&quot;: &quot;markdown&quot;, &quot;markdown&quot;: { &quot;content&quot;: &quot;实时新增用户反馈&lt;font color=\\&quot;warning\\&quot;&gt;132例&lt;/font&gt;，请相关同事注意。\\n &gt;类型:&lt;font color=\\&quot;comment\\&quot;&gt;用户反馈&lt;/font&gt; \\n &gt;普通用户反馈:&lt;font color=\\&quot;comment\\&quot;&gt;117例&lt;/font&gt; \\n &gt;VIP用户反馈:&lt;font color=\\&quot;comment\\&quot;&gt;15例&lt;/font&gt;&quot; } } 参数 是否必填 说明 msgtype 是 消息类型，此时固定为markdown content 是 markdown内容，最长不超过 4096 个字节，必须是utf8编码 目前支持的 markdown 语法是如下的子集： 标题 （支持 1 至 6 级标题，注意#与文字中间要有空格） # 标题一 ## 标题二 ### 标题三 #### 标题四 ##### 标题五 ###### 标题六 加粗 **bold** 链接 [这是一个链接](http://work.weixin.qq.com/api/doc) 行内代码段（暂不支持跨行） `code` 引用 &gt; 引用文字 字体颜色(只支持 3 种内置颜色) &lt;font color=&quot;info&quot;&gt;绿色&lt;/font&gt; &lt;font color=&quot;comment&quot;&gt;灰色&lt;/font&gt; &lt;font color=&quot;warning&quot;&gt;橙红色&lt;/font&gt; 图片类型 { &quot;msgtype&quot;: &quot;image&quot;, &quot;image&quot;: { &quot;base64&quot;: &quot;DATA&quot;, &quot;md5&quot;: &quot;MD5&quot; } } 参数 是否必填 说明 msgtype 是 消息类型，此时固定为 image base64 是 图片内容的base64编码 md5 是 图片内容（base64编码前）的md5值 注：图片（base64编码前）最大不能超过2M，支持JPG,PNG格式 图文类型 { &quot;msgtype&quot;: &quot;news&quot;, &quot;news&quot;: { &quot;articles&quot;: [ { &quot;title&quot;: &quot;中秋节礼品领取&quot;, &quot;description&quot;: &quot;今年中秋节公司有豪礼相送&quot;, &quot;url&quot;: &quot;URL&quot;, &quot;picurl&quot;: &quot;http://res.mail.qq.com/node/ww/wwopenmng/images/independent/doc/test_pic_msg1.png&quot; } ] } } 参数 是否必填 说明 msgtype 是 消息类型，此时固定为 news articles 是 图文消息，一个图文消息支持 1 到 8 条图文 title 是 标题，不超过 128 个字节，超过会自动截断 description 否 描述，不超过 512 个字节，超过会自动截断 url 是 点击后跳转的链接。 picurl 否 图文消息的图片链接，支持JPG、PNG格式，较好的效果为大图 1068455，小图 150150。 钉钉 获取自定义机器人``webhook` 在机器人管理页面选择“自定义”机器人，输入机器人名字并选择要发送消息的群，同时可以为机器人设置机器人头像。 完成必要的安全设置（至少选择一种），勾选 我已阅读并同意《自定义机器人服务及免责条款》，点击“完成”。安全设置目前有3种方式，设置说明见下文介绍。 完成安全设置后，复制出机器人的Webhook地址，可用于向这个群发送消息 import json import requests # 向钉钉机器人发消息(安全设置为加签) def sendDingDing(msg): token = '这是token' timeStamp, sign = makeDingDingRobotSign() url = f'https://oapi.dingtalk.com/robot/send?access_token={token}&amp;timestamp={timeStamp}&amp;sign={sign}' headers = {'Content-Type': 'application/json'} data = {&quot;msgtype&quot;: &quot;text&quot;, &quot;text&quot;: {&quot;content&quot;: msg}} res = requests.post(url, json.dumps(data), headers=headers) res.encoding = 'utf-8' return res.text 安全设置 安全设置目前有3种方式： 方式一，自定义关键词 最多可以设置10个关键词，消息中至少包含其中1个关键词才可以发送成功。 例如：添加了一个自定义关键词：监控报警 则这个机器人所发送的消息，必须包含 监控报警 这个词，才能发送成功。 方式二，加签 把timestamp+&quot;\\n&quot;+密钥当做签名字符串，使用HmacSHA256算法计算签名，然后进行Base64 encode，最后再把签名参数再进行urlEncode，得到最终的签名（需要使用UTF-8字符集）。 参数 说明 timestamp 当前时间戳，单位是毫秒，与请求调用时间误差不能超过1小时 secret 密钥，机器人安全设置页面，加签一栏下面显示的SEC开头的字符串 python3生成签名和时间戳示例 import base64 import hashlib import hmac import time import urllib # 生成钉钉机器人的签名和时间戳 def makeDingDingRobotSign(): signKey = '这是secret' timeStamp = int(round(time.time() * 1000)) key = signKey.encode(&quot;utf-8&quot;) preSignStr = f'{timeStamp}\\n{signKey}'.encode(&quot;utf-8&quot;) hmacStr = hmac.new(key, preSignStr, digestmod=hashlib.sha256).digest() base64Str = base64.b64encode(hmacStr) sign = urllib.parse.quote_plus(base64Str) return timeStamp, sign 把timestamp和第一步得到的签名值拼接到URL中。 参数 说明 timestamp 第一步使用到的时间戳 sign 第一步得到的签名值 方式三，IP地址（段） 设定后，只有来自IP地址范围内的请求才会被正常处理。支持两种设置方式：IP、IP段，暂不支持IPv6地址白名单，格式如下: 注意：安全设置的上述三种方式，需要至少设置其中一种，以进行安全保护。校验不通过的消息将会发送失败，错误如下： //消息内容中不包含任何关键词 { &quot;errcode&quot;: 310000, &quot;errmsg&quot;: &quot;keywords not in content&quot; } //timestamp 无效 { &quot;errcode&quot;: 310000, &quot;errmsg&quot;: &quot;invalid timestamp&quot; } //签名不匹配 { &quot;errcode&quot;: 310000, &quot;errmsg&quot;: &quot;sign not match&quot; } //IP地址不在白名单 { &quot;errcode&quot;: 310000, &quot;errmsg&quot;: &quot;ip X.X.X.X not in whitelist&quot; } 消息类型及数据格式 text类型 { &quot;msgtype&quot;: &quot;text&quot;, &quot;text&quot;: { &quot;content&quot;: &quot;我就是我, 是不一样的烟火@156xxxx8827&quot; }, &quot;at&quot;: { &quot;atMobiles&quot;: [&quot;156xxxx8827&quot;, &quot;189xxxx8325&quot;], &quot;isAtAll&quot;: false } } 参数 参数类型 必须 说明 msgtype String 是 消息类型，此时固定为：text content String 是 消息内容 atMobiles Array 否 被@人的手机号(在content里添加@人的手机号) isAtAll bool 否 @所有人时：true，否则为：false link类型 { &quot;msgtype&quot;: &quot;link&quot;, &quot;link&quot;: { &quot;text&quot;: &quot;这个即将发布的新版本，创始人xx称它为“红树林”。 而在此之前，每当面临重大升级，产品经理们都会取一个应景的代号，这一次，为什么是“红树林”？&quot;, &quot;title&quot;: &quot;时代的火车向前开&quot;, &quot;picUrl&quot;: &quot;&quot;, &quot;messageUrl&quot;: &quot;https://www.dingtalk.com/s?__biz=MzA4NjMwMTA2Ng==&amp;mid=2650316842&amp;idx=1&amp;sn=60da3ea2b29f1dcc43a7c8e4a7c97a16&amp;scene=2&amp;srcid=09189AnRJEdIiWVaKltFzNTw&amp;from=timeline&amp;isappinstalled=0&amp;key=&amp;ascene=2&amp;uin=&amp;devicetype=android-23&amp;version=26031933&amp;nettype=WIFI&quot; } } 参数 参数类型 必须 说明 msgtype String 是 消息类型，此时固定为：link title String 是 消息标题 text String 是 消息内容。如果太长只会部分展示 messageUrl String 是 点击消息跳转的URL picUrl String 否 图片URL markdown类型 { &quot;msgtype&quot;: &quot;markdown&quot;, &quot;markdown&quot;: { &quot;title&quot;: &quot;杭州天气&quot;, &quot;text&quot;: &quot;#### 杭州天气 @156xxxx8827\\n&quot; + &quot;&gt; 9度，西北风1级，空气良89，相对温度73%\\n\\n&quot; + &quot;&gt; ![screenshot](https://gw.alicdn.com/tfs/TB1ut3xxbsrBKNjSZFpXXcXhFXa-846-786.png)\\n&quot; + &quot;&gt; ###### 10点20分发布 [天气](http://www.thinkpage.cn/) \\n&quot; }, &quot;at&quot;: { &quot;atMobiles&quot;: [&quot;156xxxx8827&quot;, &quot;189xxxx8325&quot;], &quot;isAtAll&quot;: false } } 参数 类型 必选 说明 msgtype String 是 此消息类型为固定markdown title String 是 首屏会话透出的展示内容 text String 是 markdown格式的消息 atMobiles Array 否 被@人的手机号(在text内容里要有@手机号) isAtAll bool 否 @所有人时：true，否则为：false 说明：目前只支持md语法的子集，具体支持的元素如下 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 &gt; A man who stands for nothing will fall for anything. **bold** *italic* [this is a link](http://name.com) ![](http://name.com/pic.jpg) - item1 - item2 1. item1 2. item2 整体跳转ActionCard类型 { &quot;actionCard&quot;: { &quot;title&quot;: &quot;乔布斯 20 年前想打造一间苹果咖啡厅，而它正是 Apple Store 的前身&quot;, &quot;text&quot;: &quot;![screenshot](@lADOpwk3K80C0M0FoA) ### 乔布斯 20 年前想打造的苹果咖啡厅 Apple Store 的设计正从原来满满的科技感走向生活化，而其生活化的走向其实可以追溯到 20 年前苹果一个建立咖啡馆的计划&quot;, &quot;hideAvatar&quot;: &quot;0&quot;, &quot;btnOrientation&quot;: &quot;0&quot;, &quot;singleTitle&quot;: &quot;阅读全文&quot;, &quot;singleURL&quot;: &quot;https://www.dingtalk.com/&quot; }, &quot;msgtype&quot;: &quot;actionCard&quot; } 参数 类型 必选 说明 msgtype string true 此消息类型为固定actionCard title string true 首屏会话透出的展示内容 text string true markdown格式的消息 singleTitle string true 单个按钮的方案。(设置此项和singleUR后btns无效) singleURL string true 点击singleTitle按钮触发的URL btnOrientation string false 0-按钮竖直排列，1-按钮横向排列 hideAvatar string false 0-正常发消息者头像，1-隐藏发消息者头像 通过整体跳转ActionCard类型消息发出的消息样式如下： 独立跳转ActionCard类型 { &quot;actionCard&quot;: { &quot;title&quot;: &quot;乔布斯 20 年前想打造一间苹果咖啡厅，而它正是 Apple Store 的前身&quot;, &quot;text&quot;: &quot;![screenshot](@lADOpwk3K80C0M0FoA)### 乔布斯20 年前想打造的苹果咖啡厅Apple Store的设计正从原来满满的科技感走向生活化，而其生活化的走向其实可以追溯到 20 年前苹果一个建立咖啡馆的计划&quot;, &quot;hideAvatar&quot;: &quot;0&quot;, &quot;btnOrientation&quot;: &quot;0&quot;, &quot;btns&quot;: [{ &quot;title&quot;: &quot;内容不错&quot;, &quot;actionURL&quot;: &quot;https://www.dingtalk.com/&quot; }, { &quot;title&quot;: &quot;不感兴趣&quot;, &quot;actionURL&quot;: &quot;https://www.dingtalk.com/&quot; }] }, &quot;msgtype&quot;: &quot;actionCard&quot; } 参数 类型 必选 说明 msgtype string true 此消息类型为固定actionCard title string true 首屏会话透出的展示内容 text string true markdown格式的消息 btns array true 按钮的信息：title-按钮方案，actionURL-点击按钮触发的URL btnOrientation string false 0-按钮竖直排列，1-按钮横向排列 hideAvatar string false 0-正常发消息者头像，1-隐藏发消息者头像 通过独立跳转ActionCard类型消息发出的消息样式如下： FeedCard类型 { &quot;feedCard&quot;: { &quot;links&quot;: [{ &quot;title&quot;: &quot;时代的火车向前开&quot;, &quot;messageURL&quot;: &quot;https://www.dingtalk.com/s?__biz=MzA4NjMwMTA2Ng==&amp;mid=2650316842&amp;idx=1&amp;sn=60da3ea2b29f1dcc43a7c8e4a7c97a16&amp;scene=2&amp;srcid=09189AnRJEdIiWVaKltFzNTw&amp;from=timeline&amp;isappinstalled=0&amp;key=&amp;ascene=2&amp;uin=&amp;devicetype=android-23&amp;version=26031933&amp;nettype=WIFI&quot;, &quot;picURL&quot;: &quot;https://www.dingtalk.com/&quot; }, { &quot;title&quot;: &quot;时代的火车向前开2&quot;, &quot;messageURL&quot;: &quot;https://www.dingtalk.com/s?__biz=MzA4NjMwMTA2Ng==&amp;mid=2650316842&amp;idx=1&amp;sn=60da3ea2b29f1dcc43a7c8e4a7c97a16&amp;scene=2&amp;srcid=09189AnRJEdIiWVaKltFzNTw&amp;from=timeline&amp;isappinstalled=0&amp;key=&amp;ascene=2&amp;uin=&amp;devicetype=android-23&amp;version=26031933&amp;nettype=WIFI&quot;, &quot;picURL&quot;: &quot;https://www.dingtalk.com/&quot; }] }, &quot;msgtype&quot;: &quot;feedCard&quot; } 参数 类型 必选 说明 msgtype string true 此消息类型为固定feedCard title string true 单条信息文本 messageURL string true 点击单条信息到跳转链接 picURL string true 单条信息后面图片的URL 通过FeedCard类型消息发出的消息样式如下： ","link":"https://preszang.github.io/post/8iH4xT1qu/"},{"title":" 一个测试dubbo接口的小工具","content":"测试dubbo接口的小工具 flask+kazoo+telnet kazoo是一个Python库，旨在使得Python能够轻松、便捷的使用zookeeper。 Flask是一个使用 Python 编写的轻量级 Web 应用框架。 从 2.0.5 版本开始，dubbo 开始支持通过 telnet 命令来进行服务治理。 一、启动说明 git clone https://gitee.com/prestest/dubboTestTool 修改配置文件[config.py] config = { 'zooKeeper': [ # 需要替换zk的地址 'zk.xxx.cn:2181' ], 'robot': { # status的状态表示是否发送消息 'dingTalk': { 'status': False, # 需要替换钉钉的签名key 'signKey': '[需要替换钉钉的签名key]', # 需要替换钉钉的webhook_key 'token': '[需要替换钉钉的webhook_key]' }, 'qyWechat': { 'status': False, # 需要替换企业微信的webhook_key 'token': '[需要替换企业微信的webhook_key]' } } 安装第三方库 # flask、kazoo、requests pip install -r requirements.txt 启动方式 python run.py 打开网页 localhost:5000 # 默认端口为5000，可在`run.py`中修改 app.run(host='0.0.0.0', port=5000, debug=True) 二、在页面上请求 选择需要测试的ServiceAPI，可模糊搜索，点击搜索。 出现方法列表后，选择要测试的Method，可模糊搜索 输入相应参数 具体参数要求内容可向研发咨询或查看代码或者接口文档。 参数顺序必须与接口的参数顺序保持一致 如 接口为 Method(String userid,Integer number)，则只需输入参数为 &quot;userid1&quot;,456 当参数为Map&lt;Integer,T&gt;，key的类型为Integer时，建议指定类型&quot;class&quot;:&quot;java.util.HashMap&quot; 当类型转换失败的时候，可以通过增加class属性指定需要转换类，类的路径查看代码或者向研发询问即可 { &quot;name&quot;:&quot;zhangsan&quot;, &quot;age&quot;:12, &quot;class&quot;:&quot;org.apache.dubbo.qos.legacy.service.Person&quot; } 需要测试其他api，则需要重新打开页面或者，点击左上角的刷新按钮。 三、以http的方式调用 可以在postman中发起http请求，去调用dubbo接口。将常用的请求通过postman保存下来，或者其他方式使用 请求方式：get/post 参数请求格式：raw ，参数用逗号隔开。或者直接在地址后追加原始参数 地址：http://localhost:5000/d2h/{service}/{method} ","link":"https://preszang.github.io/post/KST7ZTnOT/"},{"title":"解决  No module named 'pip'","content":"问题再现 今天 安装其它python包时，莫名报了这个错 Traceback (most recent call last): File &quot;d:\\program files\\python38\\lib\\runpy.py&quot;, line 194, in _run_module_as_main return _run_code(code, main_globals, None, File &quot;d:\\program files\\python38\\lib\\runpy.py&quot;, line 87, in _run_code exec(code, run_globals) File &quot;D:\\Program Files\\python38\\Scripts\\pip.exe\\__main__.py&quot;, line 5, in &lt;module&gt; ModuleNotFoundError: No module named 'pip' 解决方案 python -m ensurepip python -m pip install --upgrade pip 若第二步 更新太慢可更换软件源 python -m pip install --upgrade pip -i https://pypi.tuna.tsinghua.edu.cn/simple/ 问题解决 Downloading https://pypi.tuna.tsinghua.edu.cn/packages/5a/4a/39400ff9b36e719bdf8f31c99fe1fa7842a42fa77432e584f707a5080063/pip-20.2.2-py2.py3-none-any.whl (1.5MB) |████████████████████████████████| 1.5MB 130kB/s Installing collected packages: pip Found existing installation: pip 19.2.3 Uninstalling pip-19.2.3: Successfully uninstalled pip-19.2.3 Successfully installed pip-20.2.2 pip -V pip 20.2.2 from d:\\program files\\python38\\lib\\site-packages\\pip (python 3 ","link":"https://preszang.github.io/post/CmAoWM_xt/"},{"title":"在pypi上发布python包","content":"在pypi上发布python包 一、注册账号 到pypi（https://pypi.org/）上注册自己的用户, 点击“Register”，填写自己的用户名，密码，邮箱。 如果期望测试发布，同时需要注册pypitest账号（可以采用相同的用户名和密码）。pypitest官网：https://test.pypi.org/ 二、准备setup 文件 准备setup.py文件，它是放在你包的根目录的，这一步至关重要，包括要发布的包名字，版本，license，描述，特性（classifier)等等。 下面是setup.py文件的示例内容，基本上只需要在这个上面修改就行了，具体如下： #!/usr/bin/env python # coding:utf-8 from setuptools import find_packages, setup setup( name='&lt;项目的名称&gt;', version='&lt;项目的版本&gt;', description='&lt;项目的简单描述&gt;', long_description=open('README.rst').read(), author='&lt;项目的作者&gt;', author_email='&lt;作者邮箱&gt;', maintainer='&lt;维护人员的名字&gt;', maintainer_email='&lt;维护人员的邮箱&gt;', packages=find_packages(), platforms=[&quot;all&quot;], url='&lt;项目的网址，可以使用自己github的url&gt;', license='BSD License', classifiers=[ 'Development Status :: 4 - Beta', 'Operating System :: OS Independent', 'Intended Audience :: Developers', 'License :: OSI Approved :: BSD License', 'Programming Language :: Python', 'Programming Language :: Python :: 2.7', 'Programming Language :: Python :: Implementation :: CPython', 'Programming Language :: Python :: Implementation :: PyPy' ], ) version：这个简单，就是包的发布的版本，可以直接写在这，也可以从其他地方引用过来。 long_description：必须是rst（reStructuredText )格式的，因为这个里面的内容是显示在pypi包首页上 packages：申明你的包里面要包含的目录 install_requires：申明依赖包，安装包时pip会自动安装 大名鼎鼎的requests库的作者大神kennethreitz为大家准备了一个仓库作为一个setup.py的很好的模板，当然你也可以自己手写setup.py。 git clone https://github.com/kennethreitz/setup.py 三、最终的代码结构 │ LICENSE │ MANIFEST.in │ README.rst │ setup.py │ └─condition_chain core.py __init__.py __version__.py 四、编写核心代码 接下来我们就可以编写自己的代码了，要注意源代码文件夹（仓库里的my_package文件夹）的名字与setup.py里配置的包名（Name）要一致。 另外在重新上传之前我们要修改__version__.py里的版本号，以免覆盖了以前的上传（相信会有人是需要之前版本的库的）。 五、打包上传 打包一个wheels格式的包，使用下面的命令搞定： python setup.py bdist_wheel --universal 上传生成的包，可以使用twine上传 pip install twine twine upload dist/* 会提示你前面注册的用户名和密码。一切搞定，你的包现在可以通过pip在任何地方安装了。 六、报错解决 1.HTTPError: 403 Client Error: The user 'xxx' isn't allowed to upload to project '&lt;项目的名称&gt;'. See https://pypi.org/help/#project-name for more information. for url: https://upload.pypi.org/legacy/ 出现这个报错一般是python包名冲突，换个包名就可以了 2.HTTPError: 403 Client Error: Invalid or non-existent authentication information. for url: https://upload.pypi.org/legacy/ 出现这个报错一般是用户名和密码错误了，要去网站上验证一下你前面注册的用户名和密码。 ","link":"https://preszang.github.io/post/jyh3VyyYn/"},{"title":"selenium之破解腾讯滑块验证码","content":"selenium之破解腾讯滑块验证码 就是图中的这种滑块验证码 先贴源码，基本思路就是 用PIL，然后对比 验证码图片 有缺口和无缺口的不同，计算出偏移量，模拟滑块滑动。 import time import random import io from PIL import Image from urllib.request import urlopen from selenium.webdriver.common.action_chains import ActionChains def openImgUrl(src): # 打开图片链接 ImgUrl = urlopen(src, timeout=1).read() img = Image.open(io.BytesIO(ImgUrl)) # 恢复原始大小 imgResize = (int(i // 2) for i in img.size) return img.resize(imgResize, Image.ANTIALIAS) def getImg(dr): dr.switch_to.frame('tcaptcha_iframe') src1 = dr.find_element_by_id('slideBg').get_attribute('src') src2 = src1.replace('img_index=1', 'img_index=0') return openImgUrl(src1), openImgUrl(src2) # 比较两张图片同一点上的像数值，差距大于设置标准返回False def isPixel(img1, img2, x, y): i = 100 px1, px2 = img1.load()[x, y], img2.load()[x, y] r, g, b = [abs(p1 - p2) for p1, p2 in zip(px1, px2)] return True if r &lt; i and g &lt; i and b &lt; i else False # 获取缺口的偏移量，两张图片对比,(i,j)像素点的RGB差距，过大则该x为偏移值 def getOffset(img1, img2): offset, distance = None, 70 x, y = img1.size for i in range(distance, x): for j in range(y): if not isPixel(img1, img2, i, j): offset = i return offset return offset # 计算滑块的移动轨迹 滑块并不是从0开始移动，有一个初始值 def getTrack(offset): offset -= 30 return [offset / 4] * 4 # 模拟释放鼠标抖动 def shake(dr): ActionChains(dr).move_by_offset(xoffset=-2, yoffset=0).perform() ActionChains(dr).move_by_offset(xoffset=2, yoffset=0).perform() time.sleep(random.random()) # 按轨迹移动 def move(dr, track): for i in track: ActionChains(dr).move_by_offset(xoffset=i, yoffset=0).perform() time.sleep(random.random() / 100) time.sleep(random.random()) # 完成拖动操作 def sliderBtn(dr, track): btn = dr.find_element_by_id('tcaptcha_drag_thumb') ActionChains(dr).click_and_hold(btn).perform() # 按住按钮不放 move(dr, track) # 按正向轨迹移动 move(dr, [-1, -0.5, -1]) # 按逆向轨迹移动 shake(dr) # 模拟人手抖动 ActionChains(dr).release().perform() # 松开滑块按钮 # 处理验证码 def dealCaptcha(dr): time.sleep(3) img1, img2 = getImg(dr) offset = getOffset(img1, img2) track = getTrack(offset) sliderBtn(dr, track) 基于selenium的webdriver from selenium import webdriver if __name__ == '__main__': dr = webdriver.Chrome('chromedriver的地址') dealCaptcha(dr) ","link":"https://preszang.github.io/post/VseyNxd0Y/"},{"title":"2020 年最热的 Python 库年度 Top 10 ","content":"1、Typer Typer 跟 FastAPI 的原理相同，都是 Python 上用来构建 API 服务的一个高性能框架。 它是 FastAPI 的升级版，不仅能够准确地记录代码，还能够轻松地进行 CLI 验证。 Typer 易于学习和使用，不需要用户阅读复杂的教程文档即可上手。支持编辑器（如 VSCode）代码自动补全，提高开发人员的开发效率，减少 bug 的数量。 其次，Typer 还能配合命令行神器 Click 使用，就可以利用 Click 的优点和插件，实现更复杂的功能。 开源地址：https://github.com/tiangolo/typer 2、Rich 谁规定 CLI 界面一定得是黑白的？它也可以是彩色的。 Rich API 不仅能够在终端输出提供丰富的彩色文本和精美的格式，还提供了精美的表格、进度条、编辑器、追踪器、语法高亮等。如下图所示。 它还可以安装在 Python REPL 上，所有的数据结构都可以漂亮地输出或标注。 总而言之，它是彩色的、漂亮的、强大的。 Rich 兼容性也不错，适用于 Linux，Mac 和 Windows 等多种系统。真彩色/表情符号可与新的 Windows 终端一起使用。 但是请注意，Rich 必须要 Python 3.6.1 或以上版本。 开源地址：https://github.com/willmcgugan/rich 3、Dear PyGui 如上所示，虽然终端应用程序可以做成很漂亮的样子。但是，你可能还需要一个真正的 GUI。 Dear PyGui 是一个便于使用、功能强大的 Python GUI 框架。但是它与其他的 Python GUI 却有着根本上的不同。 它使用了即时模式范式和计算机的 GPU 来实现动态界面。即时模式范式在视频游戏中非常流行，这意味着它的动态 GUI 不需要保留任何数据，而是逐帧独立绘制的。同时，它还使用 GPU 来建构动态界面。 Dear PyGui 还可以绘图、创建主题、创建 2D 游戏，还拥有一些小工具，比如说内置文档、日志记录、源代码查看器之类的，这些小工具可以协助 App 的开发。 支持它的系统有：Windows 10（DirectX 11），Linux（OpenGL 3）和 macOS（Metal）等。 开源地址：https://github.com/hoffstadt/DearPyGui 4、PrettyErrors PrettyErrors 是一个精简 Python 错误信息的工具，特点是界面十分简洁友好。 它最显著的功能是支持在终端进行彩色输出，标注出文件栈踪迹，发现错误信息，过滤掉冗余信息，提取出关键部分，并且进行彩色标注，从而提高开发者的效率。 而且它可以不用安装，直接被导入项目中使用，但是需要先配置一些参数，其导入和配置的参数如下： 开源地址：https://github.com/onelivesleft/PrettyErrors 5、Diagrams 程序员在编程的时候，有时候需要跟同事解释他设计的程序代码之间复杂的结构关系，然而这不是一两句话能说清楚的，需要画表或者做脉络图。 一般情况下，程序员使用 GUI 工具处理图表，并将文稿进行可视化处理。但是还有更好的方法，比如说使用 Diagrams 库。 Diagrams 让不需要任何设计类工具，直接在 Python 代码中绘制云系统结构。它们的图标来自多家云服务商，包括 AWS, Azure, GCP 等。 仅需几行代码，就可以简单地创造出箭头符号和结构图。 由于它使用 Graphviz 来渲染图，所以还需要先安装好 Graphviz。 开源地址：https://github.com/mingrammer/diagrams 6、Hydra and OmegaConf 在做机器学习项目的时候，需要做一大堆的环境配置工作。因此，在一些复杂的应用程序中，配置管理工作也相应变得复杂。 Hydra 可以使配置工作变得简单。它能够从命令行或者配置文件中覆盖部分出来，无需维护相似的配置文件，用组合的方式进行配置，从而加快了实验运行速度。 Hydra 兼容性强，拥有含插件的结构，能够很好地与开发者的操作文件融合。它的插件还可以实现直接通过命令行，就把代码发布到 AWS 或者其他云端系统。 Hydra 也离不开 OmegaConf，两者关系密不可分，OmegaConf 为 Hydra 的分层配置系统提供了协同的 API，二者协同运作可支持 YAML、配置文件、对象、CLI 参数等。 开源地址：https://github.com/facebookresearch/hydra 开源地址：https://github.com/omry/omegaconf 7、PyTorch Lightning PyTorch Lightning 也是 Facebook 的一个研究成果。它是一个轻巧的 PyTorch 包装器，用于高性能 AI 研究，其最重要的特征是能够解析 PyTorch代码，让代码研究成分和工程成分的分离。 它的扩展模型可以在任何硬件（CPU、GPU、TPU）上运行，且容易被复制，删除了大量的文件样本，保持了自身的灵活性，运行速度快。 Lightning 能够使 DL / ML 研究的 40 多个部分实现自动化，例如 GPU训练、分布式 GPU（集群）训练、TPU 训练等等…… 因为 Lightning 将可以将文件自动导出到 ONNX 或T orchScript，所以它适用于进行快速推理的 AI 研究员、BERT 或者自监督学习的研究团队等。 开源地址：https://github.com/PyTorchLightning/PyTorch-lightning 8、Hummingbird Hummingbird 是微软的一项研究成果，它能够将已经训练好的 ML 模型汇编成张量计算，从而不需要设计新的模型。 还允许用户使用神经网络框架（例如 PyTorch）来加速传统的 ML 模型。 它的推理 API 跟 sklearn 范例十分相似，都可以重复使用现有的代码，但是它是用 Hummingbird 生成的代码去实现的。 Hummingbird 还在 Sklearn API 之后提供了一个方便的统一推理API。这样就可以将 Sklearn 模型与 Hummingbird 生成的模型互换，而无需更改推理代码。 它之所以被重点关注，还因为它能够支持多种多样的模型和格式。 到目前为止，Hummingbird 支持 PyTorch、TorchScript、ONNX 和 TVM 等各种 ML 模型。 开源地址：https://github.com/microsoft/hummingbird 9、HiPlot 由于 ML 模型变得越来越复杂，还有很多超参数，于是就需要用到 HiPlot。HiPlot 是今年 3 月 Facebook 发行的一个库，主要用于处理高维数据。 Facebook AI 通过几十个超参数和 10 万多个实验，利用 HiPlot，来分析深度神经网络。 它是用平行图和其他的图像方式，帮助AI研究者发现高维数据的相关性和模型，是一款轻巧的交互式可视化工具。 HiPlot 与其他可视化工具相比，有其特有的优点： 首先，它的互动性强，因为平行图是交互式的，所以能够满足多种情况下的图像可视化。 其次，它简单易用，可以通过 IPython Notebook 或者通过带有“ hiplot”命令的服务直接使用。 它还有具有可扩展性。默认情况下，HiPlot 的 Web 服务可以解析 CSV 或 JSON 文件，还可以为其提供自定义 Python 解析器，将实验转换为 HiPlot 实验。 开源地址：https://github.com/facebookresearch/hiplot 参考链接：https://ai.facebook.com/blog/hiplot-high-dimensional-interactive-plots-made-easy 10、Scalene Scalene 是一个用于 Python 脚本的 CPU 和内存分析器，能够正确处理多线程代码，还能区分 Python 代码和本机代码的运行时间。 你不需要修改代码，只需运行 Scalene 脚本，它就会生成一个文本形式的报告，显示出每一行代码的 CPU 和内存的使用情况。通过这个文本报告，开发人员可以提高代码的效率。 Scalene 的速度快、准确率高，还能够对高耗能的代码行进行标注。 开源地址https://github.com/emeryberger/scalene 除了以上 10 个，还有多个高性能的 Python 库被点名了，例如 Norfair、Quart、Alibi-detect、Einops……等等。 那么，你今年有发现好用的 Python 库吗？ 参考链接：https://tryolabs.com/blog/2020/12/21/top-10-python-libraries-of-2020/ 参考链接：https://www.upgrad.com/blog/reasons-why-python-popular-with-developers/ ","link":"https://preszang.github.io/post/eeYWta-p7/"},{"title":"python+selenium自动化UI测试基本教程","content":"一、安装selenium 1. 安装python 打开 Python官网，找到Download, 安装最新版python，python 的安装方法再此不详细介绍了。 2. 安装selenium 确保pip命令可用，如果提示“pip不是内部或外部命令”，需要将将pip的安装目录添加到环境变量PATH下面。 接下来通过pip命令安装Selenium: pip install selenium Collecting selenium Downloading selenium-3.4.3-py2.py3-none-any.whl (931kB) 26% |████████ | 245kB 576kB/s eta 0:00:02 27% |█████████ | 256kB 570kB/s eta 0:00:02 28% |██████████ | 266kB 536kB/s eta 0:00:0 29% |███████████ | 276kB 530kB/s eta 0:00:0 30% |████████████ | 286kB 586kB/s eta 0:00:0 …… 打开编辑器，输入以下代码，如果执行报错，请看下一节 from selenium import webdriver driver = webdriver.Chrome() driver.get('https://www.baidu.com') print(driver.title) driver.quit() 二、selenium3 浏览器驱动 下载浏览器驱动 当selenium升级到3.0之后，对不同的浏览器驱动进行了规范。如果想使用selenium驱动不同的浏览器，必须单独下载并设置不同的浏览器驱动。（注：部分浏览器驱动地址需要科学上网。） Firefox浏览器驱动：geckodriver Chrome浏览器驱动：chromedriver , taobao备用地址[常用] IE浏览器驱动：IEDriverServer Edge浏览器驱动：MicrosoftWebDriver Opera浏览器驱动：operadriver PhantomJS浏览器驱动：phantomjs 设置浏览器驱动 设置浏览器的地址非常简单。 我们可以手动创建一个存放浏览器驱动的目录，如： C:\\driver , 将下载的浏览器驱动文件（例如：chromedriver、geckodriver）丢到该目录下。 验证不同的浏览器驱动是否正常使用。 from selenium import webdriver driver = webdriver.Firefox() # Firefox浏览器 driver = webdriver.Chrome() # Chrome浏览器 driver = webdriver.Ie() # Internet Explorer浏览器 driver = webdriver.Edge() # Edge浏览器 driver = webdriver.Opera() # Opera浏览器 driver = webdriver.PhantomJS() # PhantomJS 三、selenium元素定位 selenium定位方法 Selenium提供了8种定位方式。 id、name、class name、tag name、link text、partial link text、xpath、css selector 这8种定位方式在Python selenium中所对应的方法为： find_element_by_id() find_element_by_name() find_element_by_class_name() find_element_by_tag_name() find_element_by_link_text() find_element_by_partial_link_text() find_element_by_xpath() find_element_by_css_selector() 定位方法的用法 假如我们有一个Web页面，通过前端工具（如，Firebug）查看到一个元素的属性是这样的。 &lt;html&gt; &lt;head&gt; &lt;body link=&quot;#0000cc&quot;&gt; &lt;a id=&quot;result_logo&quot; href=&quot;/&quot; onmousedown=&quot;return c({'fm':'tab','tab':'logo'})&quot;&gt; &lt;form id=&quot;form&quot; class=&quot;fm&quot; name=&quot;f&quot; action=&quot;/s&quot;&gt; &lt;span class=&quot;soutu-btn&quot;&gt;&lt;/span&gt; &lt;input id=&quot;kw&quot; class=&quot;s_ipt&quot; name=&quot;wd&quot; value=&quot;&quot; maxlength=&quot;255&quot; autocomplete=&quot;off&quot;&gt; 我们的目的是要定位input标签的输入框。 通过id定位: dr.find_element_by_id(&quot;kw&quot;) 通过name定位: dr.find_element_by_name(&quot;wd&quot;) 通过class name定位: dr.find_element_by_class_name(&quot;s_ipt&quot;) 通过tag name定位: dr.find_element_by_tag_name(&quot;input&quot;) 通过xpath定位，xpath定位有N种写法，这里列几个常用写法: dr.find_element_by_xpath(&quot;//*[@id='kw']&quot;) dr.find_element_by_xpath(&quot;//*[@name='wd']&quot;) dr.find_element_by_xpath(&quot;//input[@class='s_ipt']&quot;) dr.find_element_by_xpath(&quot;/html/body/form/span/input&quot;) dr.find_element_by_xpath(&quot;//span[@class='soutu-btn']/input&quot;) dr.find_element_by_xpath(&quot;//form[@id='form']/span/input&quot;) dr.find_element_by_xpath(&quot;//input[@id='kw' and @name='wd']&quot;) 通过css定位，css定位有N种写法，这里列几个常用写法: dr.find_element_by_css_selector(&quot;#kw&quot;) dr.find_element_by_css_selector(&quot;[name=wd]&quot;) dr.find_element_by_css_selector(&quot;.s_ipt&quot;) dr.find_element_by_css_selector(&quot;html &gt; body &gt; form &gt; span &gt; input&quot;) dr.find_element_by_css_selector(&quot;span.soutu-btn&gt; input#kw&quot;) dr.find_element_by_css_selector(&quot;form#form &gt; span &gt; input&quot;) 接下来，我们的页面上有一组文本链接。 &lt;a class=&quot;mnav&quot; href=&quot;http://news.baidu.com&quot; name=&quot;tj_trnews&quot;&gt;新闻&lt;/a&gt; &lt;a class=&quot;mnav&quot; href=&quot;http://www.hao123.com&quot; name=&quot;tj_trhao123&quot;&gt;hao123&lt;/a&gt; 通过link text定位: dr.find_element_by_link_text(&quot;新闻&quot;) dr.find_element_by_link_text(&quot;hao123&quot;) 通过link text定位: dr.find_element_by_partial_link_text(&quot;新&quot;) dr.find_element_by_partial_link_text(&quot;hao&quot;) dr.find_element_by_partial_link_text(&quot;123&quot;) 关于xpaht和css的定位比较复杂，请参考xpath语法、css选择器 四、控制浏览器操作 控制浏览器窗口大小 有时候我们希望能以某种浏览器尺寸打开，让访问的页面在这种尺寸下运行。例如可以将浏览器设置成移动端大小(480* 800)，然后访问移动站点，对其样式进行评估；WebDriver提供了set_window_size()方法来设置浏览器的大小。 from selenium import webdriver driver = webdriver.Firefox() driver.get(&quot;http://m.baidu.com&quot;) # 参数数字为像素点 print(&quot;设置浏览器宽480、高800显示&quot;) driver.set_window_size(480, 800) driver.quit() 在PC端执行自动化测试脚本大多的情况下是希望浏览器在全屏幕模式下执行，那么可以使用maximize_window()方法使打开的浏览器全屏显示，其用法与set_window_size() 相同，但它不需要参数。 控制浏览器后退、前进 在使用浏览器浏览网页时，浏览器提供了后退和前进按钮，可以方便地在浏览过的网页之间切换，WebDriver也提供了对应的back()和forward()方法来模拟后退和前进按钮。下面通过例子来演示这两个方法的使用。 from selenium import webdriver driver = webdriver.Firefox() #访问百度首页 first_url= 'http://www.baidu.com' print(&quot;now access %s&quot; %(first_url)) driver.get(first_url) #访问新闻页面 second_url='http://news.baidu.com' print(&quot;now access %s&quot; %(second_url)) driver.get(second_url) #返回（后退）到百度首页 print(&quot;back to %s &quot;%(first_url)) driver.back() #前进到新闻页 print(&quot;forward to %s&quot;%(second_url)) driver.forward() driver.quit() 为了看清脚本的执行过程，下面每操作一步都通过print()来打印当前的URL地址。 刷新页面 driver.refresh() #刷新当前页面 五、WebDriver常用方法 点击和输入 前面已经学习了定位元素， 定位只是第一步， 定位之后需要对这个元素进行操作， 或单击（按钮） 或输入（输入框） ， 下面就来认识 WebDriver 中最常用的几个方法： clear()： 清除文本。 send_keys (value)： 模拟按键输入。 click()： 单击元素。 from selenium import webdriver driver = webdriver.Chrome() driver.get(&quot;https://www.baidu.com&quot;) driver.find_element_by_id(&quot;kw&quot;).clear() driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;selenium&quot;) driver.find_element_by_id(&quot;su&quot;).click() driver.quit() 提交 submit()方法用于提交表单。 例如， 在搜索框输入关键字之后的“回车” 操作， 就可以通过该方法模拟。 from selenium import webdriver driver = webdriver.Chrome() driver.get(&quot;https://www.baidu.com&quot;) search_text = driver.find_element_by_id('kw') search_text.send_keys('selenium') search_text.submit() driver.quit() 有时候 submit()可以与 click()方法互换来使用， submit()同样可以提交一个按钮， 但 submit()的应用范围远不及 click()广泛。 其他常用方法 size： 返回元素的尺寸。 text： 获取元素的文本。 get_attribute(name)： 获得属性值。 is_displayed()： 设置该元素是否用户可见。 from selenium import webdriver driver = webdriver.Chrome() driver.get(&quot;http://www.baidu.com&quot;) # 获得输入框的尺寸 size = driver.find_element_by_id('kw').size print(size) # 返回百度页面底部备案信息 text = driver.find_element_by_id(&quot;cp&quot;).text print(text) # 返回元素的属性值， 可以是 id、 name、 type 或其他任意属性 attribute = driver.find_element_by_id(&quot;kw&quot;).get_attribute('type') print(attribute) # 返回元素的结果是否可见， 返回结果为 True 或 False result = driver.find_element_by_id(&quot;kw&quot;).is_displayed() print(result) driver.quit() 输出结果： {'width': 500, 'height': 22} ©2015 Baidu 使用百度前必读 意见反馈 京 ICP 证 030173 号 text True 执行上面的程序并查看结果： size 方法用于获取百度输入框的宽、 高， text 方法用于获得百度底部的备案信息 get_attribute()用于获得百度输入的 type 属性的值， is_displayed()用于返回一个元素是否可见， 如果可见则返回 True， 否则返回 False。 六、鼠标事件 在 WebDriver 中， 将这些关于鼠标操作的方法封装在ActionChains 类提供。 ActionChains类提供了鼠标操作的常用方法： perform()： 执行所有 ActionChains 中存储的行为； context_click()： 右击； double_click()： 双击； drag_and_drop()： 拖动； move_to_element()： 鼠标悬停。 鼠标悬停操作 from selenium import webdriver # 引入 ActionChains 类 from selenium.webdriver.common.action_chains import ActionChains driver = webdriver.Chrome() driver.get(&quot;https://www.baidu.cn&quot;) # 定位到要悬停的元素 above = driver.find_element_by_link_text(&quot;设置&quot;) # 对定位到的元素执行鼠标悬停操作 ActionChains(driver).move_to_element(above).perform() from selenium.webdriver import ActionChains 导入提供鼠标操作的 ActionChains 类。 ActionChains(driver) 调用 ActionChains()类， 将浏览器驱动 driver 作为参数传入。 move_to_element(above) context_click()方法用于模拟鼠标右键操作， 在调用时需要指定元素定位。 perform() 执行所有 ActionChains 中存储的行为， 可以理解成是对整个操作的提交动作。 七、键盘事件 Keys()类提供了键盘上几乎所有按键的方法。 前面了解到， send_keys()方法可以用来模拟键盘输入， 除此 之外， 我们还可以用它来输入键盘上的按键， 甚至是组合键， 如 Ctrl+A、 Ctrl+C 等。 from selenium import webdriver # 引入 Keys 模块 from selenium.webdriver.common.keys import Keys driver = webdriver.Chrome() driver.get(&quot;http://www.baidu.com&quot;) # 输入框输入内容 driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;seleniumm&quot;) # 删除多输入的一个 m driver.find_element_by_id(&quot;kw&quot;).send_keys(Keys.BACK_SPACE) # 输入空格键+“教程” driver.find_element_by_id(&quot;kw&quot;).send_keys(Keys.SPACE) driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;教程&quot;) # ctrl+a 全选输入框内容 driver.find_element_by_id(&quot;kw&quot;).send_keys(Keys.CONTROL, 'a') # ctrl+x 剪切输入框内容 driver.find_element_by_id(&quot;kw&quot;).send_keys(Keys.CONTROL, 'x') # ctrl+v 粘贴内容到输入框 driver.find_element_by_id(&quot;kw&quot;).send_keys(Keys.CONTROL, 'v') # 通过回车键来代替单击操作 driver.find_element_by_id(&quot;su&quot;).send_keys(Keys.ENTER) driver.quit() 需要说明的是， 上面的脚本没有什么实际意义， 仅向我们展示模拟键盘各种按键与组合键的用法。 from selenium.webdriver.common.keys import Keys 在使用键盘按键方法前需要先导入 keys 类。 以下为常用的键盘操作： send_keys(Keys.BACK_SPACE) 删除键（BackSpace） send_keys(Keys.SPACE) 空格键(Space) send_keys(Keys.TAB) 制表键(Tab) send_keys(Keys.ESCAPE) 回退键（Esc） send_keys(Keys.ENTER) 回车键（Enter） send_keys(Keys.CONTROL,'a') 全选（Ctrl+A） send_keys(Keys.CONTROL,'c') 复制（Ctrl+C） send_keys(Keys.CONTROL,'x') 剪切（Ctrl+X） send_keys(Keys.CONTROL,'v') 粘贴（Ctrl+V） send_keys(Keys.F1) 键盘 F1 send_keys(Keys.F12) 键盘 F12 八、获取断言信息 不管是在做功能测试还是自动化测试，最后一步需要拿实际结果与预期进行比较。这个比较的称之为断言。 我们通常可以通过获取title 、URL和text等信息进行断言。text方法在前面已经讲过，它用于获取标签对之间的文本信息。 下面同样以百度为例，介绍如何获取这些信息。 from selenium import webdriver from time import sleep driver = webdriver.Firefox() driver.get(&quot;https://www.baidu.com&quot;) print('Before search================') # 打印当前页面title title = driver.title print(title) # 打印当前页面URL now_url = driver.current_url print(now_url) driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;selenium&quot;) driver.find_element_by_id(&quot;su&quot;).click() sleep(1) print('After search================') # 再次打印当前页面title title = driver.title print(title) # 打印当前页面URL now_url = driver.current_url print(now_url) # 获取结果数目 user = driver.find_element_by_class_name('nums').text print(user) driver.quit() 脚本运行结果如下： Before search================ 百度一下，你就知道 https://www.baidu.com/ After search================ selenium_百度搜索 https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=0&amp;rsv_idx... 搜索工具 百度为您找到相关结果约5,380,000个 title：用于获得当前页面的标题。 current_url：用户获得当前页面的URL。 text：获取搜索条目的文本信息。 九、设置元素等待 WebDriver提供了两种类型的等待：显式等待和隐式等待。 显式等待 显式等待使WebdDriver等待某个条件成立时继续执行，否则在达到最大时长时抛出超时异常（TimeoutException）。 from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC driver = webdriver.Firefox() driver.get(&quot;http://www.baidu.com&quot;) element = WebDriverWait(driver, 5, 0.5).until( EC.presence_of_element_located((By.ID, &quot;kw&quot;)) ) element.send_keys('selenium') driver.quit() WebDriverWait类是由WebDirver 提供的等待方法。在设置时间内，默认每隔一段时间检测一次当前页面元素是否存在，如果超过设置时间检测不到则抛出异常。具体格式如下： WebDriverWait(driver, timeout, poll_frequency=0.5, ignored_exceptions=None) driver ：浏览器驱动。 timeout ：最长超时时间，默认以秒为单位。 poll_frequency ：检测的间隔（步长）时间，默认为0.5S。 ignored_exceptions ：超时后的异常信息，默认情况下抛NoSuchElementException异常。 WebDriverWait()一般由until()或until_not()方法配合使用，下面是until()和until_not()方法的说明。 until(method, message='') 调用该方法提供的驱动程序作为一个参数，直到返回值为True。 until_not(method, message='') 调用该方法提供的驱动程序作为一个参数，直到返回值为False。 在本例中，通过as关键字将expected_conditions 重命名为EC，并调用presence_of_element_located()方法判断元素是否存在。 隐式等待 WebDriver提供了implicitly_wait()方法来实现隐式等待，默认设置为0。它的用法相对来说要简单得多。 from selenium import webdriver from selenium.common.exceptions import NoSuchElementException from time import ctime driver = webdriver.Firefox() # 设置隐式等待为10秒 driver.implicitly_wait(10) driver.get(&quot;http://www.baidu.com&quot;) try: print(ctime()) driver.find_element_by_id(&quot;kw22&quot;).send_keys('selenium') except NoSuchElementException as e: print(e) finally: print(ctime()) driver.quit() implicitly_wait() 默认参数的单位为秒，本例中设置等待时长为10秒。首先这10秒并非一个固定的等待时间，它并不影响脚本的执行速度。其次，它并不针对页面上的某一元素进行等待。当脚本执行到某个元素定位时，如果元素可以定位，则继续执行；如果元素定位不到，则它将以轮询的方式不断地判断元素是否被定位到。假设在第6秒定位到了元素则继续执行，若直到超出设置时长（10秒）还没有定位到元素，则抛出异常。 十、定位一组元素 WebDriver还提供了8种用于定位一组元素的方法。 find_elements_by_id() find_elements_by_name() find_elements_by_class_name() find_elements_by_tag_name() find_elements_by_link_text() find_elements_by_partial_link_text() find_elements_by_xpath() find_elements_by_css_selector() 定位一组元素的方法与定位单个元素的方法类似，唯一的区别是在单词element后面多了一个s表示复数。 接下来通过例子演示定位一组元素的使用： from selenium import webdriver from time import sleep driver = webdriver.Chrome() driver.get(&quot;https://www.baidu.com&quot;) driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;selenium&quot;) driver.find_element_by_id(&quot;su&quot;).click() sleep(1) # 定位一组元素 texts = driver.find_elements_by_xpath('//div/h3/a') # 循环遍历出每一条搜索结果的标题 for t in texts: print(t.text) driver.quit() 十一、多表单切换 在Web应用中经常会遇到frame/iframe表单嵌套页面的应用，WebDriver只能在一个页面上对元素识别与定位，对于frame/iframe表单内嵌页面上的元素无法直接定位。这时就需要通过switch_to.frame()方法将当前定位的主体切换为frame/iframe表单的内嵌页面中。 &lt;html&gt; &lt;body&gt; ... &lt;iframe id=&quot;x-URS-iframe&quot; ...&gt; &lt;html&gt; &lt;body&gt; ... &lt;input name=&quot;email&quot; &gt; 126邮箱登录框的结构大概是这样子的，想要操作登录框必须要先切换到iframe表单。 from selenium import webdriver driver = webdriver.Chrome() driver.get(&quot;http://www.126.com&quot;) driver.switch_to.frame('x-URS-iframe') driver.find_element_by_name(&quot;email&quot;).clear() driver.find_element_by_name(&quot;email&quot;).send_keys(&quot;username&quot;) driver.find_element_by_name(&quot;password&quot;).clear() driver.find_element_by_name(&quot;password&quot;).send_keys(&quot;password&quot;) driver.find_element_by_id(&quot;dologin&quot;).click() driver.switch_to.default_content() driver.quit() switch_to.frame() 默认可以直接取表单的id 或name属性。如果iframe没有可用的id和name属性，则可以通过下面的方式进行定位。 …… #先通过xpth定位到iframe xf = driver.find_element_by_xpath('//*[@id=&quot;x-URS-iframe&quot;]') #再将定位对象传给switch_to.frame()方法 driver.switch_to.frame(xf) …… driver.switch_to.parent_frame() 除此之外，在进入多级表单的情况下，还可以通过switch_to.default_content()跳回最外层的页面。 十二、多窗口切换 在页面操作过程中有时候点击某个链接会弹出新的窗口，这时就需要主机切换到新打开的窗口上进行操作。WebDriver提供了switch_to.window()方法，可以实现在不同的窗口之间切换。 以百度首页和百度注册页为例，在两个窗口之间的切换如下图。 from selenium import webdriver import time driver = webdriver.Firefox() driver.implicitly_wait(10) driver.get(&quot;http://www.baidu.com&quot;) # 获得百度搜索窗口句柄 sreach_windows = driver.current_window_handle driver.find_element_by_link_text('登录').click() driver.find_element_by_link_text(&quot;立即注册&quot;).click() # 获得当前所有打开的窗口的句柄 all_handles = driver.window_handles # 进入注册窗口 for handle in all_handles: if handle != sreach_windows: driver.switch_to.window(handle) print('now register window!') driver.find_element_by_name(&quot;account&quot;).send_keys('username') driver.find_element_by_name('password').send_keys('password') time.sleep(2) driver.quit() 在本例中所涉及的新方法如下： current_window_handle：获得当前窗口句柄。 window_handles：返回所有窗口的句柄到当前会话。 switch_to.window()：用于切换到相应的窗口，与上一节的switch_to.frame()类似，前者用于不同窗口的切换，后者用于不同表单之间的切换。 十三、警告框处理 在WebDriver中处理JavaScript所生成的alert、confirm以及prompt十分简单，具体做法是使用 switch_to.alert 方法定位到 alert/confirm/prompt，然后使用text/accept/dismiss/ send_keys等方法进行操作。 text：返回 alert/confirm/prompt 中的文字信息。 accept()：接受现有警告框。 dismiss()：解散现有警告框。 send_keys(keysToSend)：发送文本至警告框。keysToSend：将文本发送至警告框。 如下图，百度搜索设置弹出的窗口是不能通过前端工具对其进行定位的，这个时候就可以通过switch_to_alert()方法接受这个弹窗。 from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains import time driver = webdriver.Firefox() driver.implicitly_wait(10) driver.get('http://www.baidu.com') # 鼠标悬停至“设置”链接 link = driver.find_element_by_link_text('设置') ActionChains(driver).move_to_element(link).perform() # 打开搜索设置 driver.find_element_by_link_text(&quot;搜索设置&quot;).click() # 保存设置 driver.find_element_by_class_name(&quot;prefpanelgo&quot;).click() time.sleep(2) # 接受警告框 driver.switch_to.alert.accept() driver.quit() 通过switch_to_alert()方法获取当前页面上的警告框，并使用accept()方法接受警告框。 十四、下拉框选择 有时我们会碰到下拉框，WebDriver提供了Select类来处理下拉框。 如百度搜索设置的下拉框 from selenium import webdriver from selenium.webdriver.support.select import Select from time import sleep driver = webdriver.Chrome() driver.implicitly_wait(10) driver.get('http://www.baidu.com') # 鼠标悬停至“设置”链接 driver.find_element_by_link_text('设置').click() sleep(1) # 打开搜索设置 driver.find_element_by_link_text(&quot;搜索设置&quot;).click() sleep(2) # 搜索结果显示条数 sel = driver.find_element_by_xpath(&quot;//select[@id='nr']&quot;) Select(sel).select_by_value('50') # 显示50条 driver.quit() Select类用于定位select标签。 select_by_value() 方法用于定位下接选项中的value值。 十五、文件上传 对于通过input标签实现的上传功能，可以将其看作是一个输入框，即通过send_keys()指定本地文件路径的方式实现文件上传。 创建upfile.html文件，代码如下： &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot; /&gt; &lt;title&gt;upload_file&lt;/title&gt; &lt;link href=&quot;http://cdn.bootcss.com/bootstrap/3.3.0/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;row-fluid&quot;&gt; &lt;div class=&quot;span6 well&quot;&gt; &lt;h3&gt;upload_file&lt;/h3&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=&quot;http://cdn.bootcss.com/bootstrap/3.3.0/css/bootstrap.min.js&quot;&gt;&lt;/scrip&gt; &lt;/html&gt; 通过浏览器打开upfile.html文件，接下来通过send_keys()方法来实现文件上传。 from selenium import webdriver import os driver = webdriver.Firefox() file_path = 'file:///' + os.path.abspath('upfile.html') driver.get(file_path) # 定位上传按钮，添加本地文件 driver.find_element_by_name(&quot;file&quot;).send_keys('D:\\\\upload_file.txt') driver.quit() 十六、cookie操作 有时候我们需要验证浏览器中cookie是否正确，因为基于真实cookie的测试是无法通过白盒和集成测试进行的。 WebDriver提供了操作Cookie的相关方法，可以读取、添加和删除cookie信息。 WebDriver操作cookie的方法： get_cookies()： 获得所有cookie信息。 get_cookie(name)： 返回字典的key为“name”的cookie信息。 add_cookie(cookie_dict) ： 添加cookie。“cookie_dict”指字典对象，必须有name 和value 值。 delete_cookie(name,optionsString)：删除cookie信息。“name”是要删除的cookie的名称，“optionsString”是该cookie的选项，目前支持的选项包括“路径”，“域”。 delete_all_cookies()： 删除所有cookie信息。 下面通过get_cookies()来获取当前浏览器的cookie信息。 from selenium import webdriver driver = webdriver.Firefox() driver.get(&quot;http://www.youdao.com&quot;) # 获得cookie信息 cookie= driver.get_cookies() # 将获得cookie的信息打印 print(cookie) driver.quit() 从执行结果可以看出，cookie数据是以字典的形式进行存放的。知道了cookie的存放形式，接下来我们就可以按照这种形式向浏览器中写入cookie信息。 from selenium import webdriver driver = webdriver.Firefox() driver.get(&quot;http://www.youdao.com&quot;) # 向cookie的name 和value中添加会话信息 driver.add_cookie({'name': 'key-aaaaaaa', 'value': 'value-bbbbbb'}) # 遍历cookies中的name 和value信息并打印，当然还有上面添加的信息 for cookie in driver.get_cookies(): print(&quot;%s -&gt; %s&quot; % (cookie['name'], cookie['value'])) driver.quit() 输出结果： ======================== RESTART: ========================= YOUDAO_MOBILE_ACCESS_TYPE -&gt; 1 _PREF_ANONYUSER__MYTH -&gt; aGFzbG9nZ2VkPXRydWU= OUTFOX_SEARCH_USER_ID -&gt; -1046383847@218.17.158.115 JSESSIONID -&gt; abc7qSE_SBGsVgnVLBvcu key-aaaaaaa -&gt; value-bbbbbb 从执行结果可以看到，最后一条cookie信息是在脚本执行过程中通过add_cookie()方法添加的。通过遍历得到所有的cookie信息，从而找到key为“name”和“value”的特定cookie的value。 十七、调用JS代码 虽然WebDriver提供了操作浏览器的前进和后退方法，但对于浏览器滚动条并没有提供相应的操作方法。在这种情况下，就可以借助JavaScript来控制浏览器的滚动条。WebDriver提供了execute_script()方法来执行JavaScript代码。 用于调整浏览器滚动条位置的JavaScript代码如下： &lt;!-- window.scrollTo(左边距,上边距); --&gt; window.scrollTo(0,450); window.scrollTo()方法用于设置浏览器窗口滚动条的水平和垂直位置。方法的第一个参数表示水平的左间距，第二个参数表示垂直的上边距。其代码如下： from selenium import webdriver from time import sleep # 访问百度 driver=webdriver.Firefox() driver.get(&quot;http://www.baidu.com&quot;) # 设置浏览器窗口大小 driver.set_window_size(500, 500) # 搜索 driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;selenium&quot;) driver.find_element_by_id(&quot;su&quot;).click() sleep(2) # 通过javascript设置浏览器窗口的滚动条位置 js=&quot;window.scrollTo(100,450);&quot; driver.execute_script(js) sleep(3) driver.quit() 通过浏览器打开百度进行搜索，并且提前通过set_window_size()方法将浏览器窗口设置为固定宽高显示，目的是让窗口出现水平和垂直滚动条。然后通过execute_script()方法执行JavaScripts代码来移动滚动条的位置。 十八、窗口截图 自动化用例是由程序去执行的，因此有时候打印的错误信息并不十分明确。如果在脚本执行出错的时候能对当前窗口截图保存，那么通过图片就可以非常直观地看出出错的原因。WebDriver提供了截图函数get_screenshot_as_file()来截取当前窗口。 from selenium import webdriver from time import sleep driver = webdriver.Firefox() driver.get('http://www.baidu.com') driver.find_element_by_id('kw').send_keys('selenium') driver.find_element_by_id('su').click() sleep(2) # 截取当前窗口，并指定截图图片的保存位置 driver.get_screenshot_as_file(&quot;D:\\\\baidu_img.jpg&quot;) driver.quit() 脚本运行完成后打开D盘，就可以找到baidu_img.jpg图片文件了。 十九、关闭浏览器 在前面的例子中我们一直使用quit()方法，其含义为退出相关的驱动程序和关闭所有窗口。除此之外，WebDriver还提供了close()方法，用来关闭当前窗口。例多窗口的处理，在用例执行的过程中打开了多个窗口，我们想要关闭其中的某个窗口，这时就要用到close()方法进行关闭了。 close() 关闭单个窗口 quit() 关闭所有窗口 二十、Selenium踩坑指北 众所周知，我们应该把合适的工具用在合适的场景，这跟杀鸡的时候不需要用到宰牛刀是一样的道理。 selenium比较好的使用场景是验收测试/回归测试/TDD/BDD，一些同学喜欢把selenium用到某些selenium难以承受的场景，这种方式官方是不推荐的。下面这些是官方给出的各种神坑。 验证码 一般来说我们不需要用selenium去处理各种验证码，有兴趣的同学可以逆向思维，亲自试试。 那么遇到验证码怎么办？ 测试环境就关掉验证码 留个后门，比如万能验证码 下载文件 尽管我们可以使用selenium去点击下载按钮，从而达到下载文件的目的，但是这样做其实并不好。首先处理起来可能比较麻烦，另外关于下载时间下载速度以及下载完整性的验证我们是不太好做的。 HTTP 请求的响应码 这一part官方苦口婆心的解释了很多，大意是selenium是站在用户角度去自动化测试，对于终端用户来说，他们并不直接关注请求的返回码，他们关注的是能不能看到404的错误页面之类的可以直接感受到信息。 下面是非官方的建议 如果你真的关注响应的状态码，那么别在UI自动化层去做，试着去在非UI层，比如接口层做 放弃在UI自动化用例中断言状态码的努力，有舍才有得嘛 第三方登陆 使用selenium去自动化第三方登陆原则上是不推荐的。因为 增加了用例的复杂度和运行时间，用例容易跑失败 第三方登录是不稳定的，这会让你的登录变得不稳定 在国外一般第三方登录的提供方会提供对应的API，我们可以把登录API集成到用例里，这些API相当稳定，比用selenium去自动化登录过程要好。 国内可以通过类似的思路去做，比如微信登录就有自己的API，这种实现比较硬核，并且跟ui自动化结合起来也有一定难度，有需求的同学可以尝试一下。 用例依赖 selenium team说了，用例直接不要有依赖，要可以用任意顺序运行 性能测试 简而言之，selenium不适合做性能测试，原因我就不详细说了，总之不合适的话咱就不要强求，有情人总会终成眷属。 如果需要做性能测试，可以看看jmeter，官方推荐，值得信赖。 链接爬虫 用selenium去遍历一些链接从而达到爬虫的效果官方是不推荐的，理由是慢，有很多更好的替代方案。 ","link":"https://preszang.github.io/post/XfbZQSvJ5/"},{"title":"pytest接口测试基本教程","content":"1.快速开始 pytest测试框架可以让我们很方便的编写测试用例，这些用例写起来虽然简单，但仍然可以规模化以及编写更加复杂的测试用例。官方文档 安装 pip install -U pytest 用下面的命令去检查一下pytest是否成功安装 $ pytest --version This is pytest version 3.x.y, imported from $PYTHON_PREFIX/lib/python3.5/site-packages/pytest.py 快速开始 创建名为test_quick_start.py的文件，敲如下内容 def reverse(string): return string[::-1] def test_reverse(): string = &quot;good&quot; assert reverse(string) == &quot;doog&quot; another_string = &quot;itest&quot; assert reverse(another_string) == &quot;tseti&quot; 上面的代码做了2件事情 定义了名为reverse(string)的全局函数，作用是把string反转并返回。比如输入&quot;abc&quot;会反转成&quot;cba&quot; 定义了名为test_reverse()的函数，包含了2个断言，用来测试reverse()方法的正确性 在命令行中使用下面的命令去运行用例 pytest 结果应该大致如下 ========================================================================= test session starts ========================================================================= platform darwin -- Python 2.7.12, pytest-3.2.3, py-1.4.34, pluggy-0.4.0 rootdir: /Users/easonhan/code/testclass.net/src/pytest, inifile: collected 1 item test_quick_start.py . ====================================================================== 1 passed in 0.01 seconds ======================================================================= 总结 这是最简单的单元测试实例，实现了用代码去测试代码的目的。 2.运行多个文件 在现实的测试活动中，我们经常会定义多个用例文件，用来实现业务逻辑或其他逻辑上用例的物理分隔，比如 login_test.py # 登录相关功能的测试用例 cart_test.py # 购物车相关功能的测试用例 checkout_test.py # 结算相关功能的用例 order_test.py # 订单相关功能的用例 使用pytest可以很方便的执行批量执行一组文件中定义的用例。 潜规则 在批量执行用例之前，我们需要了解一下pytest的潜规则，注意，由于pytest可以支持丰富的定制选项，下面的潜规则是在没有定制的默认情况下的缺省规则 pytest会找当前以及递查找子文件夹下面所有的test_*.py或*_test.py的文件，把其当作测试文件 在这些文件里，pytest会收集下面的一些函数或方法，当作测试用例 不在类定义中的以test_开头的函数或方法 在以Test开头的类中(不能包含__init__方法)，以test_开头的方法 pytest也支持unittest模式的用例定义 实例 新建test_calc.py文件，与上一节的test_quick_start.py放在同一文件夹下，敲入下面的内容 def add(x, y): return x + y def test_add(): assert add(1, 0) == 1 assert add(1, 1) == 2 assert add(1, 99) == 100 现在当前文件夹下应该有2个文件 test_calc.py test_quick_start.py 运行 在当前文件夹敲下面的命令 pytest 结果大致应该如下所示 $ pytest ========================================================================= test session starts ========================================================================= platform darwin -- Python 2.7.12, pytest-3.2.3, py-1.4.34, pluggy-0.4.0 rootdir: /Users/easonhan/code/testclass.net/src/pytest, inifile: collected 2 items test_calc.py . test_quick_start.py . ====================================================================== 2 passed in 0.01 seconds ======================================================================= 总结 上面的例子里 所有以test_开头的py文件都被当成了测试文件 所有测试文件中以test开头的方法被当成了测试用例执行 3.Assert Assert就是断言，每个测试用例都需要断言。 与unittest不同，pytest使用的是python自带的assert关键字来进行断言，大大降低了学习成本。 assert关键字后面可以接一个表达式，只要表达式的最终结果为True，那么断言通过，用例执行成功，否则用例执行失败。 详尽的用例失败描述 pytest的用例失败描述非常详尽，一目了人。考虑下面的例子 # content of test_assert1.py def f(): return 3 def test_function(): assert f() == 4 执行上面的用例 $ pytest test_assert1.py ======= test session starts ======== platform linux -- Python 3.x.y, pytest-3.x.y, py-1.x.y, pluggy-0.x.y rootdir: $REGENDOC_TMPDIR, inifile: collected 1 item test_assert1.py F ======= FAILURES ======== _______ test_function ________ def test_function(): &gt; assert f() == 4 E assert 3 == 4 E + where 3 = f() test_assert1.py:5: AssertionError ======= 1 failed in 0.12 seconds ======== 可以很明显的看出，pytest给出的错误提示是：f()的值是3，也就是实际结果是3，而预期结果是4，3不等于4，因此断言未通过，用例失败。 断言异常抛出 pytest有自己的异常抛出断言套路，下面是最简单的形式 import pytest def test_zero_division(): with pytest.raises(ZeroDivisionError): 1 / 0 上面代码的意思是: 1/0的时候应该抛出ZeroDivisionError，否则用例失败，断言不通过。 另外pytest还允许我们访问异常的具体信息，如下面的例子 def test_recursion_depth(): with pytest.raises(RuntimeError) as excinfo: def f(): f() f() assert 'maximum recursion' in str(excinfo.value) 我们还可以定制断言异常的错误信息，比如 &gt;&gt;&gt; with raises(ZeroDivisionError, message=&quot;Expecting ZeroDivisionError&quot;): ... pass ... Failed: Expecting ZeroDivisionError 总结 更多断言异常以及定制assert中比较方式的例子，请参阅官方文档 4.Fixture 我们可以简单的把Fixture理解为准备测试数据和初始化测试对象的阶段。 一般我们对测试数据和测试对象的管理有这样的一些场景 所有用例开始之前初始化测试数据或对象 所有用例结束之后销毁测试数据或对象 每个用例开始之前初始化测试数据或对象 每个用例结束之后销毁测试数据或对象 在每个／所有module的用例开始之前初始化数据或对象 在每个／所有module的用例开始之后销毁数据或对象 ...... ...... pytest的fixture特性可以满足上面的需求。 简单的例子 考虑这种场景，我们需要判断用户的密码中包含简单密码，规则是这样的，密码必须至少6位，满足6位的话判断用户的密码不是password123或者password之类的弱密码。 我们将用户的信息导出成名为users.dev.json的文件，该文件如下所示 [ {&quot;name&quot;:&quot;jack&quot;,&quot;password&quot;:&quot;Iloverose&quot;}, {&quot;name&quot;:&quot;rose&quot;,&quot;password&quot;:&quot;Ilovejack&quot;}, {&quot;name&quot;:&quot;tom&quot;,&quot;password&quot;:&quot;password123&quot;} ] 新建名为test_user_password.py的文件，键入以下内容，一定要保证users.dev.json文件与该文件在同一路径下 import pytest import json class TestUserPassword(object): @pytest.fixture def users(self): return json.loads(open('./users.dev.json', 'r').read()) # 读取当前路径下的users.dev.json文件，返回的结果是dict def test_user_password(self, users): # 遍历每条user数据 for user in users: passwd = user['password'] assert len(passwd) &gt;= 6 msg = &quot;user %s has a weak password&quot; %(user['name']) assert passwd != 'password', msg assert passwd != 'password123', msg 运行 pytest可以通过指定文件名的方式运行单个用例文件，这里我们只运行test_user_password.py文件 pytest test_user_password.py 运行结果 $ pytest test_user_password.py ========================================================================= test session starts ========================================================================= platform darwin -- Python 2.7.12, pytest-3.2.3, py-1.4.34, pluggy-0.4.0 rootdir: /Users/easonhan/code/testclass.net/src/pytest, inifile: collected 1 item test_user_password.py F ============================================================================== FAILURES =============================================================================== _________________________________________________________________ TestUserPassword.test_user_password _________________________________________________________________ self = &lt;test_user_password.TestUserPassword object at 0x1046e3290&gt; users = [{'name': 'jack', 'password': 'Iloverose'}, {'name': 'rose', 'password': 'Ilovejack'}, {'name': 'tom', 'password': 'password123'}] def test_user_password(self, users): for user in users: passwd = user['password'] assert len(passwd) &gt;= 6 msg = &quot;user %s has a weak password&quot; %(user['name']) assert passwd != 'password', msg &gt; assert passwd != 'password123', msg E AssertionError: user tom has a weak password E assert 'password123' != 'password123' test_user_password.py:14: AssertionError ====================================================================== 1 failed in 0.03 seconds ======================================================================= 分析 使用@pytest.fixture装饰器可以定义feature 在用例的参数中传递fixture的名称以便直接调用fixture，拿到fixture的返回值 3个assert是递进关系，前1个assert断言失败后，后面的assert是不会运行的，因此重要的assert放到前面 E AssertionError: user tom has a weak password可以很容易的判断出是哪条数据出了问题，所以定制可读性好的错误信息是很必要的 任何1个断言失败以后，for循环就会退出，所以上面的用例1次只能发现1条错误数据，换句话说任何1个assert失败后，用例就终止运行了 执行顺序 pytest是这样运行上面的用例的 pytest找到以test_开头的方法，也就是test_user_password方法，执行该方法时发现传入的参数里有跟fixture users名称相同的参数 pytest认定users是fixture，执行该fixture，读取json文件解析成dict实例 test_user_password方法真正被执行，users fixture被传入到该方法 注意 我们可以使用下面的命令来查看用例中可用的fixtures pytest --fixtures test_user_password.py 数据清理 有时候我们需要在用例结束的时候去清理一些测试数据，或清除测试过程中创建的对象，我们可以使用下面的方式 import smtplib import pytest @pytest.fixture(scope=&quot;module&quot;) def smtp(): smtp = smtplib.SMTP(&quot;smtp.gmail.com&quot;, 587, timeout=5) yield smtp # provide the fixture value print(&quot;teardown smtp&quot;) smtp.close() yield 关键字返回了fixture中实例化的对象smtp module中的用例执行完成后smtp.close()方法会执行，无论用例的运行状态是怎么样的,都会执行 更多的数据清理方式 addfinalizer 也可以完成数据清理的工作，具体见这里 5.参数化的Fixture 继续上一节的测试需求，在上一节里，任何1条测试数据导致断言不通过后测试用例就会停止运行，这样每次只能检查出1条不符合规范的数据，有没有什么办法可以一次性把所有的不符合结果都测出来呢？ 这时候我们就需要用到参数化的fixture特性了 更新数据文件 新建users.test.json文件，内容如下 [ {&quot;name&quot;:&quot;jack&quot;,&quot;password&quot;:&quot;Iloverose&quot;}, {&quot;name&quot;:&quot;rose&quot;,&quot;password&quot;:&quot;Ilovejack&quot;} {&quot;name&quot;:&quot;tom&quot;,&quot;password&quot;:&quot;password123&quot;}, {&quot;name&quot;:&quot;mike&quot;,&quot;password&quot;:&quot;password&quot;}, {&quot;name&quot;:&quot;james&quot;,&quot;password&quot;:&quot;AGoodPasswordWordShouldBeLongEnough&quot;} ] 我们增加了2条用户信息，其中mike的密码是弱密码。 参数化fixture 参数化fixture允许我们向fixture提供参数，参数可以是list，该list中有几条数据，fixture就会运行几次，相应的测试用例也会运行几次。 参数化fixture的语法是 @pytest.fixture(params=[&quot;smtp.gmail.com&quot;, &quot;mail.python.org&quot;]) 其中len(params)的值就是用例执行的次数 在fixture的定义中，可以使用request.param来获取每次传入的参数，如下: @pytest.fixture(scope=&quot;module&quot;, params=[&quot;smtp.gmail.com&quot;, &quot;mail.python.org&quot;]) def smtp(request): smtp = smtplib.SMTP(request.param, 587, timeout=5) yield smtp print (&quot;finalizing %s&quot; % smtp) smtp.close() 上面的代码smtp fixture会执行2次 第1次request.param == 'smtp.gmail.com' 第2次request.param == 'mail.python.org' 实现用例 我们现在使用参数化fixtures来实现一次性检查出弱密码的用例。 新建文件test_user_password_with_params.py，内容如下: import pytest import json users = json.loads(open('./users.test.json', 'r').read()) class TestUserPasswordWithParam(object): @pytest.fixture(params=users) def user(self, request): return request.param def test_user_password(self, user): passwd = user['password'] assert len(passwd) &gt;= 6 msg = &quot;user %s has a weak password&quot; %(user['name']) assert passwd != 'password', msg assert passwd != 'password123', msg 上面的例子里，我们先把所有用户信息读到users变量里，注意users这时候是list类型，可以直接传入到fixture的params 运行及结果 运行 pytest test_user_password_with_params.py 结果 $ pytest test_user_password_with_params.py ========================================================================= test session starts ========================================================================= platform darwin -- Python 2.7.12, pytest-3.2.3, py-1.4.34, pluggy-0.4.0 rootdir: /Users/easonhan/code/testclass.net/src/pytest, inifile: collected 5 items test_user_password_with_params.py ..FF. ============================================================================== FAILURES =============================================================================== _________________________________________________________ TestUserPasswordWithParam.test_user_password[user2] _________________________________________________________ self = &lt;test_user_password_with_params.TestUserPasswordWithParam object at 0x10de1d790&gt;, user = {'name': 'tom', 'password': 'password123'} def test_user_password(self, user): passwd = user['password'] assert len(passwd) &gt;= 6 msg = &quot;user %s has a weak password&quot; %(user['name']) assert passwd != 'password', msg &gt; assert passwd != 'password123', msg E AssertionError: user tom has a weak password E assert 'password123' != 'password123' test_user_password_with_params.py:15: AssertionError _________________________________________________________ TestUserPasswordWithParam.test_user_password[user3] _________________________________________________________ self = &lt;test_user_password_with_params.TestUserPasswordWithParam object at 0x10de1df50&gt;, user = {'name': 'mike', 'password': 'password'} def test_user_password(self, user): passwd = user['password'] assert len(passwd) &gt;= 6 msg = &quot;user %s has a weak password&quot; %(user['name']) &gt; assert passwd != 'password', msg E AssertionError: user mike has a weak password E assert 'password' != 'password' test_user_password_with_params.py:14: AssertionError ================================================================= 2 failed, 3 passed in 0.05 seconds ================================================================== 稍微留意一下, 可以看出tom和mike使用了弱密码。总共运行了5个用例,3个成功,2个失败。 fixture的更多特性 fixture还有很多更加灵活和深入的用法，具体见这里 6.Parametrize Fixture @pytest.mark.parametrize 装饰器可以让我们每次参数化fixture的时候传入多个项目。回忆上一节，我们参数化的时候只能传入传入1个字符串或者是其他的数据对象，parametrize每次多个参数，更加灵活。 例子 import pytest @pytest.mark.parametrize(&quot;test_input,expected&quot;, [ (&quot;3+5&quot;, 8), (&quot;2+4&quot;, 6), (&quot;6*9&quot;, 42), ]) def test_eval(test_input, expected): assert eval(test_input) == expected test_eval方法中传入了2个参数，就如同@pytest.mark.parametrize装饰器中定义的那样，因此简单理解，我们可以把parametrize装饰器想象成是数据表格，有表头(test_input,expected)以及具体的数据。 运行结果 $ pytest ======= test session starts ======== platform linux -- Python 3.x.y, pytest-3.x.y, py-1.x.y, pluggy-0.x.y rootdir: $REGENDOC_TMPDIR, inifile: collected 3 items test_expectation.py ..F ======= FAILURES ======== _______ test_eval[6*9-42] ________ test_input = '6*9', expected = 42 @pytest.mark.parametrize(&quot;test_input,expected&quot;, [ (&quot;3+5&quot;, 8), (&quot;2+4&quot;, 6), (&quot;6*9&quot;, 42), ]) def test_eval(test_input, expected): &gt; assert eval(test_input) == expected E AssertionError: assert 54 == 42 E + where 54 = eval('6*9') test_expectation.py:8: AssertionError ======= 1 failed, 2 passed in 0.12 seconds ======== 7.常见套路 在使用pytest的时候，下面这些问题我们可能会经常遇到，这里给出官方的解决方案，按照套路来执行就可以了。 基础用法 把命令行参数传入到用例 动态添加命令行参数 根据命令行参数来忽略用例执行 编写集成度更好的辅助断言 判断是否由pytest执行 在测试报告的头部添加内容 统计用例运行时间 定义测试步骤，也就是让用例按照一定的顺序执行 Package/Directory-level fixtures (setups) 在报告和用例失败之前添加钩子 在fixtures中访问测试结果 PYTEST_CURRENT_TEST环境变量 冻结pytest 参数化 根据命令行参数来组合测试参数 配置test ID 快速创建测试场景的功能 延迟参数资源加载 间接参数 为不同的方法设置不同的参数 在多个fixture中使用间接参数 Indirect parametrization of optional implementations/imports 单独的为每个参数化用例设置标记和ID 8.使用pytest做简单的接口测试 我们现在需要测试v2ex网站的查看论坛节点信息的api。具体如下: 节点信息：获得指定节点的名字，简介，URL 及头像图片的地址。 https://www.v2ex.com/api/nodes/show.json Method: GET Authentication: None 接受参数： name: 节点名（V2EX 的节点名全是半角英文或者数字） 例如：https://www.v2ex.com/api/nodes/show.json?name=python 接口返回 { &quot;id&quot; : 90, &quot;name&quot; : &quot;python&quot;, &quot;url&quot; : &quot;http://www.v2ex.com/go/python&quot;, &quot;title&quot; : &quot;Python&quot;, &quot;title_alternative&quot; : &quot;Python&quot;, &quot;topics&quot; : 7963, &quot;stars&quot; : 5138, &quot;header&quot; : &quot;这里讨论各种 Python 语言编程话题，也包括 Django，Tornado 等框架的讨论。这里是一个能够帮助你解决实际问题的地方。&quot;, &quot;footer&quot; : null, &quot;created&quot; : 1278683336, &quot;avatar_mini&quot; : &quot;//v2ex.assets.uxengine.net/navatar/8613/985e/90_mini.png?m=1509941286&quot;, &quot;avatar_normal&quot; : &quot;//v2ex.assets.uxengine.net/navatar/8613/985e/90_normal.png?m=1509941286&quot;, &quot;avatar_large&quot; : &quot;//v2ex.assets.uxengine.net/navatar/8613/985e/90_large.png?m=1509941286&quot; } 需求分析 该接口是获取数据的接口，一般来说，这种接口我们的测试重点是验证数据的准确性。 根据3A原则，我们可以设计如下的用例 测试数据: 节点的名称:python 接口地址: https://www.v2ex.com/api/nodes/show.json 断言: 返回的结果里，id必须是90,name必须等于python，大家想一想为什么？ 代码 新建名为v2ex_api_test.py的文件，键入如下内容 import requests class TestV2exApi(object): domain = 'https://www.v2ex.com/' def test_node(self): path = 'api/nodes/show.json?name=python' url = self.domain + pathpython res = requests.get(url).json() assert res['id'] == 90 assert res['name'] == 'python' 需要注意的点 使用requests库来简化发送get请求并将返回值的json字符串转换成python字典 使用domain变量来参数化测试的地址，因为不同环境的地址可能不一样，使用domain变量之后只需要改动这个变量就可以切换测试环境了 断言id为90是因为测试数据是静态的，id不会发生变化 运行 $ pytest v2ex_api_test.py ======================================================================== test session starts ======================================================================== platform darwin -- Python 2.7.12, pytest-3.2.3, py-1.4.34, pluggy-0.4.0 rootdir: /Users/easonhan/code/testclass.net/src/pytest, inifile: collected 1 item v2ex_api_test.py . ===================================================================== 1 passed in 1.39 seconds ====================================================================== 用例执行成功，我们实现了最简单的接口测试场景。 9.使用fixture参数化接口入参 接上一节v2ex网站的查看论坛节点信息的api。具体如下: 节点信息：获得指定节点的名字，简介，URL 及头像图片的地址。 https://www.v2ex.com/api/nodes/show.json Method: GET Authentication: None 接受参数： name: 节点名（V2EX 的节点名全是半角英文或者数字） 例如：https://www.v2ex.com/api/nodes/show.json?name=python 我们试一下，通过传入不同的name，我们可以获取不同的节点信息。上面例子里我们获取了python讨论区的信息。现在我们把name改成java，该接口会返回java讨论区节点的信息，如下所示https://www.v2ex.com/api/nodes/show.json?name=python { &quot;id&quot; : 63, &quot;name&quot; : &quot;java&quot;, &quot;url&quot; : &quot;http://www.v2ex.com/go/java&quot;, &quot;title&quot; : &quot;Java&quot;, &quot;title_alternative&quot; : &quot;Java&quot;, &quot;topics&quot; : 1219, &quot;stars&quot; : 1547, &quot;header&quot; : &quot;The most popular programming language.&quot;, &quot;footer&quot; : null, &quot;created&quot; : 1272669207, &quot;avatar_mini&quot; : &quot;//v2ex.assets.uxengine.net/navatar/03af/dbd6/63_mini.png?m=1509589840&quot;, &quot;avatar_normal&quot; : &quot;//v2ex.assets.uxengine.net/navatar/03af/dbd6/63_normal.png?m=1509589840&quot;, &quot;avatar_large&quot; : &quot;//v2ex.assets.uxengine.net/navatar/03af/dbd6/63_large.png?m=1509589840&quot; } 那么新的需求来了，现在我们要测试给定的几个节点名称(python/java/go/nodejs)，v2ex的节点api可以正确返回节点的名字 需求分析 根据3A原则，我们可以设计如下的用例 测试数据: 节点的名称:python/java/go/nodejs 接口地址: https://www.v2ex.com/api/nodes/show.json 断言: 返回的结果里，name字段的值必须等于传入的节点名称 代码 在v2ex_api_test.py的文件中添加如下内容 import requests import pytest class TestV2exApiWithParams(object): domain = 'https://www.v2ex.com/' @pytest.fixture(params=['python', 'java', 'go', 'nodejs']) def lang(self, request): return request.param def test_node(self, lang): path = 'api/nodes/show.json?name=%s' %(lang) url = self.domain + path res = requests.get(url).json() assert res['name'] == lang assert 0 需要注意的点 每次都可以用request.param来访问本次传入fixture中的参数 在测试方法中传入同名的fixture方法名可以直接访问fixture 使用assert(0)强制用例失败，这样可以看到每次fixture的参数值 运行 $ pytest v2ex_api_test.py ======================================================================== test session starts ======================================================================== platform darwin -- Python 2.7.12, pytest-3.2.3, py-1.4.34, pluggy-0.4.0 rootdir: /Users/easonhan/code/testclass.net/src/pytest, inifile: collected 5 items v2ex_api_test.py .FFFF ============================================================================= FAILURES ============================================================================== ______________________________________________________________ TestV2exApiWithParams.test_node[python] ______________________________________________________________ self = &lt;v2ex_api_test.TestV2exApiWithParams object at 0x105e0edd0&gt;, lang = 'python' def test_node(self, lang): path = 'api/nodes/show.json?name=%s' %(lang) url = self.domain + path res = requests.get(url).json() assert res['name'] == lang &gt; assert 0 E assert 0 v2ex_api_test.py:27: AssertionError _______________________________________________________________ TestV2exApiWithParams.test_node[java] _______________________________________________________________ self = &lt;v2ex_api_test.TestV2exApiWithParams object at 0x1075e2750&gt;, lang = 'java' def test_node(self, lang): path = 'api/nodes/show.json?name=%s' %(lang) url = self.domain + path res = requests.get(url).json() assert res['name'] == lang &gt; assert 0 E assert 0 v2ex_api_test.py:27: AssertionError ________________________________________________________________ TestV2exApiWithParams.test_node[go] ________________________________________________________________ self = &lt;v2ex_api_test.TestV2exApiWithParams object at 0x107636190&gt;, lang = 'go' def test_node(self, lang): path = 'api/nodes/show.json?name=%s' %(lang) url = self.domain + path res = requests.get(url).json() assert res['name'] == lang &gt; assert 0 E assert 0 v2ex_api_test.py:27: AssertionError ______________________________________________________________ TestV2exApiWithParams.test_node[nodejs] ______________________________________________________________ self = &lt;v2ex_api_test.TestV2exApiWithParams object at 0x1075e2790&gt;, lang = 'nodejs' def test_node(self, lang): path = 'api/nodes/show.json?name=%s' %(lang) url = self.domain + path res = requests.get(url).json() assert res['name'] == lang &gt; assert 0 E assert 0 v2ex_api_test.py:27: AssertionError ================================================================ 4 failed, 1 passed in 1.91 seconds ================================================================= 用例执行失败，但是每次运行时lang的值我们可以看的很明白。 10.使用fixture参数化测试预期结果 接上一节v2ex网站的查看论坛节点信息的api。 我们在上一节的测试用例里只断言了返回值的name字段必须与我们传入的入参相同，但是返回值的id却没有进行判定。这一节里我们加强一下测试脚本，实现判断id的功能。 测试数据 python, id=90 java, id=63 nodejs, id=436 go, id=375 代码实现 在v2ex_api_test.py的文件中加入如下内容: class TestV2exApiWithExpectation(object): domain = 'https://www.v2ex.com/' @pytest.mark.parametrize('name,node_id', [('python', 90), ('java', 63), ('go', 375), ('nodejs', 436)]) def test_node(self, name, node_id): path = 'api/nodes/show.json?name=%s' %(name) url = self.domain + path res = requests.get(url).json() assert res['name'] == name assert res['id'] == node_id assert 0 运行及结果 $ pytest v2ex_api_test.py ======================================================================== test session starts ======================================================================== platform darwin -- Python 2.7.12, pytest-3.2.3, py-1.4.34, pluggy-0.4.0 rootdir: /Users/easonhan/code/testclass.net/src/pytest, inifile: collected 9 items v2ex_api_test.py .FFFFFFFF ============================================================================= FAILURES ============================================================================== ______________________________________________________________ TestV2exApiWithParams.test_node[python] ______________________________________________________________ self = &lt;v2ex_api_test.TestV2exApiWithParams object at 0x10618eb10&gt;, lang = 'python' def test_node(self, lang): path = 'api/nodes/show.json?name=%s' %(lang) url = self.domain + path res = requests.get(url).json() assert res['name'] == lang &gt; assert 0 E assert 0 v2ex_api_test.py:27: AssertionError _______________________________________________________________ TestV2exApiWithParams.test_node[java] _______________________________________________________________ self = &lt;v2ex_api_test.TestV2exApiWithParams object at 0x106691790&gt;, lang = 'java' def test_node(self, lang): path = 'api/nodes/show.json?name=%s' %(lang) url = self.domain + path res = requests.get(url).json() assert res['name'] == lang &gt; assert 0 E assert 0 v2ex_api_test.py:27: AssertionError ________________________________________________________________ TestV2exApiWithParams.test_node[go] ________________________________________________________________ self = &lt;v2ex_api_test.TestV2exApiWithParams object at 0x10666dc50&gt;, lang = 'go' def test_node(self, lang): path = 'api/nodes/show.json?name=%s' %(lang) url = self.domain + path res = requests.get(url).json() assert res['name'] == lang &gt; assert 0 E assert 0 v2ex_api_test.py:27: AssertionError ______________________________________________________________ TestV2exApiWithParams.test_node[nodejs] ______________________________________________________________ self = &lt;v2ex_api_test.TestV2exApiWithParams object at 0x106691890&gt;, lang = 'nodejs' def test_node(self, lang): path = 'api/nodes/show.json?name=%s' %(lang) url = self.domain + path res = requests.get(url).json() assert res['name'] == lang &gt; assert 0 E assert 0 v2ex_api_test.py:27: AssertionError __________________________________________________________ TestV2exApiWithExpectation.test_node[python-90] __________________________________________________________ self = &lt;v2ex_api_test.TestV2exApiWithExpectation object at 0x1066d20d0&gt;, name = 'python', node_id = 90 @pytest.mark.parametrize('name,node_id', [('python', 90), ('java', 63), ('go', 375), ('nodejs', 436)]) def test_node(self, name, node_id): path = 'api/nodes/show.json?name=%s' %(name) url = self.domain + path res = requests.get(url).json() assert res['name'] == name assert res['id'] == node_id &gt; assert 0 E assert 0 v2ex_api_test.py:40: AssertionError ___________________________________________________________ TestV2exApiWithExpectation.test_node[java-63] ___________________________________________________________ self = &lt;v2ex_api_test.TestV2exApiWithExpectation object at 0x1066e9690&gt;, name = 'java', node_id = 63 @pytest.mark.parametrize('name,node_id', [('python', 90), ('java', 63), ('go', 375), ('nodejs', 436)]) def test_node(self, name, node_id): path = 'api/nodes/show.json?name=%s' %(name) url = self.domain + path res = requests.get(url).json() assert res['name'] == name assert res['id'] == node_id &gt; assert 0 E assert 0 v2ex_api_test.py:40: AssertionError ___________________________________________________________ TestV2exApiWithExpectation.test_node[go-375] ____________________________________________________________ self = &lt;v2ex_api_test.TestV2exApiWithExpectation object at 0x10666d790&gt;, name = 'go', node_id = 375 @pytest.mark.parametrize('name,node_id', [('python', 90), ('java', 63), ('go', 375), ('nodejs', 436)]) def test_node(self, name, node_id): path = 'api/nodes/show.json?name=%s' %(name) url = self.domain + path res = requests.get(url).json() assert res['name'] == name assert res['id'] == node_id &gt; assert 0 E assert 0 v2ex_api_test.py:40: AssertionError _________________________________________________________ TestV2exApiWithExpectation.test_node[nodejs-436] __________________________________________________________ self = &lt;v2ex_api_test.TestV2exApiWithExpectation object at 0x1066d2710&gt;, name = 'nodejs', node_id = 436 @pytest.mark.parametrize('name,node_id', [('python', 90), ('java', 63), ('go', 375), ('nodejs', 436)]) def test_node(self, name, node_id): path = 'api/nodes/show.json?name=%s' %(name) url = self.domain + path res = requests.get(url).json() assert res['name'] == name assert res['id'] == node_id &gt; assert 0 E assert 0 v2ex_api_test.py:40: AssertionError ================================================================ 8 failed, 1 passed in 1.81 seconds ================================================================= 11.生成xml格式的测试报告 pytest有非常友好的命令行报告输出，在做用例开发的时候，这是极好的。然而我们在运行用例后经常会需要将测试结果广而告之，发送给相关责任人浏览，所以生成简洁美观的测试报告是很有必要的。 生成junit格式的xml报告 pytest可以生成junit格式的xml报告，在命令行中加入--junit-xml=path 参数就可以了。 pytest test_quick_start.py --junit-xml=report.xml 上面的命令在当前文件夹中生成了名为report.xml的测试报告 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;testsuite errors=&quot;0&quot; failures=&quot;0&quot; name=&quot;pytest&quot; skips=&quot;0&quot; tests=&quot;1&quot; time=&quot;0.009&quot;&gt;&lt;testcase classname=&quot;test_quick_start&quot; file=&quot;test_quick_start.py&quot; line=&quot;3&quot; name=&quot;test_reverse&quot; time=&quot;0.000499725341797&quot;&gt;&lt;/testcase&gt;&lt;/testsuite&gt;% ci集成 jenkins在build后可以通过插件展示junit格式的测试报告，具体步骤就不描述了。 ","link":"https://preszang.github.io/post/3oHikQsbE/"},{"title":"关于软件测试和软件测试人员","content":"一、软件测试人员应该居安思危 身为测试人员，虽然我们平常的工作相对比较安逸。 但是千万不能温水煮青蛙。 应该自强不息， 要像开发人员一样， 不断学习，提高自己的编程水平。 二、测试人员应该比开发人员更熟悉业务需求 1. 测试人员的水平主要体现在测试用例的设计上。 要设计出全面，覆盖广的测试用例，需要测试人员对自己所测试的项目的业务需求非常熟悉，甚至要比开发人员还要熟悉。 2. 这些业务知识非常有用的，学习起来比较有激情。 3. 要熟读功能需求文档， 任何有疑问的地方都要去和PM确认。 4. 把自己当成最终用户， 经常使用自己所测试的软件。模拟用户的行为。 5. 熟记软件的每个功能。 三、学会如何跟开发人员相处 1. 测试人员必须跟开发人员密切合作， 所以跟开发人员搞好关系是相当重要的。 2. 和开发人员成为朋友，熟悉了干啥都方便 3. 不要打扰开发人员，看到开发在聚精会神写代码的时候，千万不要去打扰人家。 写代码需要集中精力，如果被打扰，就会中断思考。 4. 集中问问题。把需要问的问题都总结起来， 集中起来问开发，这样能节省大量的时间。 5. 提好的Bug，不被开发人员烦。如果开发人员看到一个Bug 描述不清楚，还无法重现，他肯定会骂测试人员。 所以测试人员一定要写好Bug，描述精确，简洁，没有歧义，详细简洁的重现步骤，加截图。 四、测试人员应该懂一些基本的编程 1. 你的产品是用`php` 开发的，那测试人员应该有`php`的入门知识。 如果架构是微服务，那起码要懂得一些`RPC`相关的东西吧。 2. 你测试web程序，你起码要了解`HTML`、`CSS`、 `Javascript`、` Jquery`吧，否则你测了一两年web程序，都不知道这东西是怎么做的，悲剧了吧。 3. 只有懂代码你才能和开发人员交流，不被开发鄙视。 五、测试人员搭建开发环境 1. 项目的代码是最好的学习资料了，我们不能总跟在开发屁股后面做测试，不能老是等开发`build`一个版本后，我们就测试这个版本，开发`commit`了什么代码，测试人员一点都不知道。 2. 偶尔我们应该了解下产品代码是怎么设计的，了解下开发人员是如何修复bug的。 3. 说不定编程水平高了，还能帮开发做`code review`。 4. 使用工具把代码`check out`到本机。 经常看看代码，尤其是经常看看开发修复bug时候提交的代码，事半功倍。 六、写文档是测试人员的核心能力 1. 多写写博客，写写文档，多总结。 2. 测试后期应该做交叉测试，就是指两个测试工程师，互相交换下测试的项目。 这样做有很多好处。 3. 有利于找出bug, 测试工程师测久了自己的项目，容易形成眼盲。会对一些Bug熟视无睹。 4. 有利于知识和业务共享，避免人员离职，请假，造成无人测试的情况。 5. 测试思想不一样，可以互相找出很多问题 七、测试人员的瓶颈 黑盒测试工作做个两三年，基本上就能掌握测试需要的大部分知识， 很多人就感觉到发展瓶颈了，每天重复测试，学不到东西，很快就会对测试工作失去激情。 学不到东西，技术水平低下，是测试这个行业最大的毛病。 如何突破瓶颈？ 我也不知道。 八、尽量实现自动化 1. 抽时间尽量把自己的测试工作实现自动化，可以节省测试的时间，提高自己的技术水平，也可以避免老是重复测试，~~也为了更方便的摸鱼~~ 九、自动化测试VS手动测试 1. 自动化是趋势， 只会做手工测试的人，以后肯定会失去竞争力。 2. 自动化测试的技术和开发用到的技术相差太远。 3. 努力学习编码，然后用于测试，才是正道 十、优秀的测试人员非常稀少 1. 想把测试做好非常不容易 2. 优秀的测试人员需要很广的知识面，良好的沟通能力（不但要和开发人员和项目经理打交道，还要跟其他组的人交流）。 3. 丰富的测试经验，对测试工作有极大的热情， 耐心。 4. 还需要测试人员有丰富的业务知识 5. 还要会写代码。 十一、尽量少用UI自动化测试，多使用单元测试，接口测试 1. 能找到`bug`的自动化测试，才是有用的，否则就是个噱头 2. `UI`自动化测试比较不稳定，对于测试结果的分析也困难。 3. 而且`UI`改动也大。 所以应该尽量多做一些底层的的自动化测试， ","link":"https://preszang.github.io/post/关于软件测试和软件测试人员/"},{"title":"【女儿情】叶锐文版本","content":" ","link":"https://preszang.github.io/post/nu-er-qing-xie-rui-wen-ban-ben/"},{"title":"Pyunit测试框架基本教程","content":"1. 基本概念 unittest是python自带的单元测试框架，有时候又被称为&quot;PyUnit&quot;，是python版本的JUint实现。 该框架的作者是 Kent Beck和Erich Gamma，感谢祖师爷赏饭吃。 在学习使用unittest库之前，我们需要了解一下unittest库的一些重要概念: test fixture: 代表了用例执行前的准备工作和用例执行之后的清理工作。比如在用例执行前创建临时文件和文件夹，又或者启动1个server进程等； test case: 测试用例，这个相信大家都不陌生。是测试的最小单位，一般检查一组输入的响应(输出)是否符合预期。unittest模块提供了TestCase类来帮助我们创建测试用例； test suite: 经常被翻译成&quot;测试套件&quot;，也有人称为&quot;测试套&quot;，是测试用例或测试套件的集合，一般用来把需要一起执行的用例组合到一起; test runner: 用来执行测试用例并输出测试结果的组件。可以是图形界面或命令行界面; test fixture的功能可以理解成是初始化和清理测试数据及环境 test case是测试用例 test suite是用例集合 test runner的作用是运行用例并返回结果 2. 基本用法 我们通过最简单的例子来看一下unittest的基本用法，下面的代码测试了3个python字符串方法，基本上满足了大部分情况下的测试需求 import unittest class TestStringMethods(unittest.TestCase): def test_upper(self): self.assertEqual('foo'.upper(), 'FOO') def test_isupper(self): self.assertTrue('FOO'.isupper()) self.assertFalse('Foo'.isupper()) def test_split(self): s = 'hello world' self.assertEqual(s.split(), ['hello', 'world']) # check that s.split fails when the separator is not a string with self.assertRaises(TypeError): s.split(2) if __name__ == '__main__': unittest.main() 解释一下关键点 可以通过继承unittest.TestCase类来定义我们自己的测试用例，1个测试用例类下面可以有多个测试方法(test)或者叫做测试点 记住这个套路：测试用例中方法名以test开头的方法才是测试方法，比如上面的例子里定义了3个以test开头的方法，分别是test_upper，test_isupper和test_split。非测试方法是不会被test runner执行的 断言是测试用例的核心。我们使用assertEqual()来判断预期结果，用assertTrue()和assertFalse来做是非判断，以及用assertRaises()来判断预期的异常是否有被抛出。这些unittest提供的以assert开头的方法就是断言，一般情况下,每个测试方法里都必须有断言 最后, unittest.main提供了最简单的运行用例的方式。当我们从命令行运行上面的代码时，我们可以看到如下的输出 ... ---------------------------------------------------------------------- Ran 3 tests in 0.000s OK 除了使用unittest.main，还有其他的方式可以运行测试用例，比如把最后2行替换为 suite = unittest.TestLoader().loadTestsFromTestCase(TestStringMethods) unittest.TextTestRunner(verbosity=2).run(suite) 运行用例，结果将会如下所示 test_isupper (__main__.TestStringMethods) ... ok test_split (__main__.TestStringMethods) ... ok test_upper (__main__.TestStringMethods) ... ok ---------------------------------------------------------------------- Ran 3 tests in 0.001s OK 3. 实例: 测试弱密码 我们需要判断用户的密码中包含简单密码，规则是这样的，密码必须至少6位，满足6位的话判断用户的密码不是password123或者password之类的弱密码。 对于如下的测试数据，我们要如何使用unittest来进行相关测试呢？ [ {&quot;name&quot;:&quot;jack&quot;,&quot;password&quot;:&quot;Iloverose&quot;}, {&quot;name&quot;:&quot;rose&quot;,&quot;password&quot;:&quot;Ilovejack&quot;}, {&quot;name&quot;:&quot;tom&quot;,&quot;password&quot;:&quot;password123&quot;} ] Test fixture 前文我们也说过，text fixture的主要功能是初始化测试数据或环境以及清理测试数据或环境。 考虑上面的例子，对我们而言，在用例执行之前初始化上面的测试数据是有必要的，我们可以把上面的数据用python的数据结构来表示，比较合适的数据结构是python的字典。这样做有如下的好处 统一初始化一些需要在多个用例之间共享的数据 可以在初始化的时候做一些数据的处理工作，比如过滤一些无效数据等 Test fixture最简单的实现方式是通过自定义下面的2个方法: TestCase.setUp方法在每个测试方法运行之前都会运行一次，适合为每个用例都初始化一遍数据 TestCase.tearDown方法在每个测试方法运行之后都会运行一次，适合为每个用例都清理一遍数据 代码 新建名为test_password_1.py的文本文件，输入如下内容 import unittest class PasswordTestCase(unittest.TestCase): def setUp(self): print('set up') self.test_data = [ dict(name='jack', password='Iloverose'), dict(name='rose', password='Ilovejack'), dict(name='tom', password='password123') ] def test_weak_password(self): for data in self.test_data: passwd = data['password'] self.assertTrue(len(passwd) &gt;= 6) msg = &quot;user %s has a weak password&quot; %(data['name']) self.assertTrue(passwd != 'password', msg) self.assertTrue(passwd != 'password123', msg) def test_dummy(self): pass if __name__ == '__main__': unittest.main() 运行 在命令行里输入 python test_password_1.py来运行用例，结果如下 $ python test_password_1.py set up .set up F ====================================================================== FAIL: test_week_password (__main__.PasswordTestCase) ---------------------------------------------------------------------- Traceback (most recent call last): File &quot;test_password_1.py&quot;, line 21, in test_week_password self.assertTrue(passwd != 'password123', msg) AssertionError: False is not true : user tom has a weak password ---------------------------------- Ran 2 tests in 0.001s FAILED (failures=1) 解释一下 setUp方法运行了2次，所以打印出了2次'set up'，这是因为上面的用例中有2个测试方法(2个方法名以test开头的方法)，setUp会在每个测试方法执行之前执行1次 由于用户tom的密码是弱密码password123，所以上面的用例运行失败了，打印出1个&quot;F&quot;，有几个F就代表有几个测试用例失败 测试方法运行失败时测试结果里会打印出失败方法的方法名，因此好的测试方法名可以方便我们快速找出失败用例 为了让错误信息更加容易理解，我们经常会自定义断言出错提示消息，比如msg = &quot;user %s has a weak password&quot; %(data['name'])。一旦断言失败，我们一眼就能看出是哪个用户的密码强度不够 亲自动手试一试 假设我们增加1条测试数据，如下所示 [ {&quot;name&quot;:&quot;jack&quot;,&quot;password&quot;:&quot;Iloverose&quot;}, {&quot;name&quot;:&quot;rose&quot;,&quot;password&quot;:&quot;Ilovejack&quot;}, {&quot;name&quot;:&quot;tom&quot;,&quot;password&quot;:&quot;password123&quot;}, {&quot;name&quot;:&quot;jerry&quot;,&quot;password&quot;:&quot;password&quot;} ] 再运行上面的用例，观察一下测试结果是否会有不同？如果没有不同，那是为什么？ 4. 实例: 读取测试数据并测试弱密码 接上一节的弱密码例子，我们的用例尽管运行的不错，但还是有点问题。 假如我们需要增加一些测试数据，那么我们就必须去修改setUp方法，在test_data列表中增加数据，\b频繁修改代码以适应一些不变的测试场景，这是没有必要的开销，可以想办法去优化。 我们可以把测试数据保存在文件里，通过读取文件的方式，每次动态从测试用例读取数据，这样数据的改变并不会影响用例，用例逻辑相对稳定，维护成本得到一定的降低。 设计测试数据 我们可以把测试数据保存成json格式，json格式的数据在各个语言间有较好的通用性，比较适合复用。 新建user_data.json文件，内容如下 [ {&quot;name&quot;:&quot;jack&quot;,&quot;password&quot;:&quot;Iloverose&quot;}, {&quot;name&quot;:&quot;rose&quot;,&quot;password&quot;:&quot;Ilovejack&quot;}, {&quot;name&quot;:&quot;tom&quot;,&quot;password&quot;:&quot;password123&quot;} ] 使用python的json库解析上面的json文件，可以得到如上节中test_data一致的数据。 代码 新建test_password_2.py，内容如下 import unittest import json class PasswordWithJsonTestCase(unittest.TestCase): data_file_path = './user_data.json' def setUp(self): print('set up') self.test_data = json.loads(open(self.data_file_path).read()) def test_weak_password(self): for data in self.test_data: passwd = data['password'] self.assertTrue(len(passwd) &gt;= 6) msg = &quot;user %s has a weak password&quot; %(data['name']) self.assertTrue(passwd != 'password', msg) self.assertTrue(passwd != 'password123', msg) def test_dummy(self): pass if __name__ == '__main__': unittest.main() 跟上一节相比，最大的不同点是现在test_data通过解析json文件的方式来赋值self.test_data = json.loads(open(self.data_file_path).read())。 执行测试文件，结果应该与上一节一致。 发现问题 上面的代码有2个测试方法:test_week_password和test_dummy。由于setUp会在每个测试方法执行之前执行一次，那么setUp方法会执行2次，相应的json文件也会读取2次。如果测试方法多的话，那么反复读取json文件对性能来说是一个巨大的挑战。 优化 对于上面的测试数据读取场景，我们可以在所有测试方法执行前读取一次数据，毕竟测试数据在所有测试方法执行过程中是保持不变的。 setUpClass()和tearDownClass() setUpClass方法在每个测试用例类执行之前会执行一次，接收该class作为唯一的参数，并且必须使用装饰器classmethod() tearDownClass: 在所有测试方法执行完之后被调用1次，调用方式跟上面的方法类似 重构 下面我们重构代码以达到只读取1次测试数据的目的，新建文件``test_password_3.py`，内容如下 import unittest import json class WeakPasswordTestCase(unittest.TestCase): @classmethod def setUpClass(kls): data_file_path = './user_data.json' print('before all test methods') with open(data_file_path) as f: kls.test_data = json.loads(f.read()) def test_weak_password(self): for data in self.test_data: passwd = data['password'] self.assertTrue(len(passwd) &gt;= 6) msg = &quot;user %s has a weak password&quot; %(data['name']) self.assertTrue(passwd != 'password', msg) 5. 实例: 找出所有是弱密码的用户 当我们的测试数据是下面这些的时候，我们的用例是有问题的。 [ {&quot;name&quot;:&quot;jack&quot;,&quot;password&quot;:&quot;Iloverose&quot;}, {&quot;name&quot;:&quot;rose&quot;,&quot;password&quot;:&quot;Ilovejack&quot;}, {&quot;name&quot;:&quot;tom&quot;,&quot;password&quot;:&quot;password123&quot;}, {&quot;name&quot;:&quot;jerry&quot;,&quot;password&quot;:&quot;password&quot;} ] 我们的用例只能找出tom是弱密码的用户，jerry这个用户会成为漏网之鱼。 为什么 这是因为在unittest中，一旦某个测试方法中的断言失败，后续的断言都不会被执行。 还原一下上面的例子，当用例在断言tom失败后，for循环就退出了，测试方法也执行完毕了，后面jerry这条数据就不会被断言。 怎么办 我们可以重构一下我们的用例，让整个用例只断言1次，断言失败以后就把弱密码的用户打印出来。 代码 修改user_data.json文件，加入一些测试数据，修改后的user_data.json文件应该是 [ {&quot;name&quot;:&quot;jack&quot;,&quot;password&quot;:&quot;Iloverose&quot;}, {&quot;name&quot;:&quot;rose&quot;,&quot;password&quot;:&quot;Ilovejack&quot;}, {&quot;name&quot;:&quot;tom&quot;,&quot;password&quot;:&quot;password123&quot;}, {&quot;name&quot;:&quot;jerry&quot;,&quot;password&quot;:&quot;password&quot;}, {&quot;name&quot;:&quot;fred&quot;,&quot;password&quot;:&quot;123456&quot;}, {&quot;name&quot;:&quot;elma&quot;,&quot;password&quot;:&quot;654321&quot;} ] 新建test_password_4.py文件，内容如下 import unittest import json class WeakPasswordTestCase1(unittest.TestCase): @classmethod def setUpClass(kls): data_file_path = './user_data.json' print('before all test methods') with open(data_file_path) as f: kls.test_data = json.loads(f.read()) def test_weak_password(self): res = True msg = [] for data in self.test_data: passwd = data['password'] tmp_res = True tmp_res = tmp_res and (len(passwd) &gt;= 6) tmp_res = tmp_res and (passwd != 'password') tmp_res = tmp_res and (passwd != 'password123') if not tmp_res: msg.append(&quot;user %s has a weak password %s&quot; %(data['name'], data['password'])) res = res and tmp_res self.assertTrue(res, &quot;\\n&quot;.join(msg)) def test_dummy(self): pass if __name__ == '__main__': unittest.main() 运行及结果 在命令行中运行python test_password_4.py，结果如下 $ python test_password_4.py before all test methods .F ====================================================================== FAIL: test_weak_password (__main__.WeakPasswordTestCase1) ---------------------------------------------------------------------- Traceback (most recent call last): File &quot;test_password_4.py&quot;, line 27, in test_week_password self.assertTrue(res, &quot;\\n&quot;.join(msg)) AssertionError: user tom has a weak password password123 user jerry has a weak password password ---------------------------------------------------------------------- Ran 2 tests in 0.001s FAILED (failures=1) 我们能学到什么 断言一旦失败之后测试方法就会结束运行，所以一般来说1个测试方法推荐只有1个断言 如果一个测试方法里面必须要有多个断言，那么要确保前面的断言失败之后，后面的断言就算不运行也不会影响测试的范围和结果 for循环中的断言一旦失败，for循环就退出了 上面演示的测试用例写法其实具备了一定的数据驱动测试的思想 6. 命令行接口 unittest支持命令行接口，我们可以在命令行里指定运行具体的测试用例。 在test_password_1.py中定义了PasswordTeseCase用例，我们可以从命令行中指定只运行该用例。 $ python -m unittest test_password_1.PasswordTeseCase set up .set up F ====================================================================== FAIL: test_week_password (test_password_1.PasswordTeseCase) ---------------------------------------------------------------------- Traceback (most recent call last): File &quot;/Users/aaa/code/test_password_1.py&quot;, line 21, in test_week_password self.assertTrue(passwd != 'password123', msg) AssertionError: False is not true : user tom has a weak password ---------------------------------------------------------------------- Ran 2 tests in 0.001s FAILED (failures=1) 还可以使用-v参数来获得更详细的输出 $ python -m unittest test_password_1.PasswordTeseCase -v test_dummy (test_password_1.PasswordTeseCase) ... set up ok test_week_password (test_password_1.PasswordTeseCase) ... set up FAIL ====================================================================== ### FAIL: test_week_password (test_password_1.PasswordTeseCase) Traceback (most recent call last): File &quot;/Users/aaa/code/test_password_1.py&quot;, line 21, in test_week_password self.assertTrue(passwd != 'password123', msg) AssertionError: False is not true : user tom has a weak password ---------------------------------------------------------------------- Ran 2 tests in 0.001s FAILED (failures=1) 7. 各种断言方法 unittest支持各种断言方法。 断言列表---官方文档 方法 检查点 assertEqual(a, b) a == b assertNotEqual(a, b) a != b assertTrue(x) bool(x) is True assertFalse(x) bool(x) is False assertIs(a, b) a is b assertIsNot(a, b) a is not b assertIsNone(x) x is None assertIsNotNone(x) x is not None assertIn(a, b) a in b assertNotIn(a, b) a not in b assertIsInstance(a, b) isinstance(a, b) assertNotIsInstance(a, b) not isinstance(a, b) assertRaises(exc, fun, *args, **kwds) fun(*args, **kwds) raises exc assertRaisesRegexp(exc, r, fun, *args, **kwds) fun(*args, **kwds) raises exc and the message matches regex r assertAlmostEqual(a, b) round(a-b, 7) == 0 assertNotAlmostEqual(a, b) round(a-b, 7) != 0 assertGreater(a, b) a &gt; b 2.7 assertGreaterEqual(a, b) a &gt;= b assertLess(a, b) a &lt; b assertLessEqual(a, b) a &lt;= b assertRegexpMatches(s, r) r.search(s) assertNotRegexpMatches(s, r) not r.search(s) assertItemsEqual(a, b) sorted(a) == sorted(b) 也支持unhashable对象 assertDictContainsSubset(a, b) a里面所有的键值对都在b中存在 8. 断言异常 我们有时候需要断言一些方法会抛出异常，这些异常需要符合我们的预期。 新建test_exception.py文件，内容如下 import unittest class DivZeroTestCase(unittest.TestCase): def test_should_raise_exception(self): with self.assertRaises(ZeroDivisionError): 1 / 0 if __name__ == '__main__': unittest.main() 运行及结果 $ python test_exception.py ---------------------------------------------------------------------- Ran 1 test in 0.000s OK 上面的例子断言了当0作为除数的时候会抛出ZeroDivisionError 断言异常是有套路的，使用with语句加assertRaises，assertRaises的参数中传入预期的异常(这些异常可能需要先import进来)，在with的子句中放上会抛出异常的语句或表达式。 ","link":"https://preszang.github.io/post/Pyunit测试框架基本教程/"},{"title":"Python 第三方日志框架 loguru 使用","content":"Python 第三方日志框架 loguru 使用 看到了一个不错的 python 第三方日志框架 loguru，优雅的记录日志 Github: https://github.com/Delgan/loguru 文档：https://loguru.readthedocs.io/en/stable/index.html 1、安装 pip install loguru 2、输出日志 from loguru import logger logger.debug(&quot;这是一条debug日志&quot;) # 终端执行后出现带颜色的日志，挺酷的 3、输出到文件 from loguru import logger logger.add(&quot;file_{time}.log&quot;) logger.debug(&quot;这是一条debug日志&quot;) logger.info(&quot;这是一条info日志&quot;) # 目录下多出一个日志文件 ：file_2019-03-14_19-53-25_661314.log 4、日志规则 from loguru import logger # 设置日志格式，过滤器，日志级别 logger.add(&quot;file.log&quot;, format=&quot;{time} {level} {message}&quot;, filter=&quot;&quot;, level=&quot;INFO&quot;) logger.debug(&quot;这是一条debug日志&quot;) logger.info(&quot;这是一条info日志&quot;) #输出 # 2019-03-14T20:01:25.392454+0800 INFO 这是一条info日志 5、日志文件 # 文件管理方式 logger.add(&quot;file_1.log&quot;, rotation=&quot;500 MB&quot;) # 文件过大就会重新生成一个文件 logger.add(&quot;file_2.log&quot;, rotation=&quot;12:00&quot;) # 每天12点创建新文件 logger.add(&quot;file_3.log&quot;, rotation=&quot;1 week&quot;) # 文件时间过长就会创建新文件 logger.add(&quot;file_X.log&quot;, retention=&quot;10 days&quot;) # 一段时间后会清空 logger.add(&quot;file_Y.log&quot;, compression=&quot;zip&quot;) # 保存zip格式 6、其他参数 logger.add(&quot;somefile.log&quot;, enqueue=True) # 异步写入 logger.add(&quot;somefile.log&quot;, serialize=True) # 序列化为json 7、时间格式化 logger.add(&quot;file.log&quot;, format=&quot;{time:YYYY-MM-DD at HH:mm:ss} | {level} | {message}&quot;) 配合 notifiers 模块 github： https://github.com/notifiers/notifiers 文档：https://notifiers.readthedocs.io/en/latest/ 8、在工程中创建多个文件处理器对象并解决中文乱码问题 # coding=utf-8 import os import sys from loguru import logger BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) log_file_path = os.path.join(BASE_DIR, 'Log/my.log') err_log_file_path = os.path.join(BASE_DIR, 'Log/err.log') logger.add(sys.stderr, format=&quot;{time} {level} {message}&quot;, filter=&quot;my_module&quot;, level=&quot;INFO&quot;) # logger.add(s) logger.add(log_file_path, rotation=&quot;500 MB&quot;, encoding='utf-8') # Automatically rotate too big file logger.add(err_log_file_path, rotation=&quot;500 MB&quot;, encoding='utf-8',level='ERROR') # Automatically rotate too big file logger.debug(&quot;That's it, beautiful and simple logging!&quot;) logger.debug(&quot;中文日志可以不&quot;) logger.error(&quot;严重错误&quot;) ","link":"https://preszang.github.io/post/Python 第三方日志框架 loguru 使用/"},{"title":"【山雀】万能青年旅店","content":" ","link":"https://preszang.github.io/post/shan-que-wan-neng-qing-nian-lu-dian/"}]}