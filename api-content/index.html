{"posts":[{"title":"python+selenium自动化UI测试基本教程","content":"一、安装selenium 1. 安装python 打开 Python官网，找到Download, 安装最新版python，python 的安装方法再此不详细介绍了。 2. 安装selenium 确保pip命令可用，如果提示“pip不是内部或外部命令”，需要将将pip的安装目录添加到环境变量PATH下面。 接下来通过pip命令安装Selenium: pip install selenium Collecting selenium Downloading selenium-3.4.3-py2.py3-none-any.whl (931kB) 26% |████████ | 245kB 576kB/s eta 0:00:02 27% |█████████ | 256kB 570kB/s eta 0:00:02 28% |██████████ | 266kB 536kB/s eta 0:00:0 29% |███████████ | 276kB 530kB/s eta 0:00:0 30% |████████████ | 286kB 586kB/s eta 0:00:0 …… 打开编辑器，输入以下代码，如果执行报错，请看下一节 from selenium import webdriver driver = webdriver.Chrome() driver.get('https://www.baidu.com') print(driver.title) driver.quit() 二、selenium3 浏览器驱动 下载浏览器驱动 当selenium升级到3.0之后，对不同的浏览器驱动进行了规范。如果想使用selenium驱动不同的浏览器，必须单独下载并设置不同的浏览器驱动。（注：部分浏览器驱动地址需要科学上网。） Firefox浏览器驱动：geckodriver Chrome浏览器驱动：chromedriver , taobao备用地址[常用] IE浏览器驱动：IEDriverServer Edge浏览器驱动：MicrosoftWebDriver Opera浏览器驱动：operadriver PhantomJS浏览器驱动：phantomjs 设置浏览器驱动 设置浏览器的地址非常简单。 我们可以手动创建一个存放浏览器驱动的目录，如： C:\\driver , 将下载的浏览器驱动文件（例如：chromedriver、geckodriver）丢到该目录下。 验证不同的浏览器驱动是否正常使用。 from selenium import webdriver driver = webdriver.Firefox() # Firefox浏览器 driver = webdriver.Chrome() # Chrome浏览器 driver = webdriver.Ie() # Internet Explorer浏览器 driver = webdriver.Edge() # Edge浏览器 driver = webdriver.Opera() # Opera浏览器 driver = webdriver.PhantomJS() # PhantomJS 三、selenium元素定位 selenium定位方法 Selenium提供了8种定位方式。 id、name、class name、tag name、link text、partial link text、xpath、css selector 这8种定位方式在Python selenium中所对应的方法为： find_element_by_id() find_element_by_name() find_element_by_class_name() find_element_by_tag_name() find_element_by_link_text() find_element_by_partial_link_text() find_element_by_xpath() find_element_by_css_selector() 定位方法的用法 假如我们有一个Web页面，通过前端工具（如，Firebug）查看到一个元素的属性是这样的。 &lt;html&gt; &lt;head&gt; &lt;body link=&quot;#0000cc&quot;&gt; &lt;a id=&quot;result_logo&quot; href=&quot;/&quot; onmousedown=&quot;return c({'fm':'tab','tab':'logo'})&quot;&gt; &lt;form id=&quot;form&quot; class=&quot;fm&quot; name=&quot;f&quot; action=&quot;/s&quot;&gt; &lt;span class=&quot;soutu-btn&quot;&gt;&lt;/span&gt; &lt;input id=&quot;kw&quot; class=&quot;s_ipt&quot; name=&quot;wd&quot; value=&quot;&quot; maxlength=&quot;255&quot; autocomplete=&quot;off&quot;&gt; 我们的目的是要定位input标签的输入框。 通过id定位: dr.find_element_by_id(&quot;kw&quot;) 通过name定位: dr.find_element_by_name(&quot;wd&quot;) 通过class name定位: dr.find_element_by_class_name(&quot;s_ipt&quot;) 通过tag name定位: dr.find_element_by_tag_name(&quot;input&quot;) 通过xpath定位，xpath定位有N种写法，这里列几个常用写法: dr.find_element_by_xpath(&quot;//*[@id='kw']&quot;) dr.find_element_by_xpath(&quot;//*[@name='wd']&quot;) dr.find_element_by_xpath(&quot;//input[@class='s_ipt']&quot;) dr.find_element_by_xpath(&quot;/html/body/form/span/input&quot;) dr.find_element_by_xpath(&quot;//span[@class='soutu-btn']/input&quot;) dr.find_element_by_xpath(&quot;//form[@id='form']/span/input&quot;) dr.find_element_by_xpath(&quot;//input[@id='kw' and @name='wd']&quot;) 通过css定位，css定位有N种写法，这里列几个常用写法: dr.find_element_by_css_selector(&quot;#kw&quot;) dr.find_element_by_css_selector(&quot;[name=wd]&quot;) dr.find_element_by_css_selector(&quot;.s_ipt&quot;) dr.find_element_by_css_selector(&quot;html &gt; body &gt; form &gt; span &gt; input&quot;) dr.find_element_by_css_selector(&quot;span.soutu-btn&gt; input#kw&quot;) dr.find_element_by_css_selector(&quot;form#form &gt; span &gt; input&quot;) 接下来，我们的页面上有一组文本链接。 &lt;a class=&quot;mnav&quot; href=&quot;http://news.baidu.com&quot; name=&quot;tj_trnews&quot;&gt;新闻&lt;/a&gt; &lt;a class=&quot;mnav&quot; href=&quot;http://www.hao123.com&quot; name=&quot;tj_trhao123&quot;&gt;hao123&lt;/a&gt; 通过link text定位: dr.find_element_by_link_text(&quot;新闻&quot;) dr.find_element_by_link_text(&quot;hao123&quot;) 通过link text定位: dr.find_element_by_partial_link_text(&quot;新&quot;) dr.find_element_by_partial_link_text(&quot;hao&quot;) dr.find_element_by_partial_link_text(&quot;123&quot;) 关于xpaht和css的定位比较复杂，请参考xpath语法、css选择器 四、控制浏览器操作 控制浏览器窗口大小 有时候我们希望能以某种浏览器尺寸打开，让访问的页面在这种尺寸下运行。例如可以将浏览器设置成移动端大小(480* 800)，然后访问移动站点，对其样式进行评估；WebDriver提供了set_window_size()方法来设置浏览器的大小。 from selenium import webdriver driver = webdriver.Firefox() driver.get(&quot;http://m.baidu.com&quot;) # 参数数字为像素点 print(&quot;设置浏览器宽480、高800显示&quot;) driver.set_window_size(480, 800) driver.quit() 在PC端执行自动化测试脚本大多的情况下是希望浏览器在全屏幕模式下执行，那么可以使用maximize_window()方法使打开的浏览器全屏显示，其用法与set_window_size() 相同，但它不需要参数。 控制浏览器后退、前进 在使用浏览器浏览网页时，浏览器提供了后退和前进按钮，可以方便地在浏览过的网页之间切换，WebDriver也提供了对应的back()和forward()方法来模拟后退和前进按钮。下面通过例子来演示这两个方法的使用。 from selenium import webdriver driver = webdriver.Firefox() #访问百度首页 first_url= 'http://www.baidu.com' print(&quot;now access %s&quot; %(first_url)) driver.get(first_url) #访问新闻页面 second_url='http://news.baidu.com' print(&quot;now access %s&quot; %(second_url)) driver.get(second_url) #返回（后退）到百度首页 print(&quot;back to %s &quot;%(first_url)) driver.back() #前进到新闻页 print(&quot;forward to %s&quot;%(second_url)) driver.forward() driver.quit() 为了看清脚本的执行过程，下面每操作一步都通过print()来打印当前的URL地址。 刷新页面 driver.refresh() #刷新当前页面 五、WebDriver常用方法 点击和输入 前面已经学习了定位元素， 定位只是第一步， 定位之后需要对这个元素进行操作， 或单击（按钮） 或输入（输入框） ， 下面就来认识 WebDriver 中最常用的几个方法： clear()： 清除文本。 send_keys (value)： 模拟按键输入。 click()： 单击元素。 from selenium import webdriver driver = webdriver.Chrome() driver.get(&quot;https://www.baidu.com&quot;) driver.find_element_by_id(&quot;kw&quot;).clear() driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;selenium&quot;) driver.find_element_by_id(&quot;su&quot;).click() driver.quit() 提交 submit()方法用于提交表单。 例如， 在搜索框输入关键字之后的“回车” 操作， 就可以通过该方法模拟。 from selenium import webdriver driver = webdriver.Chrome() driver.get(&quot;https://www.baidu.com&quot;) search_text = driver.find_element_by_id('kw') search_text.send_keys('selenium') search_text.submit() driver.quit() 有时候 submit()可以与 click()方法互换来使用， submit()同样可以提交一个按钮， 但 submit()的应用范围远不及 click()广泛。 其他常用方法 size： 返回元素的尺寸。 text： 获取元素的文本。 get_attribute(name)： 获得属性值。 is_displayed()： 设置该元素是否用户可见。 from selenium import webdriver driver = webdriver.Chrome() driver.get(&quot;http://www.baidu.com&quot;) # 获得输入框的尺寸 size = driver.find_element_by_id('kw').size print(size) # 返回百度页面底部备案信息 text = driver.find_element_by_id(&quot;cp&quot;).text print(text) # 返回元素的属性值， 可以是 id、 name、 type 或其他任意属性 attribute = driver.find_element_by_id(&quot;kw&quot;).get_attribute('type') print(attribute) # 返回元素的结果是否可见， 返回结果为 True 或 False result = driver.find_element_by_id(&quot;kw&quot;).is_displayed() print(result) driver.quit() 输出结果： {'width': 500, 'height': 22} ©2015 Baidu 使用百度前必读 意见反馈 京 ICP 证 030173 号 text True 执行上面的程序并查看结果： size 方法用于获取百度输入框的宽、 高， text 方法用于获得百度底部的备案信息 get_attribute()用于获得百度输入的 type 属性的值， is_displayed()用于返回一个元素是否可见， 如果可见则返回 True， 否则返回 False。 六、鼠标事件 在 WebDriver 中， 将这些关于鼠标操作的方法封装在ActionChains 类提供。 ActionChains类提供了鼠标操作的常用方法： perform()： 执行所有 ActionChains 中存储的行为； context_click()： 右击； double_click()： 双击； drag_and_drop()： 拖动； move_to_element()： 鼠标悬停。 鼠标悬停操作 from selenium import webdriver # 引入 ActionChains 类 from selenium.webdriver.common.action_chains import ActionChains driver = webdriver.Chrome() driver.get(&quot;https://www.baidu.cn&quot;) # 定位到要悬停的元素 above = driver.find_element_by_link_text(&quot;设置&quot;) # 对定位到的元素执行鼠标悬停操作 ActionChains(driver).move_to_element(above).perform() from selenium.webdriver import ActionChains 导入提供鼠标操作的 ActionChains 类。 ActionChains(driver) 调用 ActionChains()类， 将浏览器驱动 driver 作为参数传入。 move_to_element(above) context_click()方法用于模拟鼠标右键操作， 在调用时需要指定元素定位。 perform() 执行所有 ActionChains 中存储的行为， 可以理解成是对整个操作的提交动作。 七、键盘事件 Keys()类提供了键盘上几乎所有按键的方法。 前面了解到， send_keys()方法可以用来模拟键盘输入， 除此 之外， 我们还可以用它来输入键盘上的按键， 甚至是组合键， 如 Ctrl+A、 Ctrl+C 等。 from selenium import webdriver # 引入 Keys 模块 from selenium.webdriver.common.keys import Keys driver = webdriver.Chrome() driver.get(&quot;http://www.baidu.com&quot;) # 输入框输入内容 driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;seleniumm&quot;) # 删除多输入的一个 m driver.find_element_by_id(&quot;kw&quot;).send_keys(Keys.BACK_SPACE) # 输入空格键+“教程” driver.find_element_by_id(&quot;kw&quot;).send_keys(Keys.SPACE) driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;教程&quot;) # ctrl+a 全选输入框内容 driver.find_element_by_id(&quot;kw&quot;).send_keys(Keys.CONTROL, 'a') # ctrl+x 剪切输入框内容 driver.find_element_by_id(&quot;kw&quot;).send_keys(Keys.CONTROL, 'x') # ctrl+v 粘贴内容到输入框 driver.find_element_by_id(&quot;kw&quot;).send_keys(Keys.CONTROL, 'v') # 通过回车键来代替单击操作 driver.find_element_by_id(&quot;su&quot;).send_keys(Keys.ENTER) driver.quit() 需要说明的是， 上面的脚本没有什么实际意义， 仅向我们展示模拟键盘各种按键与组合键的用法。 from selenium.webdriver.common.keys import Keys 在使用键盘按键方法前需要先导入 keys 类。 以下为常用的键盘操作： send_keys(Keys.BACK_SPACE) 删除键（BackSpace） send_keys(Keys.SPACE) 空格键(Space) send_keys(Keys.TAB) 制表键(Tab) send_keys(Keys.ESCAPE) 回退键（Esc） send_keys(Keys.ENTER) 回车键（Enter） send_keys(Keys.CONTROL,'a') 全选（Ctrl+A） send_keys(Keys.CONTROL,'c') 复制（Ctrl+C） send_keys(Keys.CONTROL,'x') 剪切（Ctrl+X） send_keys(Keys.CONTROL,'v') 粘贴（Ctrl+V） send_keys(Keys.F1) 键盘 F1 send_keys(Keys.F12) 键盘 F12 八、获取断言信息 不管是在做功能测试还是自动化测试，最后一步需要拿实际结果与预期进行比较。这个比较的称之为断言。 我们通常可以通过获取title 、URL和text等信息进行断言。text方法在前面已经讲过，它用于获取标签对之间的文本信息。 下面同样以百度为例，介绍如何获取这些信息。 from selenium import webdriver from time import sleep driver = webdriver.Firefox() driver.get(&quot;https://www.baidu.com&quot;) print('Before search================') # 打印当前页面title title = driver.title print(title) # 打印当前页面URL now_url = driver.current_url print(now_url) driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;selenium&quot;) driver.find_element_by_id(&quot;su&quot;).click() sleep(1) print('After search================') # 再次打印当前页面title title = driver.title print(title) # 打印当前页面URL now_url = driver.current_url print(now_url) # 获取结果数目 user = driver.find_element_by_class_name('nums').text print(user) driver.quit() 脚本运行结果如下： Before search================ 百度一下，你就知道 https://www.baidu.com/ After search================ selenium_百度搜索 https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=0&amp;rsv_idx... 搜索工具 百度为您找到相关结果约5,380,000个 title：用于获得当前页面的标题。 current_url：用户获得当前页面的URL。 text：获取搜索条目的文本信息。 九、设置元素等待 WebDriver提供了两种类型的等待：显式等待和隐式等待。 显式等待 显式等待使WebdDriver等待某个条件成立时继续执行，否则在达到最大时长时抛出超时异常（TimeoutException）。 from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC driver = webdriver.Firefox() driver.get(&quot;http://www.baidu.com&quot;) element = WebDriverWait(driver, 5, 0.5).until( EC.presence_of_element_located((By.ID, &quot;kw&quot;)) ) element.send_keys('selenium') driver.quit() WebDriverWait类是由WebDirver 提供的等待方法。在设置时间内，默认每隔一段时间检测一次当前页面元素是否存在，如果超过设置时间检测不到则抛出异常。具体格式如下： WebDriverWait(driver, timeout, poll_frequency=0.5, ignored_exceptions=None) driver ：浏览器驱动。 timeout ：最长超时时间，默认以秒为单位。 poll_frequency ：检测的间隔（步长）时间，默认为0.5S。 ignored_exceptions ：超时后的异常信息，默认情况下抛NoSuchElementException异常。 WebDriverWait()一般由until()或until_not()方法配合使用，下面是until()和until_not()方法的说明。 until(method, message='') 调用该方法提供的驱动程序作为一个参数，直到返回值为True。 until_not(method, message='') 调用该方法提供的驱动程序作为一个参数，直到返回值为False。 在本例中，通过as关键字将expected_conditions 重命名为EC，并调用presence_of_element_located()方法判断元素是否存在。 隐式等待 WebDriver提供了implicitly_wait()方法来实现隐式等待，默认设置为0。它的用法相对来说要简单得多。 from selenium import webdriver from selenium.common.exceptions import NoSuchElementException from time import ctime driver = webdriver.Firefox() # 设置隐式等待为10秒 driver.implicitly_wait(10) driver.get(&quot;http://www.baidu.com&quot;) try: print(ctime()) driver.find_element_by_id(&quot;kw22&quot;).send_keys('selenium') except NoSuchElementException as e: print(e) finally: print(ctime()) driver.quit() implicitly_wait() 默认参数的单位为秒，本例中设置等待时长为10秒。首先这10秒并非一个固定的等待时间，它并不影响脚本的执行速度。其次，它并不针对页面上的某一元素进行等待。当脚本执行到某个元素定位时，如果元素可以定位，则继续执行；如果元素定位不到，则它将以轮询的方式不断地判断元素是否被定位到。假设在第6秒定位到了元素则继续执行，若直到超出设置时长（10秒）还没有定位到元素，则抛出异常。 十、定位一组元素 WebDriver还提供了8种用于定位一组元素的方法。 find_elements_by_id() find_elements_by_name() find_elements_by_class_name() find_elements_by_tag_name() find_elements_by_link_text() find_elements_by_partial_link_text() find_elements_by_xpath() find_elements_by_css_selector() 定位一组元素的方法与定位单个元素的方法类似，唯一的区别是在单词element后面多了一个s表示复数。 接下来通过例子演示定位一组元素的使用： from selenium import webdriver from time import sleep driver = webdriver.Chrome() driver.get(&quot;https://www.baidu.com&quot;) driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;selenium&quot;) driver.find_element_by_id(&quot;su&quot;).click() sleep(1) # 定位一组元素 texts = driver.find_elements_by_xpath('//div/h3/a') # 循环遍历出每一条搜索结果的标题 for t in texts: print(t.text) driver.quit() 十一、多表单切换 在Web应用中经常会遇到frame/iframe表单嵌套页面的应用，WebDriver只能在一个页面上对元素识别与定位，对于frame/iframe表单内嵌页面上的元素无法直接定位。这时就需要通过switch_to.frame()方法将当前定位的主体切换为frame/iframe表单的内嵌页面中。 &lt;html&gt; &lt;body&gt; ... &lt;iframe id=&quot;x-URS-iframe&quot; ...&gt; &lt;html&gt; &lt;body&gt; ... &lt;input name=&quot;email&quot; &gt; 126邮箱登录框的结构大概是这样子的，想要操作登录框必须要先切换到iframe表单。 from selenium import webdriver driver = webdriver.Chrome() driver.get(&quot;http://www.126.com&quot;) driver.switch_to.frame('x-URS-iframe') driver.find_element_by_name(&quot;email&quot;).clear() driver.find_element_by_name(&quot;email&quot;).send_keys(&quot;username&quot;) driver.find_element_by_name(&quot;password&quot;).clear() driver.find_element_by_name(&quot;password&quot;).send_keys(&quot;password&quot;) driver.find_element_by_id(&quot;dologin&quot;).click() driver.switch_to.default_content() driver.quit() switch_to.frame() 默认可以直接取表单的id 或name属性。如果iframe没有可用的id和name属性，则可以通过下面的方式进行定位。 …… #先通过xpth定位到iframe xf = driver.find_element_by_xpath('//*[@id=&quot;x-URS-iframe&quot;]') #再将定位对象传给switch_to.frame()方法 driver.switch_to.frame(xf) …… driver.switch_to.parent_frame() 除此之外，在进入多级表单的情况下，还可以通过switch_to.default_content()跳回最外层的页面。 十二、多窗口切换 在页面操作过程中有时候点击某个链接会弹出新的窗口，这时就需要主机切换到新打开的窗口上进行操作。WebDriver提供了switch_to.window()方法，可以实现在不同的窗口之间切换。 以百度首页和百度注册页为例，在两个窗口之间的切换如下图。 from selenium import webdriver import time driver = webdriver.Firefox() driver.implicitly_wait(10) driver.get(&quot;http://www.baidu.com&quot;) # 获得百度搜索窗口句柄 sreach_windows = driver.current_window_handle driver.find_element_by_link_text('登录').click() driver.find_element_by_link_text(&quot;立即注册&quot;).click() # 获得当前所有打开的窗口的句柄 all_handles = driver.window_handles # 进入注册窗口 for handle in all_handles: if handle != sreach_windows: driver.switch_to.window(handle) print('now register window!') driver.find_element_by_name(&quot;account&quot;).send_keys('username') driver.find_element_by_name('password').send_keys('password') time.sleep(2) driver.quit() 在本例中所涉及的新方法如下： current_window_handle：获得当前窗口句柄。 window_handles：返回所有窗口的句柄到当前会话。 switch_to.window()：用于切换到相应的窗口，与上一节的switch_to.frame()类似，前者用于不同窗口的切换，后者用于不同表单之间的切换。 十三、警告框处理 在WebDriver中处理JavaScript所生成的alert、confirm以及prompt十分简单，具体做法是使用 switch_to.alert 方法定位到 alert/confirm/prompt，然后使用text/accept/dismiss/ send_keys等方法进行操作。 text：返回 alert/confirm/prompt 中的文字信息。 accept()：接受现有警告框。 dismiss()：解散现有警告框。 send_keys(keysToSend)：发送文本至警告框。keysToSend：将文本发送至警告框。 如下图，百度搜索设置弹出的窗口是不能通过前端工具对其进行定位的，这个时候就可以通过switch_to_alert()方法接受这个弹窗。 from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains import time driver = webdriver.Firefox() driver.implicitly_wait(10) driver.get('http://www.baidu.com') # 鼠标悬停至“设置”链接 link = driver.find_element_by_link_text('设置') ActionChains(driver).move_to_element(link).perform() # 打开搜索设置 driver.find_element_by_link_text(&quot;搜索设置&quot;).click() # 保存设置 driver.find_element_by_class_name(&quot;prefpanelgo&quot;).click() time.sleep(2) # 接受警告框 driver.switch_to.alert.accept() driver.quit() 通过switch_to_alert()方法获取当前页面上的警告框，并使用accept()方法接受警告框。 十四、下拉框选择 有时我们会碰到下拉框，WebDriver提供了Select类来处理下拉框。 如百度搜索设置的下拉框 from selenium import webdriver from selenium.webdriver.support.select import Select from time import sleep driver = webdriver.Chrome() driver.implicitly_wait(10) driver.get('http://www.baidu.com') # 鼠标悬停至“设置”链接 driver.find_element_by_link_text('设置').click() sleep(1) # 打开搜索设置 driver.find_element_by_link_text(&quot;搜索设置&quot;).click() sleep(2) # 搜索结果显示条数 sel = driver.find_element_by_xpath(&quot;//select[@id='nr']&quot;) Select(sel).select_by_value('50') # 显示50条 driver.quit() Select类用于定位select标签。 select_by_value() 方法用于定位下接选项中的value值。 十五、文件上传 对于通过input标签实现的上传功能，可以将其看作是一个输入框，即通过send_keys()指定本地文件路径的方式实现文件上传。 创建upfile.html文件，代码如下： &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot; /&gt; &lt;title&gt;upload_file&lt;/title&gt; &lt;link href=&quot;http://cdn.bootcss.com/bootstrap/3.3.0/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;row-fluid&quot;&gt; &lt;div class=&quot;span6 well&quot;&gt; &lt;h3&gt;upload_file&lt;/h3&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=&quot;http://cdn.bootcss.com/bootstrap/3.3.0/css/bootstrap.min.js&quot;&gt;&lt;/scrip&gt; &lt;/html&gt; 通过浏览器打开upfile.html文件，接下来通过send_keys()方法来实现文件上传。 from selenium import webdriver import os driver = webdriver.Firefox() file_path = 'file:///' + os.path.abspath('upfile.html') driver.get(file_path) # 定位上传按钮，添加本地文件 driver.find_element_by_name(&quot;file&quot;).send_keys('D:\\\\upload_file.txt') driver.quit() 十六、cookie操作 有时候我们需要验证浏览器中cookie是否正确，因为基于真实cookie的测试是无法通过白盒和集成测试进行的。 WebDriver提供了操作Cookie的相关方法，可以读取、添加和删除cookie信息。 WebDriver操作cookie的方法： get_cookies()： 获得所有cookie信息。 get_cookie(name)： 返回字典的key为“name”的cookie信息。 add_cookie(cookie_dict) ： 添加cookie。“cookie_dict”指字典对象，必须有name 和value 值。 delete_cookie(name,optionsString)：删除cookie信息。“name”是要删除的cookie的名称，“optionsString”是该cookie的选项，目前支持的选项包括“路径”，“域”。 delete_all_cookies()： 删除所有cookie信息。 下面通过get_cookies()来获取当前浏览器的cookie信息。 from selenium import webdriver driver = webdriver.Firefox() driver.get(&quot;http://www.youdao.com&quot;) # 获得cookie信息 cookie= driver.get_cookies() # 将获得cookie的信息打印 print(cookie) driver.quit() 从执行结果可以看出，cookie数据是以字典的形式进行存放的。知道了cookie的存放形式，接下来我们就可以按照这种形式向浏览器中写入cookie信息。 from selenium import webdriver driver = webdriver.Firefox() driver.get(&quot;http://www.youdao.com&quot;) # 向cookie的name 和value中添加会话信息 driver.add_cookie({'name': 'key-aaaaaaa', 'value': 'value-bbbbbb'}) # 遍历cookies中的name 和value信息并打印，当然还有上面添加的信息 for cookie in driver.get_cookies(): print(&quot;%s -&gt; %s&quot; % (cookie['name'], cookie['value'])) driver.quit() 输出结果： ======================== RESTART: ========================= YOUDAO_MOBILE_ACCESS_TYPE -&gt; 1 _PREF_ANONYUSER__MYTH -&gt; aGFzbG9nZ2VkPXRydWU= OUTFOX_SEARCH_USER_ID -&gt; -1046383847@218.17.158.115 JSESSIONID -&gt; abc7qSE_SBGsVgnVLBvcu key-aaaaaaa -&gt; value-bbbbbb 从执行结果可以看到，最后一条cookie信息是在脚本执行过程中通过add_cookie()方法添加的。通过遍历得到所有的cookie信息，从而找到key为“name”和“value”的特定cookie的value。 十七、调用JS代码 虽然WebDriver提供了操作浏览器的前进和后退方法，但对于浏览器滚动条并没有提供相应的操作方法。在这种情况下，就可以借助JavaScript来控制浏览器的滚动条。WebDriver提供了execute_script()方法来执行JavaScript代码。 用于调整浏览器滚动条位置的JavaScript代码如下： &lt;!-- window.scrollTo(左边距,上边距); --&gt; window.scrollTo(0,450); window.scrollTo()方法用于设置浏览器窗口滚动条的水平和垂直位置。方法的第一个参数表示水平的左间距，第二个参数表示垂直的上边距。其代码如下： from selenium import webdriver from time import sleep # 访问百度 driver=webdriver.Firefox() driver.get(&quot;http://www.baidu.com&quot;) # 设置浏览器窗口大小 driver.set_window_size(500, 500) # 搜索 driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;selenium&quot;) driver.find_element_by_id(&quot;su&quot;).click() sleep(2) # 通过javascript设置浏览器窗口的滚动条位置 js=&quot;window.scrollTo(100,450);&quot; driver.execute_script(js) sleep(3) driver.quit() 通过浏览器打开百度进行搜索，并且提前通过set_window_size()方法将浏览器窗口设置为固定宽高显示，目的是让窗口出现水平和垂直滚动条。然后通过execute_script()方法执行JavaScripts代码来移动滚动条的位置。 十八、窗口截图 自动化用例是由程序去执行的，因此有时候打印的错误信息并不十分明确。如果在脚本执行出错的时候能对当前窗口截图保存，那么通过图片就可以非常直观地看出出错的原因。WebDriver提供了截图函数get_screenshot_as_file()来截取当前窗口。 from selenium import webdriver from time import sleep driver = webdriver.Firefox() driver.get('http://www.baidu.com') driver.find_element_by_id('kw').send_keys('selenium') driver.find_element_by_id('su').click() sleep(2) # 截取当前窗口，并指定截图图片的保存位置 driver.get_screenshot_as_file(&quot;D:\\\\baidu_img.jpg&quot;) driver.quit() 脚本运行完成后打开D盘，就可以找到baidu_img.jpg图片文件了。 十九、关闭浏览器 在前面的例子中我们一直使用quit()方法，其含义为退出相关的驱动程序和关闭所有窗口。除此之外，WebDriver还提供了close()方法，用来关闭当前窗口。例多窗口的处理，在用例执行的过程中打开了多个窗口，我们想要关闭其中的某个窗口，这时就要用到close()方法进行关闭了。 close() 关闭单个窗口 quit() 关闭所有窗口 二十、Selenium踩坑指北 众所周知，我们应该把合适的工具用在合适的场景，这跟杀鸡的时候不需要用到宰牛刀是一样的道理。 selenium比较好的使用场景是验收测试/回归测试/TDD/BDD，一些同学喜欢把selenium用到某些selenium难以承受的场景，这种方式官方是不推荐的。下面这些是官方给出的各种神坑。 验证码 一般来说我们不需要用selenium去处理各种验证码，有兴趣的同学可以逆向思维，亲自试试。 那么遇到验证码怎么办？ 测试环境就关掉验证码 留个后门，比如万能验证码 下载文件 尽管我们可以使用selenium去点击下载按钮，从而达到下载文件的目的，但是这样做其实并不好。首先处理起来可能比较麻烦，另外关于下载时间下载速度以及下载完整性的验证我们是不太好做的。 HTTP 请求的响应码 这一part官方苦口婆心的解释了很多，大意是selenium是站在用户角度去自动化测试，对于终端用户来说，他们并不直接关注请求的返回码，他们关注的是能不能看到404的错误页面之类的可以直接感受到信息。 下面是非官方的建议 如果你真的关注响应的状态码，那么别在UI自动化层去做，试着去在非UI层，比如接口层做 放弃在UI自动化用例中断言状态码的努力，有舍才有得嘛 第三方登陆 使用selenium去自动化第三方登陆原则上是不推荐的。因为 增加了用例的复杂度和运行时间，用例容易跑失败 第三方登录是不稳定的，这会让你的登录变得不稳定 在国外一般第三方登录的提供方会提供对应的API，我们可以把登录API集成到用例里，这些API相当稳定，比用selenium去自动化登录过程要好。 国内可以通过类似的思路去做，比如微信登录就有自己的API，这种实现比较硬核，并且跟ui自动化结合起来也有一定难度，有需求的同学可以尝试一下。 用例依赖 selenium team说了，用例直接不要有依赖，要可以用任意顺序运行 性能测试 简而言之，selenium不适合做性能测试，原因我就不详细说了，总之不合适的话咱就不要强求，有情人总会终成眷属。 如果需要做性能测试，可以看看jmeter，官方推荐，值得信赖。 链接爬虫 用selenium去遍历一些链接从而达到爬虫的效果官方是不推荐的，理由是慢，有很多更好的替代方案。 ","link":"https://preszang.github.io/post/XfbZQSvJ5/"},{"title":"pytest接口测试基本教程","content":"1.快速开始 pytest测试框架可以让我们很方便的编写测试用例，这些用例写起来虽然简单，但仍然可以规模化以及编写更加复杂的测试用例。官方文档 安装 pip install -U pytest 用下面的命令去检查一下pytest是否成功安装 $ pytest --version This is pytest version 3.x.y, imported from $PYTHON_PREFIX/lib/python3.5/site-packages/pytest.py 快速开始 创建名为test_quick_start.py的文件，敲如下内容 def reverse(string): return string[::-1] def test_reverse(): string = &quot;good&quot; assert reverse(string) == &quot;doog&quot; another_string = &quot;itest&quot; assert reverse(another_string) == &quot;tseti&quot; 上面的代码做了2件事情 定义了名为reverse(string)的全局函数，作用是把string反转并返回。比如输入&quot;abc&quot;会反转成&quot;cba&quot; 定义了名为test_reverse()的函数，包含了2个断言，用来测试reverse()方法的正确性 在命令行中使用下面的命令去运行用例 pytest 结果应该大致如下 ========================================================================= test session starts ========================================================================= platform darwin -- Python 2.7.12, pytest-3.2.3, py-1.4.34, pluggy-0.4.0 rootdir: /Users/easonhan/code/testclass.net/src/pytest, inifile: collected 1 item test_quick_start.py . ====================================================================== 1 passed in 0.01 seconds ======================================================================= 总结 这是最简单的单元测试实例，实现了用代码去测试代码的目的。 2.运行多个文件 在现实的测试活动中，我们经常会定义多个用例文件，用来实现业务逻辑或其他逻辑上用例的物理分隔，比如 login_test.py # 登录相关功能的测试用例 cart_test.py # 购物车相关功能的测试用例 checkout_test.py # 结算相关功能的用例 order_test.py # 订单相关功能的用例 使用pytest可以很方便的执行批量执行一组文件中定义的用例。 潜规则 在批量执行用例之前，我们需要了解一下pytest的潜规则，注意，由于pytest可以支持丰富的定制选项，下面的潜规则是在没有定制的默认情况下的缺省规则 pytest会找当前以及递查找子文件夹下面所有的test_*.py或*_test.py的文件，把其当作测试文件 在这些文件里，pytest会收集下面的一些函数或方法，当作测试用例 不在类定义中的以test_开头的函数或方法 在以Test开头的类中(不能包含__init__方法)，以test_开头的方法 pytest也支持unittest模式的用例定义 实例 新建test_calc.py文件，与上一节的test_quick_start.py放在同一文件夹下，敲入下面的内容 def add(x, y): return x + y def test_add(): assert add(1, 0) == 1 assert add(1, 1) == 2 assert add(1, 99) == 100 现在当前文件夹下应该有2个文件 test_calc.py test_quick_start.py 运行 在当前文件夹敲下面的命令 pytest 结果大致应该如下所示 $ pytest ========================================================================= test session starts ========================================================================= platform darwin -- Python 2.7.12, pytest-3.2.3, py-1.4.34, pluggy-0.4.0 rootdir: /Users/easonhan/code/testclass.net/src/pytest, inifile: collected 2 items test_calc.py . test_quick_start.py . ====================================================================== 2 passed in 0.01 seconds ======================================================================= 总结 上面的例子里 所有以test_开头的py文件都被当成了测试文件 所有测试文件中以test开头的方法被当成了测试用例执行 3.Assert Assert就是断言，每个测试用例都需要断言。 与unittest不同，pytest使用的是python自带的assert关键字来进行断言，大大降低了学习成本。 assert关键字后面可以接一个表达式，只要表达式的最终结果为True，那么断言通过，用例执行成功，否则用例执行失败。 详尽的用例失败描述 pytest的用例失败描述非常详尽，一目了人。考虑下面的例子 # content of test_assert1.py def f(): return 3 def test_function(): assert f() == 4 执行上面的用例 $ pytest test_assert1.py ======= test session starts ======== platform linux -- Python 3.x.y, pytest-3.x.y, py-1.x.y, pluggy-0.x.y rootdir: $REGENDOC_TMPDIR, inifile: collected 1 item test_assert1.py F ======= FAILURES ======== _______ test_function ________ def test_function(): &gt; assert f() == 4 E assert 3 == 4 E + where 3 = f() test_assert1.py:5: AssertionError ======= 1 failed in 0.12 seconds ======== 可以很明显的看出，pytest给出的错误提示是：f()的值是3，也就是实际结果是3，而预期结果是4，3不等于4，因此断言未通过，用例失败。 断言异常抛出 pytest有自己的异常抛出断言套路，下面是最简单的形式 import pytest def test_zero_division(): with pytest.raises(ZeroDivisionError): 1 / 0 上面代码的意思是: 1/0的时候应该抛出ZeroDivisionError，否则用例失败，断言不通过。 另外pytest还允许我们访问异常的具体信息，如下面的例子 def test_recursion_depth(): with pytest.raises(RuntimeError) as excinfo: def f(): f() f() assert 'maximum recursion' in str(excinfo.value) 我们还可以定制断言异常的错误信息，比如 &gt;&gt;&gt; with raises(ZeroDivisionError, message=&quot;Expecting ZeroDivisionError&quot;): ... pass ... Failed: Expecting ZeroDivisionError 总结 更多断言异常以及定制assert中比较方式的例子，请参阅官方文档 4.Fixture 我们可以简单的把Fixture理解为准备测试数据和初始化测试对象的阶段。 一般我们对测试数据和测试对象的管理有这样的一些场景 所有用例开始之前初始化测试数据或对象 所有用例结束之后销毁测试数据或对象 每个用例开始之前初始化测试数据或对象 每个用例结束之后销毁测试数据或对象 在每个／所有module的用例开始之前初始化数据或对象 在每个／所有module的用例开始之后销毁数据或对象 ...... ...... pytest的fixture特性可以满足上面的需求。 简单的例子 考虑这种场景，我们需要判断用户的密码中包含简单密码，规则是这样的，密码必须至少6位，满足6位的话判断用户的密码不是password123或者password之类的弱密码。 我们将用户的信息导出成名为users.dev.json的文件，该文件如下所示 [ {&quot;name&quot;:&quot;jack&quot;,&quot;password&quot;:&quot;Iloverose&quot;}, {&quot;name&quot;:&quot;rose&quot;,&quot;password&quot;:&quot;Ilovejack&quot;}, {&quot;name&quot;:&quot;tom&quot;,&quot;password&quot;:&quot;password123&quot;} ] 新建名为test_user_password.py的文件，键入以下内容，一定要保证users.dev.json文件与该文件在同一路径下 import pytest import json class TestUserPassword(object): @pytest.fixture def users(self): return json.loads(open('./users.dev.json', 'r').read()) # 读取当前路径下的users.dev.json文件，返回的结果是dict def test_user_password(self, users): # 遍历每条user数据 for user in users: passwd = user['password'] assert len(passwd) &gt;= 6 msg = &quot;user %s has a weak password&quot; %(user['name']) assert passwd != 'password', msg assert passwd != 'password123', msg 运行 pytest可以通过指定文件名的方式运行单个用例文件，这里我们只运行test_user_password.py文件 pytest test_user_password.py 运行结果 $ pytest test_user_password.py ========================================================================= test session starts ========================================================================= platform darwin -- Python 2.7.12, pytest-3.2.3, py-1.4.34, pluggy-0.4.0 rootdir: /Users/easonhan/code/testclass.net/src/pytest, inifile: collected 1 item test_user_password.py F ============================================================================== FAILURES =============================================================================== _________________________________________________________________ TestUserPassword.test_user_password _________________________________________________________________ self = &lt;test_user_password.TestUserPassword object at 0x1046e3290&gt; users = [{'name': 'jack', 'password': 'Iloverose'}, {'name': 'rose', 'password': 'Ilovejack'}, {'name': 'tom', 'password': 'password123'}] def test_user_password(self, users): for user in users: passwd = user['password'] assert len(passwd) &gt;= 6 msg = &quot;user %s has a weak password&quot; %(user['name']) assert passwd != 'password', msg &gt; assert passwd != 'password123', msg E AssertionError: user tom has a weak password E assert 'password123' != 'password123' test_user_password.py:14: AssertionError ====================================================================== 1 failed in 0.03 seconds ======================================================================= 分析 使用@pytest.fixture装饰器可以定义feature 在用例的参数中传递fixture的名称以便直接调用fixture，拿到fixture的返回值 3个assert是递进关系，前1个assert断言失败后，后面的assert是不会运行的，因此重要的assert放到前面 E AssertionError: user tom has a weak password可以很容易的判断出是哪条数据出了问题，所以定制可读性好的错误信息是很必要的 任何1个断言失败以后，for循环就会退出，所以上面的用例1次只能发现1条错误数据，换句话说任何1个assert失败后，用例就终止运行了 执行顺序 pytest是这样运行上面的用例的 pytest找到以test_开头的方法，也就是test_user_password方法，执行该方法时发现传入的参数里有跟fixture users名称相同的参数 pytest认定users是fixture，执行该fixture，读取json文件解析成dict实例 test_user_password方法真正被执行，users fixture被传入到该方法 注意 我们可以使用下面的命令来查看用例中可用的fixtures pytest --fixtures test_user_password.py 数据清理 有时候我们需要在用例结束的时候去清理一些测试数据，或清除测试过程中创建的对象，我们可以使用下面的方式 import smtplib import pytest @pytest.fixture(scope=&quot;module&quot;) def smtp(): smtp = smtplib.SMTP(&quot;smtp.gmail.com&quot;, 587, timeout=5) yield smtp # provide the fixture value print(&quot;teardown smtp&quot;) smtp.close() yield 关键字返回了fixture中实例化的对象smtp module中的用例执行完成后smtp.close()方法会执行，无论用例的运行状态是怎么样的,都会执行 更多的数据清理方式 addfinalizer 也可以完成数据清理的工作，具体见这里 5.参数化的Fixture 继续上一节的测试需求，在上一节里，任何1条测试数据导致断言不通过后测试用例就会停止运行，这样每次只能检查出1条不符合规范的数据，有没有什么办法可以一次性把所有的不符合结果都测出来呢？ 这时候我们就需要用到参数化的fixture特性了 更新数据文件 新建users.test.json文件，内容如下 [ {&quot;name&quot;:&quot;jack&quot;,&quot;password&quot;:&quot;Iloverose&quot;}, {&quot;name&quot;:&quot;rose&quot;,&quot;password&quot;:&quot;Ilovejack&quot;} {&quot;name&quot;:&quot;tom&quot;,&quot;password&quot;:&quot;password123&quot;}, {&quot;name&quot;:&quot;mike&quot;,&quot;password&quot;:&quot;password&quot;}, {&quot;name&quot;:&quot;james&quot;,&quot;password&quot;:&quot;AGoodPasswordWordShouldBeLongEnough&quot;} ] 我们增加了2条用户信息，其中mike的密码是弱密码。 参数化fixture 参数化fixture允许我们向fixture提供参数，参数可以是list，该list中有几条数据，fixture就会运行几次，相应的测试用例也会运行几次。 参数化fixture的语法是 @pytest.fixture(params=[&quot;smtp.gmail.com&quot;, &quot;mail.python.org&quot;]) 其中len(params)的值就是用例执行的次数 在fixture的定义中，可以使用request.param来获取每次传入的参数，如下: @pytest.fixture(scope=&quot;module&quot;, params=[&quot;smtp.gmail.com&quot;, &quot;mail.python.org&quot;]) def smtp(request): smtp = smtplib.SMTP(request.param, 587, timeout=5) yield smtp print (&quot;finalizing %s&quot; % smtp) smtp.close() 上面的代码smtp fixture会执行2次 第1次request.param == 'smtp.gmail.com' 第2次request.param == 'mail.python.org' 实现用例 我们现在使用参数化fixtures来实现一次性检查出弱密码的用例。 新建文件test_user_password_with_params.py，内容如下: import pytest import json users = json.loads(open('./users.test.json', 'r').read()) class TestUserPasswordWithParam(object): @pytest.fixture(params=users) def user(self, request): return request.param def test_user_password(self, user): passwd = user['password'] assert len(passwd) &gt;= 6 msg = &quot;user %s has a weak password&quot; %(user['name']) assert passwd != 'password', msg assert passwd != 'password123', msg 上面的例子里，我们先把所有用户信息读到users变量里，注意users这时候是list类型，可以直接传入到fixture的params 运行及结果 运行 pytest test_user_password_with_params.py 结果 $ pytest test_user_password_with_params.py ========================================================================= test session starts ========================================================================= platform darwin -- Python 2.7.12, pytest-3.2.3, py-1.4.34, pluggy-0.4.0 rootdir: /Users/easonhan/code/testclass.net/src/pytest, inifile: collected 5 items test_user_password_with_params.py ..FF. ============================================================================== FAILURES =============================================================================== _________________________________________________________ TestUserPasswordWithParam.test_user_password[user2] _________________________________________________________ self = &lt;test_user_password_with_params.TestUserPasswordWithParam object at 0x10de1d790&gt;, user = {'name': 'tom', 'password': 'password123'} def test_user_password(self, user): passwd = user['password'] assert len(passwd) &gt;= 6 msg = &quot;user %s has a weak password&quot; %(user['name']) assert passwd != 'password', msg &gt; assert passwd != 'password123', msg E AssertionError: user tom has a weak password E assert 'password123' != 'password123' test_user_password_with_params.py:15: AssertionError _________________________________________________________ TestUserPasswordWithParam.test_user_password[user3] _________________________________________________________ self = &lt;test_user_password_with_params.TestUserPasswordWithParam object at 0x10de1df50&gt;, user = {'name': 'mike', 'password': 'password'} def test_user_password(self, user): passwd = user['password'] assert len(passwd) &gt;= 6 msg = &quot;user %s has a weak password&quot; %(user['name']) &gt; assert passwd != 'password', msg E AssertionError: user mike has a weak password E assert 'password' != 'password' test_user_password_with_params.py:14: AssertionError ================================================================= 2 failed, 3 passed in 0.05 seconds ================================================================== 稍微留意一下, 可以看出tom和mike使用了弱密码。总共运行了5个用例,3个成功,2个失败。 fixture的更多特性 fixture还有很多更加灵活和深入的用法，具体见这里 6.Parametrize Fixture @pytest.mark.parametrize 装饰器可以让我们每次参数化fixture的时候传入多个项目。回忆上一节，我们参数化的时候只能传入传入1个字符串或者是其他的数据对象，parametrize每次多个参数，更加灵活。 例子 import pytest @pytest.mark.parametrize(&quot;test_input,expected&quot;, [ (&quot;3+5&quot;, 8), (&quot;2+4&quot;, 6), (&quot;6*9&quot;, 42), ]) def test_eval(test_input, expected): assert eval(test_input) == expected test_eval方法中传入了2个参数，就如同@pytest.mark.parametrize装饰器中定义的那样，因此简单理解，我们可以把parametrize装饰器想象成是数据表格，有表头(test_input,expected)以及具体的数据。 运行结果 $ pytest ======= test session starts ======== platform linux -- Python 3.x.y, pytest-3.x.y, py-1.x.y, pluggy-0.x.y rootdir: $REGENDOC_TMPDIR, inifile: collected 3 items test_expectation.py ..F ======= FAILURES ======== _______ test_eval[6*9-42] ________ test_input = '6*9', expected = 42 @pytest.mark.parametrize(&quot;test_input,expected&quot;, [ (&quot;3+5&quot;, 8), (&quot;2+4&quot;, 6), (&quot;6*9&quot;, 42), ]) def test_eval(test_input, expected): &gt; assert eval(test_input) == expected E AssertionError: assert 54 == 42 E + where 54 = eval('6*9') test_expectation.py:8: AssertionError ======= 1 failed, 2 passed in 0.12 seconds ======== 7.常见套路 在使用pytest的时候，下面这些问题我们可能会经常遇到，这里给出官方的解决方案，按照套路来执行就可以了。 基础用法 把命令行参数传入到用例 动态添加命令行参数 根据命令行参数来忽略用例执行 编写集成度更好的辅助断言 判断是否由pytest执行 在测试报告的头部添加内容 统计用例运行时间 定义测试步骤，也就是让用例按照一定的顺序执行 Package/Directory-level fixtures (setups) 在报告和用例失败之前添加钩子 在fixtures中访问测试结果 PYTEST_CURRENT_TEST环境变量 冻结pytest 参数化 根据命令行参数来组合测试参数 配置test ID 快速创建测试场景的功能 延迟参数资源加载 间接参数 为不同的方法设置不同的参数 在多个fixture中使用间接参数 Indirect parametrization of optional implementations/imports 单独的为每个参数化用例设置标记和ID 8.使用pytest做简单的接口测试 我们现在需要测试v2ex网站的查看论坛节点信息的api。具体如下: 节点信息：获得指定节点的名字，简介，URL 及头像图片的地址。 https://www.v2ex.com/api/nodes/show.json Method: GET Authentication: None 接受参数： name: 节点名（V2EX 的节点名全是半角英文或者数字） 例如：https://www.v2ex.com/api/nodes/show.json?name=python 接口返回 { &quot;id&quot; : 90, &quot;name&quot; : &quot;python&quot;, &quot;url&quot; : &quot;http://www.v2ex.com/go/python&quot;, &quot;title&quot; : &quot;Python&quot;, &quot;title_alternative&quot; : &quot;Python&quot;, &quot;topics&quot; : 7963, &quot;stars&quot; : 5138, &quot;header&quot; : &quot;这里讨论各种 Python 语言编程话题，也包括 Django，Tornado 等框架的讨论。这里是一个能够帮助你解决实际问题的地方。&quot;, &quot;footer&quot; : null, &quot;created&quot; : 1278683336, &quot;avatar_mini&quot; : &quot;//v2ex.assets.uxengine.net/navatar/8613/985e/90_mini.png?m=1509941286&quot;, &quot;avatar_normal&quot; : &quot;//v2ex.assets.uxengine.net/navatar/8613/985e/90_normal.png?m=1509941286&quot;, &quot;avatar_large&quot; : &quot;//v2ex.assets.uxengine.net/navatar/8613/985e/90_large.png?m=1509941286&quot; } 需求分析 该接口是获取数据的接口，一般来说，这种接口我们的测试重点是验证数据的准确性。 根据3A原则，我们可以设计如下的用例 测试数据: 节点的名称:python 接口地址: https://www.v2ex.com/api/nodes/show.json 断言: 返回的结果里，id必须是90,name必须等于python，大家想一想为什么？ 代码 新建名为v2ex_api_test.py的文件，键入如下内容 import requests class TestV2exApi(object): domain = 'https://www.v2ex.com/' def test_node(self): path = 'api/nodes/show.json?name=python' url = self.domain + pathpython res = requests.get(url).json() assert res['id'] == 90 assert res['name'] == 'python' 需要注意的点 使用requests库来简化发送get请求并将返回值的json字符串转换成python字典 使用domain变量来参数化测试的地址，因为不同环境的地址可能不一样，使用domain变量之后只需要改动这个变量就可以切换测试环境了 断言id为90是因为测试数据是静态的，id不会发生变化 运行 $ pytest v2ex_api_test.py ======================================================================== test session starts ======================================================================== platform darwin -- Python 2.7.12, pytest-3.2.3, py-1.4.34, pluggy-0.4.0 rootdir: /Users/easonhan/code/testclass.net/src/pytest, inifile: collected 1 item v2ex_api_test.py . ===================================================================== 1 passed in 1.39 seconds ====================================================================== 用例执行成功，我们实现了最简单的接口测试场景。 9.使用fixture参数化接口入参 接上一节v2ex网站的查看论坛节点信息的api。具体如下: 节点信息：获得指定节点的名字，简介，URL 及头像图片的地址。 https://www.v2ex.com/api/nodes/show.json Method: GET Authentication: None 接受参数： name: 节点名（V2EX 的节点名全是半角英文或者数字） 例如：https://www.v2ex.com/api/nodes/show.json?name=python 我们试一下，通过传入不同的name，我们可以获取不同的节点信息。上面例子里我们获取了python讨论区的信息。现在我们把name改成java，该接口会返回java讨论区节点的信息，如下所示https://www.v2ex.com/api/nodes/show.json?name=python { &quot;id&quot; : 63, &quot;name&quot; : &quot;java&quot;, &quot;url&quot; : &quot;http://www.v2ex.com/go/java&quot;, &quot;title&quot; : &quot;Java&quot;, &quot;title_alternative&quot; : &quot;Java&quot;, &quot;topics&quot; : 1219, &quot;stars&quot; : 1547, &quot;header&quot; : &quot;The most popular programming language.&quot;, &quot;footer&quot; : null, &quot;created&quot; : 1272669207, &quot;avatar_mini&quot; : &quot;//v2ex.assets.uxengine.net/navatar/03af/dbd6/63_mini.png?m=1509589840&quot;, &quot;avatar_normal&quot; : &quot;//v2ex.assets.uxengine.net/navatar/03af/dbd6/63_normal.png?m=1509589840&quot;, &quot;avatar_large&quot; : &quot;//v2ex.assets.uxengine.net/navatar/03af/dbd6/63_large.png?m=1509589840&quot; } 那么新的需求来了，现在我们要测试给定的几个节点名称(python/java/go/nodejs)，v2ex的节点api可以正确返回节点的名字 需求分析 根据3A原则，我们可以设计如下的用例 测试数据: 节点的名称:python/java/go/nodejs 接口地址: https://www.v2ex.com/api/nodes/show.json 断言: 返回的结果里，name字段的值必须等于传入的节点名称 代码 在v2ex_api_test.py的文件中添加如下内容 import requests import pytest class TestV2exApiWithParams(object): domain = 'https://www.v2ex.com/' @pytest.fixture(params=['python', 'java', 'go', 'nodejs']) def lang(self, request): return request.param def test_node(self, lang): path = 'api/nodes/show.json?name=%s' %(lang) url = self.domain + path res = requests.get(url).json() assert res['name'] == lang assert 0 需要注意的点 每次都可以用request.param来访问本次传入fixture中的参数 在测试方法中传入同名的fixture方法名可以直接访问fixture 使用assert(0)强制用例失败，这样可以看到每次fixture的参数值 运行 $ pytest v2ex_api_test.py ======================================================================== test session starts ======================================================================== platform darwin -- Python 2.7.12, pytest-3.2.3, py-1.4.34, pluggy-0.4.0 rootdir: /Users/easonhan/code/testclass.net/src/pytest, inifile: collected 5 items v2ex_api_test.py .FFFF ============================================================================= FAILURES ============================================================================== ______________________________________________________________ TestV2exApiWithParams.test_node[python] ______________________________________________________________ self = &lt;v2ex_api_test.TestV2exApiWithParams object at 0x105e0edd0&gt;, lang = 'python' def test_node(self, lang): path = 'api/nodes/show.json?name=%s' %(lang) url = self.domain + path res = requests.get(url).json() assert res['name'] == lang &gt; assert 0 E assert 0 v2ex_api_test.py:27: AssertionError _______________________________________________________________ TestV2exApiWithParams.test_node[java] _______________________________________________________________ self = &lt;v2ex_api_test.TestV2exApiWithParams object at 0x1075e2750&gt;, lang = 'java' def test_node(self, lang): path = 'api/nodes/show.json?name=%s' %(lang) url = self.domain + path res = requests.get(url).json() assert res['name'] == lang &gt; assert 0 E assert 0 v2ex_api_test.py:27: AssertionError ________________________________________________________________ TestV2exApiWithParams.test_node[go] ________________________________________________________________ self = &lt;v2ex_api_test.TestV2exApiWithParams object at 0x107636190&gt;, lang = 'go' def test_node(self, lang): path = 'api/nodes/show.json?name=%s' %(lang) url = self.domain + path res = requests.get(url).json() assert res['name'] == lang &gt; assert 0 E assert 0 v2ex_api_test.py:27: AssertionError ______________________________________________________________ TestV2exApiWithParams.test_node[nodejs] ______________________________________________________________ self = &lt;v2ex_api_test.TestV2exApiWithParams object at 0x1075e2790&gt;, lang = 'nodejs' def test_node(self, lang): path = 'api/nodes/show.json?name=%s' %(lang) url = self.domain + path res = requests.get(url).json() assert res['name'] == lang &gt; assert 0 E assert 0 v2ex_api_test.py:27: AssertionError ================================================================ 4 failed, 1 passed in 1.91 seconds ================================================================= 用例执行失败，但是每次运行时lang的值我们可以看的很明白。 10.使用fixture参数化测试预期结果 接上一节v2ex网站的查看论坛节点信息的api。 我们在上一节的测试用例里只断言了返回值的name字段必须与我们传入的入参相同，但是返回值的id却没有进行判定。这一节里我们加强一下测试脚本，实现判断id的功能。 测试数据 python, id=90 java, id=63 nodejs, id=436 go, id=375 代码实现 在v2ex_api_test.py的文件中加入如下内容: class TestV2exApiWithExpectation(object): domain = 'https://www.v2ex.com/' @pytest.mark.parametrize('name,node_id', [('python', 90), ('java', 63), ('go', 375), ('nodejs', 436)]) def test_node(self, name, node_id): path = 'api/nodes/show.json?name=%s' %(name) url = self.domain + path res = requests.get(url).json() assert res['name'] == name assert res['id'] == node_id assert 0 运行及结果 $ pytest v2ex_api_test.py ======================================================================== test session starts ======================================================================== platform darwin -- Python 2.7.12, pytest-3.2.3, py-1.4.34, pluggy-0.4.0 rootdir: /Users/easonhan/code/testclass.net/src/pytest, inifile: collected 9 items v2ex_api_test.py .FFFFFFFF ============================================================================= FAILURES ============================================================================== ______________________________________________________________ TestV2exApiWithParams.test_node[python] ______________________________________________________________ self = &lt;v2ex_api_test.TestV2exApiWithParams object at 0x10618eb10&gt;, lang = 'python' def test_node(self, lang): path = 'api/nodes/show.json?name=%s' %(lang) url = self.domain + path res = requests.get(url).json() assert res['name'] == lang &gt; assert 0 E assert 0 v2ex_api_test.py:27: AssertionError _______________________________________________________________ TestV2exApiWithParams.test_node[java] _______________________________________________________________ self = &lt;v2ex_api_test.TestV2exApiWithParams object at 0x106691790&gt;, lang = 'java' def test_node(self, lang): path = 'api/nodes/show.json?name=%s' %(lang) url = self.domain + path res = requests.get(url).json() assert res['name'] == lang &gt; assert 0 E assert 0 v2ex_api_test.py:27: AssertionError ________________________________________________________________ TestV2exApiWithParams.test_node[go] ________________________________________________________________ self = &lt;v2ex_api_test.TestV2exApiWithParams object at 0x10666dc50&gt;, lang = 'go' def test_node(self, lang): path = 'api/nodes/show.json?name=%s' %(lang) url = self.domain + path res = requests.get(url).json() assert res['name'] == lang &gt; assert 0 E assert 0 v2ex_api_test.py:27: AssertionError ______________________________________________________________ TestV2exApiWithParams.test_node[nodejs] ______________________________________________________________ self = &lt;v2ex_api_test.TestV2exApiWithParams object at 0x106691890&gt;, lang = 'nodejs' def test_node(self, lang): path = 'api/nodes/show.json?name=%s' %(lang) url = self.domain + path res = requests.get(url).json() assert res['name'] == lang &gt; assert 0 E assert 0 v2ex_api_test.py:27: AssertionError __________________________________________________________ TestV2exApiWithExpectation.test_node[python-90] __________________________________________________________ self = &lt;v2ex_api_test.TestV2exApiWithExpectation object at 0x1066d20d0&gt;, name = 'python', node_id = 90 @pytest.mark.parametrize('name,node_id', [('python', 90), ('java', 63), ('go', 375), ('nodejs', 436)]) def test_node(self, name, node_id): path = 'api/nodes/show.json?name=%s' %(name) url = self.domain + path res = requests.get(url).json() assert res['name'] == name assert res['id'] == node_id &gt; assert 0 E assert 0 v2ex_api_test.py:40: AssertionError ___________________________________________________________ TestV2exApiWithExpectation.test_node[java-63] ___________________________________________________________ self = &lt;v2ex_api_test.TestV2exApiWithExpectation object at 0x1066e9690&gt;, name = 'java', node_id = 63 @pytest.mark.parametrize('name,node_id', [('python', 90), ('java', 63), ('go', 375), ('nodejs', 436)]) def test_node(self, name, node_id): path = 'api/nodes/show.json?name=%s' %(name) url = self.domain + path res = requests.get(url).json() assert res['name'] == name assert res['id'] == node_id &gt; assert 0 E assert 0 v2ex_api_test.py:40: AssertionError ___________________________________________________________ TestV2exApiWithExpectation.test_node[go-375] ____________________________________________________________ self = &lt;v2ex_api_test.TestV2exApiWithExpectation object at 0x10666d790&gt;, name = 'go', node_id = 375 @pytest.mark.parametrize('name,node_id', [('python', 90), ('java', 63), ('go', 375), ('nodejs', 436)]) def test_node(self, name, node_id): path = 'api/nodes/show.json?name=%s' %(name) url = self.domain + path res = requests.get(url).json() assert res['name'] == name assert res['id'] == node_id &gt; assert 0 E assert 0 v2ex_api_test.py:40: AssertionError _________________________________________________________ TestV2exApiWithExpectation.test_node[nodejs-436] __________________________________________________________ self = &lt;v2ex_api_test.TestV2exApiWithExpectation object at 0x1066d2710&gt;, name = 'nodejs', node_id = 436 @pytest.mark.parametrize('name,node_id', [('python', 90), ('java', 63), ('go', 375), ('nodejs', 436)]) def test_node(self, name, node_id): path = 'api/nodes/show.json?name=%s' %(name) url = self.domain + path res = requests.get(url).json() assert res['name'] == name assert res['id'] == node_id &gt; assert 0 E assert 0 v2ex_api_test.py:40: AssertionError ================================================================ 8 failed, 1 passed in 1.81 seconds ================================================================= 11.生成xml格式的测试报告 pytest有非常友好的命令行报告输出，在做用例开发的时候，这是极好的。然而我们在运行用例后经常会需要将测试结果广而告之，发送给相关责任人浏览，所以生成简洁美观的测试报告是很有必要的。 生成junit格式的xml报告 pytest可以生成junit格式的xml报告，在命令行中加入--junit-xml=path 参数就可以了。 pytest test_quick_start.py --junit-xml=report.xml 上面的命令在当前文件夹中生成了名为report.xml的测试报告 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;testsuite errors=&quot;0&quot; failures=&quot;0&quot; name=&quot;pytest&quot; skips=&quot;0&quot; tests=&quot;1&quot; time=&quot;0.009&quot;&gt;&lt;testcase classname=&quot;test_quick_start&quot; file=&quot;test_quick_start.py&quot; line=&quot;3&quot; name=&quot;test_reverse&quot; time=&quot;0.000499725341797&quot;&gt;&lt;/testcase&gt;&lt;/testsuite&gt;% ci集成 jenkins在build后可以通过插件展示junit格式的测试报告，具体步骤就不描述了。 ","link":"https://preszang.github.io/post/3oHikQsbE/"},{"title":"关于软件测试和软件测试人员","content":"一、软件测试人员应该居安思危 身为测试人员，虽然我们平常的工作相对比较安逸。 但是千万不能温水煮青蛙。 应该自强不息， 要像开发人员一样， 不断学习，提高自己的编程水平。 二、测试人员应该比开发人员更熟悉业务需求 1. 测试人员的水平主要体现在测试用例的设计上。 要设计出全面，覆盖广的测试用例，需要测试人员对自己所测试的项目的业务需求非常熟悉，甚至要比开发人员还要熟悉。 2. 这些业务知识非常有用的，学习起来比较有激情。 3. 要熟读功能需求文档， 任何有疑问的地方都要去和PM确认。 4. 把自己当成最终用户， 经常使用自己所测试的软件。模拟用户的行为。 5. 熟记软件的每个功能。 三、学会如何跟开发人员相处 1. 测试人员必须跟开发人员密切合作， 所以跟开发人员搞好关系是相当重要的。 2. 和开发人员成为朋友，熟悉了干啥都方便 3. 不要打扰开发人员，看到开发在聚精会神写代码的时候，千万不要去打扰人家。 写代码需要集中精力，如果被打扰，就会中断思考。 4. 集中问问题。把需要问的问题都总结起来， 集中起来问开发，这样能节省大量的时间。 5. 提好的Bug，不被开发人员烦。如果开发人员看到一个Bug 描述不清楚，还无法重现，他肯定会骂测试人员。 所以测试人员一定要写好Bug，描述精确，简洁，没有歧义，详细简洁的重现步骤，加截图。 四、测试人员应该懂一些基本的编程 1. 你的产品是用`php` 开发的，那测试人员应该有`php`的入门知识。 如果架构是微服务，那起码要懂得一些`RPC`相关的东西吧。 2. 你测试web程序，你起码要了解`HTML`、`CSS`、 `Javascript`、` Jquery`吧，否则你测了一两年web程序，都不知道这东西是怎么做的，悲剧了吧。 3. 只有懂代码你才能和开发人员交流，不被开发鄙视。 五、测试人员搭建开发环境 1. 项目的代码是最好的学习资料了，我们不能总跟在开发屁股后面做测试，不能老是等开发`build`一个版本后，我们就测试这个版本，开发`commit`了什么代码，测试人员一点都不知道。 2. 偶尔我们应该了解下产品代码是怎么设计的，了解下开发人员是如何修复bug的。 3. 说不定编程水平高了，还能帮开发做`code review`。 4. 使用工具把代码`check out`到本机。 经常看看代码，尤其是经常看看开发修复bug时候提交的代码，事半功倍。 六、写文档是测试人员的核心能力 1. 多写写博客，写写文档，多总结。 2. 测试后期应该做交叉测试，就是指两个测试工程师，互相交换下测试的项目。 这样做有很多好处。 3. 有利于找出bug, 测试工程师测久了自己的项目，容易形成眼盲。会对一些Bug熟视无睹。 4. 有利于知识和业务共享，避免人员离职，请假，造成无人测试的情况。 5. 测试思想不一样，可以互相找出很多问题 七、测试人员的瓶颈 黑盒测试工作做个两三年，基本上就能掌握测试需要的大部分知识， 很多人就感觉到发展瓶颈了，每天重复测试，学不到东西，很快就会对测试工作失去激情。 学不到东西，技术水平低下，是测试这个行业最大的毛病。 如何突破瓶颈？ 我也不知道。 八、尽量实现自动化 1. 抽时间尽量把自己的测试工作实现自动化，可以节省测试的时间，提高自己的技术水平，也可以避免老是重复测试，~~也为了更方便的摸鱼~~ 九、自动化测试VS手动测试 1. 自动化是趋势， 只会做手工测试的人，以后肯定会失去竞争力。 2. 自动化测试的技术和开发用到的技术相差太远。 3. 努力学习编码，然后用于测试，才是正道 十、优秀的测试人员非常稀少 1. 想把测试做好非常不容易 2. 优秀的测试人员需要很广的知识面，良好的沟通能力（不但要和开发人员和项目经理打交道，还要跟其他组的人交流）。 3. 丰富的测试经验，对测试工作有极大的热情， 耐心。 4. 还需要测试人员有丰富的业务知识 5. 还要会写代码。 十一、尽量少用UI自动化测试，多使用单元测试，接口测试 1. 能找到`bug`的自动化测试，才是有用的，否则就是个噱头 2. `UI`自动化测试比较不稳定，对于测试结果的分析也困难。 3. 而且`UI`改动也大。 所以应该尽量多做一些底层的的自动化测试， ","link":"https://preszang.github.io/post/关于软件测试和软件测试人员/"},{"title":"【女儿情】叶锐文版本","content":" ","link":"https://preszang.github.io/post/nu-er-qing-xie-rui-wen-ban-ben/"},{"title":"Pyunit测试框架基本教程","content":"1. 基本概念 unittest是python自带的单元测试框架，有时候又被称为&quot;PyUnit&quot;，是python版本的JUint实现。 该框架的作者是 Kent Beck和Erich Gamma，感谢祖师爷赏饭吃。 在学习使用unittest库之前，我们需要了解一下unittest库的一些重要概念: test fixture: 代表了用例执行前的准备工作和用例执行之后的清理工作。比如在用例执行前创建临时文件和文件夹，又或者启动1个server进程等； test case: 测试用例，这个相信大家都不陌生。是测试的最小单位，一般检查一组输入的响应(输出)是否符合预期。unittest模块提供了TestCase类来帮助我们创建测试用例； test suite: 经常被翻译成&quot;测试套件&quot;，也有人称为&quot;测试套&quot;，是测试用例或测试套件的集合，一般用来把需要一起执行的用例组合到一起; test runner: 用来执行测试用例并输出测试结果的组件。可以是图形界面或命令行界面; test fixture的功能可以理解成是初始化和清理测试数据及环境 test case是测试用例 test suite是用例集合 test runner的作用是运行用例并返回结果 2. 基本用法 我们通过最简单的例子来看一下unittest的基本用法，下面的代码测试了3个python字符串方法，基本上满足了大部分情况下的测试需求 import unittest class TestStringMethods(unittest.TestCase): def test_upper(self): self.assertEqual('foo'.upper(), 'FOO') def test_isupper(self): self.assertTrue('FOO'.isupper()) self.assertFalse('Foo'.isupper()) def test_split(self): s = 'hello world' self.assertEqual(s.split(), ['hello', 'world']) # check that s.split fails when the separator is not a string with self.assertRaises(TypeError): s.split(2) if __name__ == '__main__': unittest.main() 解释一下关键点 可以通过继承unittest.TestCase类来定义我们自己的测试用例，1个测试用例类下面可以有多个测试方法(test)或者叫做测试点 记住这个套路：测试用例中方法名以test开头的方法才是测试方法，比如上面的例子里定义了3个以test开头的方法，分别是test_upper，test_isupper和test_split。非测试方法是不会被test runner执行的 断言是测试用例的核心。我们使用assertEqual()来判断预期结果，用assertTrue()和assertFalse来做是非判断，以及用assertRaises()来判断预期的异常是否有被抛出。这些unittest提供的以assert开头的方法就是断言，一般情况下,每个测试方法里都必须有断言 最后, unittest.main提供了最简单的运行用例的方式。当我们从命令行运行上面的代码时，我们可以看到如下的输出 ... ---------------------------------------------------------------------- Ran 3 tests in 0.000s OK 除了使用unittest.main，还有其他的方式可以运行测试用例，比如把最后2行替换为 suite = unittest.TestLoader().loadTestsFromTestCase(TestStringMethods) unittest.TextTestRunner(verbosity=2).run(suite) 运行用例，结果将会如下所示 test_isupper (__main__.TestStringMethods) ... ok test_split (__main__.TestStringMethods) ... ok test_upper (__main__.TestStringMethods) ... ok ---------------------------------------------------------------------- Ran 3 tests in 0.001s OK 3. 实例: 测试弱密码 我们需要判断用户的密码中包含简单密码，规则是这样的，密码必须至少6位，满足6位的话判断用户的密码不是password123或者password之类的弱密码。 对于如下的测试数据，我们要如何使用unittest来进行相关测试呢？ [ {&quot;name&quot;:&quot;jack&quot;,&quot;password&quot;:&quot;Iloverose&quot;}, {&quot;name&quot;:&quot;rose&quot;,&quot;password&quot;:&quot;Ilovejack&quot;}, {&quot;name&quot;:&quot;tom&quot;,&quot;password&quot;:&quot;password123&quot;} ] Test fixture 前文我们也说过，text fixture的主要功能是初始化测试数据或环境以及清理测试数据或环境。 考虑上面的例子，对我们而言，在用例执行之前初始化上面的测试数据是有必要的，我们可以把上面的数据用python的数据结构来表示，比较合适的数据结构是python的字典。这样做有如下的好处 统一初始化一些需要在多个用例之间共享的数据 可以在初始化的时候做一些数据的处理工作，比如过滤一些无效数据等 Test fixture最简单的实现方式是通过自定义下面的2个方法: TestCase.setUp方法在每个测试方法运行之前都会运行一次，适合为每个用例都初始化一遍数据 TestCase.tearDown方法在每个测试方法运行之后都会运行一次，适合为每个用例都清理一遍数据 代码 新建名为test_password_1.py的文本文件，输入如下内容 import unittest class PasswordTestCase(unittest.TestCase): def setUp(self): print('set up') self.test_data = [ dict(name='jack', password='Iloverose'), dict(name='rose', password='Ilovejack'), dict(name='tom', password='password123') ] def test_weak_password(self): for data in self.test_data: passwd = data['password'] self.assertTrue(len(passwd) &gt;= 6) msg = &quot;user %s has a weak password&quot; %(data['name']) self.assertTrue(passwd != 'password', msg) self.assertTrue(passwd != 'password123', msg) def test_dummy(self): pass if __name__ == '__main__': unittest.main() 运行 在命令行里输入 python test_password_1.py来运行用例，结果如下 $ python test_password_1.py set up .set up F ====================================================================== FAIL: test_week_password (__main__.PasswordTestCase) ---------------------------------------------------------------------- Traceback (most recent call last): File &quot;test_password_1.py&quot;, line 21, in test_week_password self.assertTrue(passwd != 'password123', msg) AssertionError: False is not true : user tom has a weak password ---------------------------------- Ran 2 tests in 0.001s FAILED (failures=1) 解释一下 setUp方法运行了2次，所以打印出了2次'set up'，这是因为上面的用例中有2个测试方法(2个方法名以test开头的方法)，setUp会在每个测试方法执行之前执行1次 由于用户tom的密码是弱密码password123，所以上面的用例运行失败了，打印出1个&quot;F&quot;，有几个F就代表有几个测试用例失败 测试方法运行失败时测试结果里会打印出失败方法的方法名，因此好的测试方法名可以方便我们快速找出失败用例 为了让错误信息更加容易理解，我们经常会自定义断言出错提示消息，比如msg = &quot;user %s has a weak password&quot; %(data['name'])。一旦断言失败，我们一眼就能看出是哪个用户的密码强度不够 亲自动手试一试 假设我们增加1条测试数据，如下所示 [ {&quot;name&quot;:&quot;jack&quot;,&quot;password&quot;:&quot;Iloverose&quot;}, {&quot;name&quot;:&quot;rose&quot;,&quot;password&quot;:&quot;Ilovejack&quot;}, {&quot;name&quot;:&quot;tom&quot;,&quot;password&quot;:&quot;password123&quot;}, {&quot;name&quot;:&quot;jerry&quot;,&quot;password&quot;:&quot;password&quot;} ] 再运行上面的用例，观察一下测试结果是否会有不同？如果没有不同，那是为什么？ 4. 实例: 读取测试数据并测试弱密码 接上一节的弱密码例子，我们的用例尽管运行的不错，但还是有点问题。 假如我们需要增加一些测试数据，那么我们就必须去修改setUp方法，在test_data列表中增加数据，\b频繁修改代码以适应一些不变的测试场景，这是没有必要的开销，可以想办法去优化。 我们可以把测试数据保存在文件里，通过读取文件的方式，每次动态从测试用例读取数据，这样数据的改变并不会影响用例，用例逻辑相对稳定，维护成本得到一定的降低。 设计测试数据 我们可以把测试数据保存成json格式，json格式的数据在各个语言间有较好的通用性，比较适合复用。 新建user_data.json文件，内容如下 [ {&quot;name&quot;:&quot;jack&quot;,&quot;password&quot;:&quot;Iloverose&quot;}, {&quot;name&quot;:&quot;rose&quot;,&quot;password&quot;:&quot;Ilovejack&quot;}, {&quot;name&quot;:&quot;tom&quot;,&quot;password&quot;:&quot;password123&quot;} ] 使用python的json库解析上面的json文件，可以得到如上节中test_data一致的数据。 代码 新建test_password_2.py，内容如下 import unittest import json class PasswordWithJsonTestCase(unittest.TestCase): data_file_path = './user_data.json' def setUp(self): print('set up') self.test_data = json.loads(open(self.data_file_path).read()) def test_weak_password(self): for data in self.test_data: passwd = data['password'] self.assertTrue(len(passwd) &gt;= 6) msg = &quot;user %s has a weak password&quot; %(data['name']) self.assertTrue(passwd != 'password', msg) self.assertTrue(passwd != 'password123', msg) def test_dummy(self): pass if __name__ == '__main__': unittest.main() 跟上一节相比，最大的不同点是现在test_data通过解析json文件的方式来赋值self.test_data = json.loads(open(self.data_file_path).read())。 执行测试文件，结果应该与上一节一致。 发现问题 上面的代码有2个测试方法:test_week_password和test_dummy。由于setUp会在每个测试方法执行之前执行一次，那么setUp方法会执行2次，相应的json文件也会读取2次。如果测试方法多的话，那么反复读取json文件对性能来说是一个巨大的挑战。 优化 对于上面的测试数据读取场景，我们可以在所有测试方法执行前读取一次数据，毕竟测试数据在所有测试方法执行过程中是保持不变的。 setUpClass()和tearDownClass() setUpClass方法在每个测试用例类执行之前会执行一次，接收该class作为唯一的参数，并且必须使用装饰器classmethod() tearDownClass: 在所有测试方法执行完之后被调用1次，调用方式跟上面的方法类似 重构 下面我们重构代码以达到只读取1次测试数据的目的，新建文件``test_password_3.py`，内容如下 import unittest import json class WeakPasswordTestCase(unittest.TestCase): @classmethod def setUpClass(kls): data_file_path = './user_data.json' print('before all test methods') with open(data_file_path) as f: kls.test_data = json.loads(f.read()) def test_weak_password(self): for data in self.test_data: passwd = data['password'] self.assertTrue(len(passwd) &gt;= 6) msg = &quot;user %s has a weak password&quot; %(data['name']) self.assertTrue(passwd != 'password', msg) 5. 实例: 找出所有是弱密码的用户 当我们的测试数据是下面这些的时候，我们的用例是有问题的。 [ {&quot;name&quot;:&quot;jack&quot;,&quot;password&quot;:&quot;Iloverose&quot;}, {&quot;name&quot;:&quot;rose&quot;,&quot;password&quot;:&quot;Ilovejack&quot;}, {&quot;name&quot;:&quot;tom&quot;,&quot;password&quot;:&quot;password123&quot;}, {&quot;name&quot;:&quot;jerry&quot;,&quot;password&quot;:&quot;password&quot;} ] 我们的用例只能找出tom是弱密码的用户，jerry这个用户会成为漏网之鱼。 为什么 这是因为在unittest中，一旦某个测试方法中的断言失败，后续的断言都不会被执行。 还原一下上面的例子，当用例在断言tom失败后，for循环就退出了，测试方法也执行完毕了，后面jerry这条数据就不会被断言。 怎么办 我们可以重构一下我们的用例，让整个用例只断言1次，断言失败以后就把弱密码的用户打印出来。 代码 修改user_data.json文件，加入一些测试数据，修改后的user_data.json文件应该是 [ {&quot;name&quot;:&quot;jack&quot;,&quot;password&quot;:&quot;Iloverose&quot;}, {&quot;name&quot;:&quot;rose&quot;,&quot;password&quot;:&quot;Ilovejack&quot;}, {&quot;name&quot;:&quot;tom&quot;,&quot;password&quot;:&quot;password123&quot;}, {&quot;name&quot;:&quot;jerry&quot;,&quot;password&quot;:&quot;password&quot;}, {&quot;name&quot;:&quot;fred&quot;,&quot;password&quot;:&quot;123456&quot;}, {&quot;name&quot;:&quot;elma&quot;,&quot;password&quot;:&quot;654321&quot;} ] 新建test_password_4.py文件，内容如下 import unittest import json class WeakPasswordTestCase1(unittest.TestCase): @classmethod def setUpClass(kls): data_file_path = './user_data.json' print('before all test methods') with open(data_file_path) as f: kls.test_data = json.loads(f.read()) def test_weak_password(self): res = True msg = [] for data in self.test_data: passwd = data['password'] tmp_res = True tmp_res = tmp_res and (len(passwd) &gt;= 6) tmp_res = tmp_res and (passwd != 'password') tmp_res = tmp_res and (passwd != 'password123') if not tmp_res: msg.append(&quot;user %s has a weak password %s&quot; %(data['name'], data['password'])) res = res and tmp_res self.assertTrue(res, &quot;\\n&quot;.join(msg)) def test_dummy(self): pass if __name__ == '__main__': unittest.main() 运行及结果 在命令行中运行python test_password_4.py，结果如下 $ python test_password_4.py before all test methods .F ====================================================================== FAIL: test_weak_password (__main__.WeakPasswordTestCase1) ---------------------------------------------------------------------- Traceback (most recent call last): File &quot;test_password_4.py&quot;, line 27, in test_week_password self.assertTrue(res, &quot;\\n&quot;.join(msg)) AssertionError: user tom has a weak password password123 user jerry has a weak password password ---------------------------------------------------------------------- Ran 2 tests in 0.001s FAILED (failures=1) 我们能学到什么 断言一旦失败之后测试方法就会结束运行，所以一般来说1个测试方法推荐只有1个断言 如果一个测试方法里面必须要有多个断言，那么要确保前面的断言失败之后，后面的断言就算不运行也不会影响测试的范围和结果 for循环中的断言一旦失败，for循环就退出了 上面演示的测试用例写法其实具备了一定的数据驱动测试的思想 6. 命令行接口 unittest支持命令行接口，我们可以在命令行里指定运行具体的测试用例。 在test_password_1.py中定义了PasswordTeseCase用例，我们可以从命令行中指定只运行该用例。 $ python -m unittest test_password_1.PasswordTeseCase set up .set up F ====================================================================== FAIL: test_week_password (test_password_1.PasswordTeseCase) ---------------------------------------------------------------------- Traceback (most recent call last): File &quot;/Users/aaa/code/test_password_1.py&quot;, line 21, in test_week_password self.assertTrue(passwd != 'password123', msg) AssertionError: False is not true : user tom has a weak password ---------------------------------------------------------------------- Ran 2 tests in 0.001s FAILED (failures=1) 还可以使用-v参数来获得更详细的输出 $ python -m unittest test_password_1.PasswordTeseCase -v test_dummy (test_password_1.PasswordTeseCase) ... set up ok test_week_password (test_password_1.PasswordTeseCase) ... set up FAIL ====================================================================== ### FAIL: test_week_password (test_password_1.PasswordTeseCase) Traceback (most recent call last): File &quot;/Users/aaa/code/test_password_1.py&quot;, line 21, in test_week_password self.assertTrue(passwd != 'password123', msg) AssertionError: False is not true : user tom has a weak password ---------------------------------------------------------------------- Ran 2 tests in 0.001s FAILED (failures=1) 7. 各种断言方法 unittest支持各种断言方法。 断言列表---官方文档 方法 检查点 assertEqual(a, b) a == b assertNotEqual(a, b) a != b assertTrue(x) bool(x) is True assertFalse(x) bool(x) is False assertIs(a, b) a is b assertIsNot(a, b) a is not b assertIsNone(x) x is None assertIsNotNone(x) x is not None assertIn(a, b) a in b assertNotIn(a, b) a not in b assertIsInstance(a, b) isinstance(a, b) assertNotIsInstance(a, b) not isinstance(a, b) assertRaises(exc, fun, *args, **kwds) fun(*args, **kwds) raises exc assertRaisesRegexp(exc, r, fun, *args, **kwds) fun(*args, **kwds) raises exc and the message matches regex r assertAlmostEqual(a, b) round(a-b, 7) == 0 assertNotAlmostEqual(a, b) round(a-b, 7) != 0 assertGreater(a, b) a &gt; b 2.7 assertGreaterEqual(a, b) a &gt;= b assertLess(a, b) a &lt; b assertLessEqual(a, b) a &lt;= b assertRegexpMatches(s, r) r.search(s) assertNotRegexpMatches(s, r) not r.search(s) assertItemsEqual(a, b) sorted(a) == sorted(b) 也支持unhashable对象 assertDictContainsSubset(a, b) a里面所有的键值对都在b中存在 8. 断言异常 我们有时候需要断言一些方法会抛出异常，这些异常需要符合我们的预期。 新建test_exception.py文件，内容如下 import unittest class DivZeroTestCase(unittest.TestCase): def test_should_raise_exception(self): with self.assertRaises(ZeroDivisionError): 1 / 0 if __name__ == '__main__': unittest.main() 运行及结果 $ python test_exception.py ---------------------------------------------------------------------- Ran 1 test in 0.000s OK 上面的例子断言了当0作为除数的时候会抛出ZeroDivisionError 断言异常是有套路的，使用with语句加assertRaises，assertRaises的参数中传入预期的异常(这些异常可能需要先import进来)，在with的子句中放上会抛出异常的语句或表达式。 ","link":"https://preszang.github.io/post/Pyunit测试框架基本教程/"},{"title":"Python 第三方日志框架 loguru 使用","content":"Python 第三方日志框架 loguru 使用 看到了一个不错的 python 第三方日志框架 loguru，优雅的记录日志 Github: https://github.com/Delgan/loguru 文档：https://loguru.readthedocs.io/en/stable/index.html 1、安装 pip install loguru 2、输出日志 from loguru import logger logger.debug(&quot;这是一条debug日志&quot;) # 终端执行后出现带颜色的日志，挺酷的 3、输出到文件 from loguru import logger logger.add(&quot;file_{time}.log&quot;) logger.debug(&quot;这是一条debug日志&quot;) logger.info(&quot;这是一条info日志&quot;) # 目录下多出一个日志文件 ：file_2019-03-14_19-53-25_661314.log 4、日志规则 from loguru import logger # 设置日志格式，过滤器，日志级别 logger.add(&quot;file.log&quot;, format=&quot;{time} {level} {message}&quot;, filter=&quot;&quot;, level=&quot;INFO&quot;) logger.debug(&quot;这是一条debug日志&quot;) logger.info(&quot;这是一条info日志&quot;) #输出 # 2019-03-14T20:01:25.392454+0800 INFO 这是一条info日志 5、日志文件 # 文件管理方式 logger.add(&quot;file_1.log&quot;, rotation=&quot;500 MB&quot;) # 文件过大就会重新生成一个文件 logger.add(&quot;file_2.log&quot;, rotation=&quot;12:00&quot;) # 每天12点创建新文件 logger.add(&quot;file_3.log&quot;, rotation=&quot;1 week&quot;) # 文件时间过长就会创建新文件 logger.add(&quot;file_X.log&quot;, retention=&quot;10 days&quot;) # 一段时间后会清空 logger.add(&quot;file_Y.log&quot;, compression=&quot;zip&quot;) # 保存zip格式 6、其他参数 logger.add(&quot;somefile.log&quot;, enqueue=True) # 异步写入 logger.add(&quot;somefile.log&quot;, serialize=True) # 序列化为json 7、时间格式化 logger.add(&quot;file.log&quot;, format=&quot;{time:YYYY-MM-DD at HH:mm:ss} | {level} | {message}&quot;) 配合 notifiers 模块 github： https://github.com/notifiers/notifiers 文档：https://notifiers.readthedocs.io/en/latest/ 8、在工程中创建多个文件处理器对象并解决中文乱码问题 # coding=utf-8 import os import sys from loguru import logger BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) log_file_path = os.path.join(BASE_DIR, 'Log/my.log') err_log_file_path = os.path.join(BASE_DIR, 'Log/err.log') logger.add(sys.stderr, format=&quot;{time} {level} {message}&quot;, filter=&quot;my_module&quot;, level=&quot;INFO&quot;) # logger.add(s) logger.add(log_file_path, rotation=&quot;500 MB&quot;, encoding='utf-8') # Automatically rotate too big file logger.add(err_log_file_path, rotation=&quot;500 MB&quot;, encoding='utf-8',level='ERROR') # Automatically rotate too big file logger.debug(&quot;That's it, beautiful and simple logging!&quot;) logger.debug(&quot;中文日志可以不&quot;) logger.error(&quot;严重错误&quot;) ","link":"https://preszang.github.io/post/Python 第三方日志框架 loguru 使用/"},{"title":"【山雀】万能青年旅店","content":" ","link":"https://preszang.github.io/post/shan-que-wan-neng-qing-nian-lu-dian/"}]}