{"posts":[{"title":"【贯口】地理图","content":"东门官银号，北海楼、龟甲胡同，万寿宫、北大关，河北大街、大红桥，西于庄子、丁字沽，南仓北仓，走蒲口、汉宫、桃花口，杨村、蔡村、河西务，安平码头、张家湾，走通县、过八里桥进齐化门，东四牌楼北京桥，交道口 出德胜门，走清河、沙河、昌平县、南口、青龙桥、康庄子、怀来县、沙城、保安、下花园、辛庄子、宣化、沙岭子、宁远、张家口、柴沟、西弯、天镇、阳高县、聚乐堡、周士庄、大同、孤山、丰镇、集宁、平地泉、三岔口、十八台、桌子山、三道营、旗下营、陶卜旗、呼和浩特、萨拉齐、西包头、过乌拉苏哈、石嘴山、宁夏回族自治区。 银川市，过中宁走甘肃、兰州、西宁、凉州、永昌、临泽、酒泉、玉门、猩猩峡、新疆哈密、巴里、昆木、乌鲁木齐、达坂城、库尔勒市、马奇、库车、温宿、泽普、昆仑山。 进西藏聂拉木、札什伦布、多拉本、天泉、柴达木、齐木沙尔到拉萨、墨竹、工卡、拉里、柴垛木是巴塘、理塘、雅砻江。 大渡河，过泸定桥、四川成都市，走简阳、资阳、隆昌、永川到重庆，贵州省遵义、贵阳市，云南省昆明市、文山、砚山到广西，南宁、柳州、阳朔、桂林市，湖南省衡阳、株洲到长沙，湖北省沙市、汉阳、汉口武胜关，河南信阳、驻马店、郾城、许昌、郑州、开封、洛阳、三门峡，陕西临宝、潼关、华阴县、西安、咸阳、岳县，到延安。 由龙门过黄河，山西省榆次县、太原市、寿阳、平定州、阳泉，井陉、河北石家庄、新乐、望都、保定市、深、武、饶、安，河间、沧州、南皮、东光、德州、平原、禹城山东济南市、党家庄、张夏、万德、界首、泰安，东北坡大汶口、吴村、曲阜、兖州、固镇新桥、曹老集是蚌埠门台子，由白关小溪和石门山、张八岭、担子街、花旗营、浦口，过江南京市、龙潭、下蜀、镇江、昆山、陆家浜，无锡、苏州到上海。 走松江、浙江嘉兴、绍兴、杭州、金华到江西，永丰、瑞金到福建，走青州、连城、三原、南平、福州、泉州、金门、厦门奔汕头，广东省广州、雷州、海南岛，过了九龙、香港，到越南河内。 老挝万象、泰国曼谷、缅甸仰光，孟加拉，印度加尔各答、孟买、新德里过巴基斯坦、 阿富汗伊朗、伊拉克、叙利亚、黎巴嫩、土耳其安卡拉，过黑海到苏联乌克兰，斯大林格勒、列宁格勒、莫斯科、爱沙尼亚、拉脱维亚、立陶宛，波罗的海到芬兰、瑞典斯德哥尔摩、挪威、丹麦、德国柏林、波兰华沙、捷克斯洛伐克、匈牙利布达佩斯、罗马尼亚、保加利亚、/索非亚、希腊、阿尔巴尼亚、南斯拉夫、意大利、瑞士、瑞玛、法国马赛，地中海、直布罗陀、葡萄牙、西班牙/马德里，过英吉利海峡到伦敦。 英格兰、苏格兰、北爱尔兰、冰岛，过了大西洋到美洲，走加拿大魁北克、纽芬兰波士顿、纽约、华盛顿、芝加哥、旧金山、墨西哥、中亚美尼亚、危地马拉、洪都拉斯、厄瓜多尔、尼加拉瓜、哥伦比亚、玻利维亚、圭亚那、巴西、秘鲁、乌拉圭、阿根廷布宜诺斯艾利斯、智利圣地亚哥、麦哲伦、澳大利亚墨尔本，过大洋洲走突尼斯、摩洛哥、阿尔及利亚、利比亚、埃及、苏丹、埃塞俄比亚、莫桑比克、马达加斯加，到南洋群岛，苏门答腊、爪哇、马来西亚、菲律宾马尼拉，过吕宋到日本九州、门次、下关、长崎、广岛、东京、大阪、名古屋、北海道，千岛、库页岛、勘察加半岛过日本海到朝鲜，釜山、大丘、汉城、平壤、新义州，过鸭绿江加到丹东。 走通化、梅河口、吉林省长春市、延吉、双河镇、宁安、牡丹江、林口、佳木斯、木兰、巴彦、哈尔滨、齐齐哈尔、内蒙古巴克图、海拉尔、满洲里、呼伦贝尔、阿尔山、乌兰浩特、开原、铁岭、乱石山，走新城子、文关屯、沈阳皇姑屯、新民县、柳河沟、白旗堡、大虎山、高山子、青堆子、赵家屯、沟帮子、大林河、双羊店、锦州、女儿河、高桥连山韩家沟、兴城白庙、沙后所、前所、山海关、走秦皇岛、北戴河、昌黎县到滦州、古冶、开平到唐山，芦台、汉沽、塘沽到天津，过杨村、蔡村、河西务、安平、马头、张家湾到通县，过八里桥，进建国门，才回到咱们祖国的首都北京城 ","link":"https://preszang.github.io/post/CoqzCyRqw/"},{"title":"一些常用的web测试方法","content":" 记录了一些常用 web 测试方法总结 一、输入框 1、字符型输入框： （1）字符型输入框： 英文全角、英文半角、数字、空或者空格、特殊字符“~！@#￥%……&amp;*？[]{}”特别要注意单引号和&amp;符号。禁止直接输入特殊字符时，使用“粘贴、拷贝”功能尝试输入。 （2）长度检查： 最小长度、最大长度、最小长度-1、最大长度+1、输入超工字符比如把整个文章拷贝过去。 （3）空格检查： 输入的字符间有空格、字符前有空格、字符后有空格、字符前后有空格 （4）多行文本框输入： 允许回车换行、保存后再显示能够保存输入的格式、仅输入回车换行，检查能否正确保存（若能，检查保存结果，若不能，查看是否有正常提示）、 （5）安全性检查： 输入特殊字符串 null,NULL,javascript, &lt;script&gt;,&lt;/script&gt;,&lt;title&gt;,&lt;html&gt;,&lt;td&gt; 输入脚本函数 &lt;script&gt;alert(&quot;abc&quot;)&lt;/script&gt; doucment.write(&quot;abc&quot;) &lt;b&gt;hello&lt;/b&gt; 2、数值型输入框： （1）边界值： 最大值、最小值、最大值+1、最小值-1 （2）位数： 最小位数、最大位数、最小位数-1 最大位数+1、输入超长值、输入整数 （3）异常值、特殊字符： 输入空白（NULL）、空格或&quot; ~!@#$%^&amp;*()_+{}|[]\\:&quot;&lt;&gt;?;',./?;:'-= 等可能导致系统错误的字符、禁止直接输入特殊字符时，尝试使用粘贴拷贝查看是否能正常提交、word 中的特殊功能，通过剪贴板拷贝到输入框，分页符，分节符类似公式的上下标等、数值的特殊符号如 ∑，㏒，㏑，∏，+，- 输入负整数、负小数、分数、 输入字母或汉字、 小数（小数前 0 点舍去的情况，多个小数点的情况）、 首位为 0 的数字如 01、02、 科学计数法是否支持 1.0E2、 全角数字与半角数字、 数字与字母混合、 16 进制，8 进制数值、 货币型输入（允许小数点后面几位）、 （4）安全性检查： 不能直接输入就 copy 3、日期型输入框： （1）合法性检查： 输入 0 日、1 日、32 日)、 月输入[1、3、5、7、8、10、12]、日输入[31]、 月输入[4、6、9、11]、日输入[30][31]、 输入非闰年，月输入[2]，日期输入[28、29]、 输入闰年，月输入[2]、日期输入[29、30]、 月输入[0、1、12、13] （2）异常值、特殊字符： 输入空白或 NULL、输入 ~！@#￥%……&amp;*（）{}[] 等可能导致系统错误的字符 （3）安全性检查： 不能直接输入，就 copy，是否数据检验出错？ 4、信息重复: 在一些需要命名,且名字应该唯一的信息输入重复的名字或 ID,看系统有没有处理,会否报错,重名包括是否区分大小写,以及在输入内容的前后输入空格,系统是否作出正确处理. 二、搜索功能 若查询条件为输入框，则参考输入框对应类型的测试方法 1、功能实现： （1）如果支持模糊查询，搜索名称中任意一个字符是否能搜索到 （2）比较长的名称是否能查到 （3）输入系统中不存在的与之匹配的条件 （4）用户进行查询操作时，一般情况是不进行查询条件的清空，除非需求特殊说明。 2、组合测试： （1）不同查询条件之间来回选择，是否出现页面错误（单选框和多选框最容易出错） （2）测试多个查询条件时，要注意查询条件的组合测试，可能不同组合的测试会报错。 三、添加、修改功能 1、特殊键： （1）是否支持 Tab 键 （2）是否支持回车键 2、提示信息： （1）不符合要求的地方是否有错误提示 3、唯一性： （1）字段唯一的，是否可以重复添加，添加后是否能修改为已存在的字段（字段包括区分大小写以及在输入的内容前后输入空格，保存后，数据是否真的插入到数据库中，注意保存后数据的正确性） 4、数据 正确性： （1）对编辑页的每个编辑项进行修改，点击保存，是否可以保存成功，检查想关联的数据是否得到更新。 （2）进行必填项检查（即是否给出提示以及提示后是否依然把数据存到数据库中；是否提示后出现页码错乱等） （3）是否能够连续添加（针对特殊情况） （4）在编辑的时候，注意编辑项的长度限制，有时在添加的时候有，在编辑的时候却没有（注意要添加和修改规则是否一致） （5）对于有图片上传功能的编辑框，若不上传图片，查看编辑页面时是否显示有默认的图片，若上传图片，查看是否显示为上传图片 （6）修改后增加数据后，特别要注意查询页面的数据是否及时更新，特别是在首页时要注意数据的更新。 （7）提交数据时，连续多次点击，查看系统会不会连续增加几条相同的数据或报错。 （8）若结果列表中没有记录或者没选择某条记录，点击修改按钮，系统会抛异常。 四、删除功能 1、特殊键： （1）是否支持 Tab 键 （2）是否支持回车键 2、提示信息： （1）不选择任何信息，直接点击删除按钮，是否有提示 （2）删除某条信息时，应该有确认提示 3、数据 实现： （1）是否能连续删除多个产品 （2）当只有一条数据时，是否可以删除成功 （3）删除一条数据后，是否可以添加相同的数据 （4）如系统支持批量删除，注意删除的信息是否正确 （5）如有全选，注意是否把所有的数据删除 （6）删除数据时，要注意相应查询页面的数据是否及时更新 （7）如删除的数据与其他业务数据关联，要注意其关联性（如删除部门信息时，部门下游员工，则应该给出提示） （8）如果结果列表中没有记录或没有选择任何一条记录，点击删除按钮系统会报错。 如：某一功能模块具有最基本的增删改查功能，则需要进行以下测试 单项功能测试（增加、修改、查询、删除） 增加——&gt;增加——&gt;增加 （连续增加测试） 增加——&gt;删除 增加——&gt;删除——&gt;增加 （新增加的内容与删除内容一致） 增加——&gt;修改——&gt;删除 修改——&gt;修改——&gt;修改 （连续修改测试） 修改——&gt;增加（新增加的内容与修改前内容一致） 修改——&gt;删除 修改——&gt;删除——&gt;增加 （新增加的内容与删除内容一致） 删除——&gt;删除——&gt;删除 （连续删除测试） 五、注册、登录模块 1、注册功能： （1）注册时，设置密码为特殊版本号，检查登录时是否会报错 （2）注册成功后，页面应该以登录状态跳转到首页或指定页面 （3）在注册信息中删除已输入的信息，检查是否可以注册成功。 2、登录 功能： （1）输入正确的用户名和正确的密码 （2）输入正确的用户名和错误的密码 （3）输入错误的用户名和正确的密码 （4）输入错误的用户名和错误的密码 （5）不输入用户名和密码（均为空格） （6）只输入用户名，密码为空 （7）用户名为空，只输入密码 （8）输入正确的用户名和密码，但是不区分大小写 （9）用户名和密码包括特殊字符 （10）用户名和密码输入超长值 （11）已删除的用户名和密码 （12）登录时，当页面刷新或重新输入数据时，验证码是否更新 六、上传图片测试 1、功能 实现： （1）文件类型正确、大小合适 （2）文件类型正确，大小不合适 （3）文件类型错误，大小合适 （4）文件类型和大小都合适，上传一个正在使用中的图片 （5）文件类型大小都合适，手动输入存在的图片地址来上传 （6）文件类型和大小都合适，输入不存在的图片地址来上传 （7）文件类型和大小都合适，输入图片名称来上传 （8）不选择文件直接点击上传，查看是否给出提示 （9）连续多次选择不同的文件，查看是否上传最后一次选择的文件 七、查询结果列表 1、功能 实现： （1）列表、列宽是否合理 （2）列表数据太宽有没有提供横向滚动 （3）列表的列名有没有与内容对应 （4）列表的每列的列名是否描述的清晰 （5）列表是否把不必要的列都显示出来 （6）点击某列进行排序，是否会报错（点击查看每一页的排序是否正确） （7）双击或单击某列信息，是否会报错 八、返回键检查 1、一条已经成功提交的记录，返回后再提交，是否做了处理 2、检查多次使用返回键的情况，在有返回键的地方，返回到原来的页面多次，查看是否会出错 九、回车键检查 1、在输入结果后，直接按回车键，看系统如何处理，是否会报错 十、刷新键检查 1、在 Web 系统中，使用刷新键，看系统如何处理，是否会报错 十一、直接 URL 链接检查 1、在 Web 系统中，在地址栏直接输入各个功能页面的 URL 地址，看系统如何处理，是否能够直接链接查看（匿名查看），是否有权限控制，是否直接执行，并返回相应结果页； 十二、界面和易用性测试 1、风格、样式、颜色是否协调 2、界面布局是否整齐、协调（保证全部显示出来的，尽量不要使用滚动条 3、界面操作、标题描述是否恰当（描述有歧义、注意是否有错别字） 4、操作是否符合人们的常规习惯（有没有把相似的功能的控件放在一起，方便操作） 5、提示界面是否符合规范（不应该显示英文的 cancel、ok，应该显示中文的确定等） 6、界面中各个控件是否对齐 7、日期控件是否可编辑 8、日期控件的长度是否合理，以修改时可以把时间全部显示出来为准 9、查询结果列表列宽是否合理、标签描述是否合理 10、查询结果列表太宽没有横向滚动提示 11、对于信息比较长的文本，文本框有没有提供自动竖直滚动条 12、数据录入控件是否方便 13、有没有支持 Tab 键，键的顺序要有条理，不乱跳 14、有没有提供相关的热键 15、控件的提示语描述是否正确 16、模块调用是否统一，相同的模块是否调用同一个界面 17、用滚动条移动页面时，页面的控件是否显示正常 18、日期的正确格式应该是 XXXX-XX-XX 或 XXXX-XX-XX XX:XX:XX 19、页面是否有多余按钮或标签 20、窗口标题或图标是否与菜单栏的统一 21、窗口的最大化、最小化是否能正确切换 22、对于正常的功能，用户可以不必阅读用户手册就能使用 23、执行风险操作时，有确认、删除等提示吗 24、操作顺序是否合理 25、正确性检查：检查页面上的 form, button, table, header, footer,提示信息，还有其他文字拼写，句子的语法等是否正确。 26、系统应该在用户执行错误的操作之前提出警告，提示信息. 27、页面分辨率检查，在各种分辨率浏览系统检查系统界面友好性。 28、合理性检查：做 delete, update, add, cancel, back 等操作后，查看信息回到的页面是否合理。 29、检查本地化是否通过：英文版不应该有中文信息，英文翻译准确，专业。 十三、兼容性测试 兼容性测试不只是指界面在不同操作系统或浏览器下的兼容，有些功能方面的测试，也要考虑到兼容性， 包括操作系统兼容和应用软件兼容，可能还包括硬件兼容 比如涉及到 ajax、jquery、javascript 等技术的，都要考虑到不同浏览器下的兼容性问题。 十四、链接测试 主要是保证链接的可用性和正确性，它也是网站测试中比较重要的一个方面。 可以使用特定的工具如 XENU 来进行链接测试。 1 导航测试 导航描述了用户在一个页面内操作的方式，在不同的用户接口控制之间，例如按钮、对话框、列表和窗口等；或在不同的连接页面之间。通过考虑下列问题，可以决定一个 Web 应用系统是否易于导航：导航是否直观？Web 系统的主要部分是否可通过主页存取？Web 系统是否需要站点地图、搜索引擎或其他的导航帮助？ 在一个页面上放太多的信息往往起到与预期相反的效果。Web 应用系统的用户趋向于目的驱动，很快地扫描一个 Web 应用系统，看是否有满足自己需要的信息，如果没有，就会很快地离开。很少有用户愿意花时间去熟悉 Web 应用系统的结构，因此，Web 应用系统导航帮助要尽可能地准确。 导航的另一个重要方面是 Web 应用系统的页面结构、导航、菜单、连接的风格是否一致。确保用户凭直觉就知道 Web 应用系统里面是否还有内容，内容在什么地方。 Web 应用系统的层次一旦决定，就要着手测试用户导航功能，让最终用户参与这种测试，效果将更加明显。 2 图形测试 在 Web 应用系统中，适当的图片和动画既能起到广告宣传的作用，又能起到美化页面的功能。一个 Web 应用系统的图形可以包括图片、动画、边框、颜色、字体、背景、按钮等。图形测试的内容有： （1）要确保图形有明确的用途，图片或动画不要胡乱地堆在一起，以免浪费传输时间。Web 应用系统的图片尺寸要尽量地小，并且要能清楚地说明某件事情，一般都链接到某个具体的页面。 （2）验证所有页面字体的风格是否一致。 （3）背景颜色应该与字体颜色和前景颜色相搭配。 （4）图片的大小和质量也是一个很重要的因素，一般采用 JPG 或 GIF 压缩，最好能使图片的大小减小到 30k 以下 （5）最后，需要验证的是文字回绕是否正确。如果说明文字指向右边的图片，应该确保该图片出现在右边。不要因为使用图片而使窗口和段落排列古怪或者出现孤行。 通常来说，使用少许或尽量不使用背景是个不错的选择。如果您想用背景，那么最好使用单色的，和导航条一起放在页面的左边。另外，图案和图片可能会转移用户的注意力。 十五、业务流程测试（主要功能测试） 业务流程，一般会涉及到多个模块的数据，所以在对业务流程测试时，首先要保证单个模块功能的正确性，其次就要对各个模块间传递的数据进行测试，这往往是容易出现问题的地方，测试时一定要设计不同的数据进行测试。 十六、安全性测试 （1）SQL 注入（比如登录页面） （2）XSS 跨网站脚本攻击：程序或数据库没有对一些特殊字符进行过滤或处理，导致用户所输入的一些破坏性的脚本语句能够直接写进数据库中，浏览器会直接执行这些脚本语句，破坏网站的正常显示，或网站用户的信息被盗,构造脚本语句时，要保证脚本的完整性。 document.write(&quot;abc&quot;) &lt;script&gt;alter(&quot;abc&quot;)&lt;/script&gt; （3）URL 地址后面随便输入一些符号，并尽量是动态参数靠后 （4）验证码更新问题 （5）现在的 Web 应用系统基本采用先注册，后登录的方式。因此，必须测试有效和无效的用户名和密码，要注意到是否大小写敏感，可以试多少次的限制，是否可以不登录而直接浏览某个页面等。 （6）Web 应用系统是否有超时的限制，也就是说，用户登录后在一定时间内（例如 15 分钟）没有点击任何页面，是否需要重新登录才能正常使用。 （7）为了保证 Web 应用系统的安全性，日志文件是至关重要的。需要测试相关信息是否写进了日志文件、是否可追踪。 （8）当使用了安全套接字时，还要测试加密是否正确，检查信息的完整性。 （9）服务器端的脚本常常构成安全漏洞，这些漏洞又常常被黑客利用。所以，还要测试没有经过授权，就不能在服务器端放置和编辑脚本的问题。 十七、性能测试 1 连接速度测试 用户连接到 Web 应用系统的速度根据上网方式的变化而变化，他们或许是电话拨号，或是宽带上网。当下载一个程序时，用户可以等较长的时间，但如果仅仅访问一个页面就不会这样。如果 Web 系统响应时间太长（例如超过 5 秒钟），用户就会因没有耐心等待而离开。 另外，有些页面有超时的限制，如果响应速度太慢，用户可能还没来得及浏览内容，就需要重新登录了。而且，连接速度太慢，还可能引起数据丢失，使用户得不到真实的页面。 2 负载测试 负载测试是为了测量 Web 系统在某一负载级别上的性能，以保证 Web 系统在需求范围内能正常工作。负载级别可以是某个时刻同时访问 Web 系统的用户数量，也可以是在线数据处理的数量。例如：Web 应用系统能允许多少个用户同时在线？如果超过了这个数量，会出现什么现象？Web 应用系统能否处理大量用户对同一个页面的请求？ 3 压力测试 负载测试应该安排在 Web 系统发布以后，在实际的网络环境中进行测试。因为一个企业内部员工，特别是项目组人员总是有限的，而一个 Web 系统能同时处理的请求数量将远远超出这个限度，所以，只有放在 Internet 上，接受负载测试，其结果才是正确可信的。 进行压力测试是指实际破坏一个 Web 应用系统，测试系统的反映。压力测试是测试系统的限制和故障恢复能力，也就是测试 Web 应用系统会不会崩溃，在什么情况下会崩溃。黑客常常提供错误的数据负载，直到 Web 应用系统崩溃，接着当系统重新启动时获得存取权。 压力测试的区域包括表单、登录和其他信息传输页面等。 备注： 1、负载/压力测试应该关注什么 测试需要验证系统能否在同一时间响应大量的用户，在用户传送大量数据的时候能否响应，系统能否长时间运行。可访问性对用户来说是极其重要的。如果用户得到“系统忙”的信息，他们可能放弃，并转向竞争对手。系统检测不仅要使用户能够正常访问站点，在很多情况下，可能会有黑客试图通过发送大量数据包来攻击服务器。出于安全的原因，测试人员应该知道当系统过载时，需要采取哪些措施，而不是简单地提升系统性能。 1）瞬间访问高峰 如果您的站点用于公布彩票的抽奖结果，最好使系统在中奖号码公布后的一段时间内能够响应上百万的请求。负载测试工具能够模拟 X 个用户同时访问测试站点。 2）每个用户传送大量数据 网上书店的多数用户可能只订购 1-5 书，但是大学书店可能会订购 5000 本有关心理学介绍的课本?或者一个祖母为她的 50 个儿孙购买圣诞礼物(当然每个孩子都有自己的邮件地址)系统能处理单个用户的大量数据吗? 3）长时间的使用 如果站点用于处理鲜花订单，那么至少希望它在母亲节前的一周内能持续运行。如果站点提供基于 web 的 email 服务，那么点最好能持续运行几个月，甚至几年。可能需要使用自动测试工具来完成这种类型的测试，因为很难通过手工完成这些测试。你可以想象组织 100 个人同时点击某个站点。但是同时组织 100000 个人呢。通常，测试工具在第二次使用的时候，它创造的效益，就足以支付成本。而且，测试工具安装完成之后，再次使用的时候，只要点击几下。 采取措施：采用性能测试工具 WAS、ACT，LR 等协助进行测试 十八、测试中应该注意的其他情况 1、在测试时，与网络有关的步骤或者模块必须考虑到断网的情况 2、每个页面都有相应的 Title，不能为空，或者显示“无标题页” 3、在测试的时候要考虑到页面出现滚动条时，滚动条上下滚动时，页面是否正常 4、URL 不区分大小写，大小写不敏感 5、对于电子商务网站，当用户并发购买数量大于库存的数量时，系统如何处理 6、测试数据避免单纯输入“123”、“abc“之类的，让测试数据尽量接近实际 7、进行测试时，尽量不要用超级管理员进行测试，用新建的用户进行测试。测试人员尽量不要使用同一个用户进行测试 8、提示信息：提示信息是否完整、正确、详细 9、帮助信息：是否提供帮助信息，帮助信息的表现形式（页面文字、提示信息、帮助文件），帮助信息是否正确、详细 10、可扩展性：是否由升级的余地，是否保留了接口 11、稳定性：运行所需的软硬件配置，占用资源情况，出现问题时的容错性，对数据的保护 12、运行速度：运行的快慢，带宽占用情况 ","link":"https://preszang.github.io/post/3W_lw6qiO/"},{"title":"一些常用的APP测试方法","content":" 记录了一些常用的 app 测试方法 一、安全测试 1.软件权限 1）扣费风险：包括短信、拨打电话、连接网络等。 2）隐私泄露风险：包括访问手机信息、访问联系人信息等。 3）对 App 的输入有效性校验、认证、授权、数据加密等方面进行检测 4）限制/允许使用手机功能接入互联网 5）限制/允许使用手机发送接收信息功能 6）限制或使用本地连接 7）限制/允许使用手机拍照或录音 8）限制/允许使用手机读取用户数据 9）限制/允许使用手机写入用户数据 10）限制/允许应用程序来注册自动启动应用程序 2.安装与卸载安全性 1）应用程序应能正确安装到设备驱动程序上 2）能够在安装设备驱动程序上找到应用程序的相应图标 3）安装路径应能指定 4）没有用户的允许，应用程序不能预先设定自动启动 5）卸载是否安全，其安装进去的文件是否全部卸载 6）卸载用户使用过程中产生的文件是否有提示 7）其修改的配置信息是否复原 8）卸载是否影响其他软件的功能 9）卸载应该移除所有的文件 3.数据安全性 1）当将密码或其它的敏感数据输入到应用程序时，其不会被存储在设备中，同时密码也不会被解码。 2）输入的密码将不以明文形式进行显示。 3）密码、信用卡明细或其他的敏感数据将不被存储在它们预输入的位置上。 4）不同的应用程序的个人身份证或密码长度必须至少在 4-8 个数字长度之间。 5）当应用程序处理信用卡明细或其它的敏感数据时，不以明文形式将数据写到其他单独的文件或者临时文件中。以防止应用程序异常终止而又没有删除它的临时文件，文件可能遭受入侵者的袭击，然后读取这些数据信息。 6）党建敏感数据输入到应用程序时，其不会被存储在设备中。 7）应用程序应考虑或者虚拟机器产生的用户提示信息或安全警告 8）应用程序不能忽略系统或者虚拟机器产生的用户提示信息或安全警告，更不能在安全警告显示前，利用显示误导信息欺骗用户，应用程序不应该模拟进行安全警告误导用户。 9）在数据删除之前，应用程序应当通知用户或者应用程序提供一个“取消”命令的操作。 10）应用程序应当能够处理当不允许应用软件连接到个人信息管理的情况。 11）当进行读或写用户信息操作时，应用程序将会向用户发送一个操作错误的提示信息。 12）在没有用户明确许可的前提下不损坏删除个人信息管理应用程序中的任何内容。 13）如果数据库中重要的数据正要被重写，应及时告知用户。 14）能合理的处理出现的错误。 15）意外情况下应提示用户。 4.通讯安全性 1）在运行软件过程中，如果有来电、SMS、蓝牙等通讯或充电时，是否能暂停程序，优先处理通信，并在处理完毕后能正常恢复软件，继续其原来的功能。 2）当创立连接时，应用程序能够处理因为网络连接中断，进而告诉用户连接中断的情况。 3）应能处理通讯延时或中断。 4）应用程序将保持工作到通讯超时，进而给用户一个错误信息指示有链接错误。 5）应能处理网络异常和及时将异常情况通报用户。 6）应用程序关闭网络连接不再使用时应及时关闭，断开。 5.人机接口安全测试 1）返回菜单应总保持可用。 2）命令有优先权顺序。 3）声音的设置不影响使用程序的功能。 4）声音的设置不影响应用程序的功能 5）应用程序必须能够处理不可预知的用户操作，例如错误的操作和同时按下多个键。 二、安装、卸载测试 验证 App 是否能正确安装、运行、卸载、以及操作过程和操作前后对系统资源的使用情况 1.安装 1）软件安装后是否能够正常运行，安装后的文件夹以及文件是否写到了指定的目录里。 2）软件安装各个选项的组合是否符合概要设计说明。 3）软件安装向导的 UI 测试 4）安装后没有生成多余的目录结构和文件。 2.卸载 1）测试系统直接卸载程序是否有提示信息。 2）测试卸载后文件是否全部删除所有的安装文件夹。 3）卸载是否支持取消功能，单击取消后软件卸载的情况。 4）系统直接卸载 UI 测试，是否有卸载状态进度条提示。 三、UI 测试 1）测试用户界面（如菜单、对话框、窗口和其他控件）布局、风格是否满足要求、文字是否正确、页面是否美观、文字、图片组合是否完美、操作是否友好等。 2）UI 测试的目标是确保用户界面会通过测试对象的功能来为用户提供相应的访问或浏览功能。确保用户界面符合公司或行业的标准。包括用户友好性、人性化、易操作性测试。 1.导航测试 1）按钮、对话框、列表和窗口等；或在不同的连接页面之间需要导航。 2）是否易于导航，导航是否直观。 3）是否需要搜索引擎。 4）导航帮助是否准确直观。 5）导航与页面结构、菜单、连接页面的风格是否一致。 2.图形测试 1）横向比较，各控件操作方式统一。 2）自适应界面设计，内容根据窗口大小自适应。 3）页面标签风格是否统一。 4）页面是否美观。 5）页面的图片应有其实际意义而要求整体有序美观。 3.内容测试 1）输入框说明文字的内容与系统功能是否一致。 2）文字长度是否加以限制。 3）文字内容是否表意不明。 4）是否有错别字。 5）信息是否为中文显示。 四、功能测试 根据软件说明或用户需求验证 App 的各个功能实现，采用如下方法实现并评估功能测试过程： 1）采用时间、地点、对象、行为和背景五元素或业务分析等方法分析、提炼 App 的用户使用场景，对比说明或需求，整理出内在、外在及非功能直接相关的需求，构建测试点，并明确测试标准。 2）根据被测功能点的特性列出相应类型的测试用例对其进行覆盖，如：设计输入的地方需要考虑等价、边界、负面、异常、非法、场景回滚、关联测试等测试类型对其进行覆盖。 3）在测试实现的各个阶段跟踪测试实现与需求输入的覆盖情况，及时修正业务或需求理解错误。 1.运行 1）App 安装完成后的试运行，可正常打开软件。 2）App 打开测试，是否有加载状态进度提示。 3）App 页面间的切换是否流畅，逻辑是否正确。 4）注册 同表单编辑页面 用户名密码长度 注册后的提示页面 前台注册页面和后台的管理页面数据是否一致 注册后，在后台管理中页面提示 5）登录 使用合法的用户登录系统 系统是否允许多次非法的登录，是否有次数限制 使用已经登录的账号登录系统是否正确处理 用户名、口令（密码）错误或漏填时能否登陆 删除或修改后的用户，原用户名登陆 不输入用户口令和重复点“确定/取消”按钮，是否允许登录 登陆后，页面中登录信息 页面中有注销按钮 登录超时的处理 2.应用的前后台切换 1）App 切换到后台，再回到 App，检查是否停留在上一次操作界面。 2）App 切换到后台，再回到 App，检查功能及应用状态是否正常。 3）App 切换到后台，再回到前台时，注意程序是否崩溃，功能状态是否正常，尤其是对于从后台切换回前台数据有自动更新的时候。 4）手机锁屏解锁后进入 App 注意是否会崩溃，功能状态是否正常，尤其是对于从后台切换回前台数据有自动更新的时候。 5）当 App 使用过程中有电话进来中断后再切换到 App，功能状态是否正常。 6）当杀掉 App 进城后，再开启 App，App 能否正常启动。 7）出现必须处理的提示框后，切换到后台，再切换回来，检查提示框是否还存在，有时候会出现应用自动跳过提示框的缺陷。 8）对于有数据交换的页面，每个页面都必须要进行前后台切换、锁屏的测试，这种页面最容易出现崩溃。 3.免登陆 很多应用提供免登陆功能，当应用开启时自动以上一次登录的用户身份来使用 App。 1）考虑无网络情况时能否正常进入免登录状态。 2）切换用户登陆后，要校验用户登录信息以及数据内容是否相应更新，确保原用户退出。 3）根据 Mtop 的现有规则，一个账户只允许登陆一台机器。所以，需要检查一个账户登录多台手机的情况。原手机里的用户需要被退出，给出友好提示。 4）App 切换到后台，在切换回前台的校验。 5）切换到后台，再切换回到前台的测试。 6）密码更换后，检查有数据交换时是否进行了有效身份的校验。 7）支持自动登录的应用在进行数据校验时，检查系统是否能自动登录成功并且数据操作无误。 8）检查用户主动退出登录后，下次启动 App，应停留在登录界面。 4.离线浏览 很多应用会支持离线浏览，即在本地客户端会缓存一部分数据供用户查看。 1）在无线网络情况可以浏览本地数据。 2）退出 App 再开启 App 时能正常浏览。 3）切换到后台再回到前台可以正常浏览。 4）锁屏后再解锁回到应用前台可以正常浏览。 5）在对服务器段的数据有更新时回给予离线的相应提示。 5.App 更新 1）当客户端有新版本时，有更新提示。 2）当版本为非强制升级版时，用户可以取消更新，老版本能正常使用。用户在下次启动 App 时，仍出现更新提示。 3）当版本为强制升级版时，但给出强制更新后用户没有做更新时，退出客户端。下次启动 App 时，仍出现强制升级提示。 4）当客户端有新版本时，在本地不删除客户端的情况下，直接更新检查是否能正常更新。 5）当客户端有新版本时，在本地不删除客户端的情况下，检查更新后的客户端功能是否是新版本。 6）当客户端有新版本时，在本地不删除客户端的情况下，检查资源同名文件如图片是否能正常更新成最新版本。如果以上无法更新成功的，也都属于缺陷。 6.定位、照相机服务 1）App 有用到相机，定位服务时，需要注意系统版本差异。 2）有用到照相机服务的地方，需要进行前后台的切换测试，检查应用是否正常。 3）测试照相机服务时，需要采用真机进行测试。 7.PUSH 测试 1）检查 Push 消息是否按照指定的业务规则发送。 2）检查不接收推送消息时，用户不会在接收到 Push 消息。 3）如果用户设置了免打扰的时间段，检查在免打扰时间段内，用户接收不到 Push。在非免打扰时间段内，用户能正常收到 Push。 4）当 Push 消息是针对登录用户的时候，需要检查收到的 Push 与用户身份是否相符，没有错误的将其他人的消息推送过来。一般情况下，只对手机上最后一个登录用户进行消息推送。 5）测试 Push 时，需要采用真机进行测试。 五、性能测试 1）响应能力测试：测试 App 中的各类操作是否满足用户响应时间要求。 App 安装、卸载的响应时间 App 各类功能性操作的响应时间 2）压力测试，反复/长期操作下，系统资源是否占用异常。 App 反复进行安装卸载，检查系统资源是否正常 其他功能反复进行操作，检查系统资源是否正常 六、交叉事件测试 针对智能终端应用的服务等级划分方式及实时特性所提出的测试方法。 交叉测试又叫事件或冲突测试，是指一个功能正在执行过程中，同时另外一个事件或操作对该过程进行干扰的测试。 如：App 在前/后台运行状态时与来电、文件下载、音乐收听等关键运用的交互情况测试等。 交叉事件测试非常重要，能发现很多应用中潜在的性能问题。 1）多个 App 同时运行是否影响正常功能。 2）App 运行时前/后台切换是否影响正常功能。 3）App 运行时拨打/接听电话。 4）App 运行时发送/接收信息。 5）App 运行时发送/收取邮件。 6）App 运行时浏览网络。 7）App 运行时使用蓝牙传送/接收数据。 8）App 运行时使用相机、计算器等手机自带设备。 七、兼容测试 主要测试内部和外部兼容性 1）与本地及主流 App 是否兼容 2）与各种设备是否兼容，若有跨系统支持则需要检验是否在个系统下，各种行为是否一致。 不同手机屏幕分标率的兼容性 不同手机品牌的兼容性 八、回归测试 1）Bug 修复后且在新版本发布后需要进行回归测试。 2）Bug 修复后的回归测试在交付前、要进行大量用例的回归测试。 九、用户体验测试 以主观的普通消费者的角度去感知产品或服务的舒适、有用、易用、友好亲切程度。通过不同个体、独立空间和非经验的统计复用方式去有效评价产品的体验特性，提出修改意见提升产品的潜在客户满意度。 1）是否有空数据界面设计，引导用户去执行操作。 2）是否滥用用户引导。 3）是否有不可点击的效果，如：你的按钮此时处于不可用状态，那么一定要灰掉，或者拿掉按钮，否则会给用户误导。 4）菜单层次是否太深。 5）交互流程分支是否太多。 6）相关的选项是否离的很远。 7）一次是否载入太多的数据。 8）界面中按钮可点击范围是否适中。 9）标签页是否跟内容没有从属关系，当切换标签的时候，内容跟着切换。 10）操作应该有主次从属关系。 11）是否定义 Back 的逻辑。涉及软硬件交互时，Back 键应具体定义。 12）是否有横屏模式的设计，应用一般需要支持横屏模式，即自适应设计。 十、手势操作测试 1）手机开锁屏对运行中的 App 的影响。 2）运行中的 App 前后台切换的影响。 3）多个运行中的 App 的切换。 4）App 运行时关机。 5）App 运行时重启系统。 6）App 运行时充电 7）App 运行时 Kill 掉进程再打开 十一、客户端数据库测试 1）一般的增、删、改、查测试。 2）当表不存在时是否能自动创建，当数据库表被删除后能否再自建，数据是否还能自动从服务器中获取回来并保存。 3）在业务需要从服务器端取回数据保存到客户端的时候，客户端能否将数据保存到本地。 4）当业务需要从客户端取数据时，检查客户端数据存在时，App 数据是否能自动从客户端数据中取出，还是仍然会从服务器端获取？检查客户端数据不存在时，App 数据能否自动从服务器端获取到并保存到服务器端。 5）当业务对数据进行了修改、删除后，客户端和服务器端是否会有相应的更新。 ","link":"https://preszang.github.io/post/ob8y4p_m4/"},{"title":"一些常用的查询功能测试方法","content":" 记录了一些常用的查询功能测试方法 一、测试方法 查询类型包含单个查询、组合查询、输入框输入查询、时间控件查询四种场景： 1、功能实现 （1）支持模糊查询搜索 （2）时间控件查询 （3）默认空查询 （4）查询后默认清空输入框记录（根据业务需求） （5）输入系统中不存在与之匹配的条件查询 2、组合查询 （1）单个查询条件。 单个条件查询切换以及单个查询、 组合查询来回切换的查询结果与错误提示 （2）组合查询条件。（正交试验法） 3、时间控件查询 起始时间、结束时间 二、主要测试点 （1）默认查询 界面 UI 规范性（输入条件与输出结果页面） 显示符合条件的数据 校对数据与页码是否匹配、总数目、每页数据条数 （2）正常查询功能 输入符合规则的查询条件，得到查询结果验证。 支持的输入字符类型、字符长度、含空格等文本域条件逐个验证 重置条件二次查询 （3）边界值查询 （等价类、边界值综合--字符长度） （4）异常查询与相关提示 非法字符控制逐个验证（不符合输入规则） 字符长度超长、过短（不符合输入规则） 错误查询的提示信息 （5）模糊查询 单个字符、多个字符、特殊字符、英文大小写搜索查询 超长字符查询 （6）查询后是否清空查询记录 （7）空查询 查询结果为空或者为全部数据。 （8）组合查询 多种不同组合条件的查询与查询结果验证。 组合查询不符合要求的错误提示。 （9）时间查询 起始时间与结束时间的逻辑判断 起始时间与结束时间内的查询结果验证 起止时间边界值校验 大月、小月、闰月、跨年、跨月、跨日查询、日期溢出查询 起止时间溢出的查询控制 （10）数据库验证 查询条件、输出结果、数据库查询验证三者必须一致。 容易遗漏的点 必填项的星号提示方向不一致问题 代码首位是 0 的情况 面包屑跳转 面包屑与一二级导航的统一 所有提示框中英文符号合理显示 列表中，一些宽度要固定 ","link":"https://preszang.github.io/post/gERkuO2Or/"},{"title":"Python Faker库常用操作 函数","content":"Python Faker 库常用操作 函数 Python Faker 库常用操作 函数 country()：国家 province()：省份 city_suffix()：市，县 district()：区 street_address()：街道地址 street_name()：街道名 street_suffix()：街、路 country_code()：国家编码 postcode()：邮编 geo_coordinate()：地理坐标 longitude()：经度 latitude()：纬度 lexify()：替换所有问号？带有随机事件 numerify()：生成三位随机数 random_digit()：生成 0~9 随机数 random_digit_not_null()：生成 1~9 的随机数 random_element()：生成随机字母 random_int()：随机数字，默认 0~9999，可通过 min,max 参数修改 random_letter()：随机字母 random_number()：随机数字，参数 digits 设置生成的数字位数 color_name()：随机颜色名 hex_color()：随机 HEX 颜色 rgb_color()：随机 RGB 颜色 safe_color_name()：随机安全色名 safe_hex_color()：随机安全 HEX 颜色 bs()：随机公司服务名 company()：随机公司名（长） company_prefix()：随机公司名（短） company_suffix()：公司性质 credit_card_expire()：随机信用卡到期日 credit_card_full()：生成完整信用卡信息 credit_card_number()：信用卡号 credit_card_provider()：信用卡类型 credit_card_security_code()：信用卡安全码 currency_code()：货币编码 am_pm()：AM/PM century()：随机世纪 date()：随机日期 date_between()：随机生成指定范围内日期，参数：start_date，end_date date_between_dates()：随机生成指定范围内日期，用法同上 date_object()：随机生产从 1970-1-1 到指定日期的随机日期。 date_this_month()： date_this_year()： date_time()：随机生成指定时间（1970 年 1 月 1 日至今） date_time_ad()：生成公元 1 年到现在的随机时间 date_time_between()：用法同 dates future_date()：未来日期 future_datetime()：未来时间 month()：随机月份 month_name()：随机月份（英文） past_date()：随机生成已经过去的日期 past_datetime()：随机生成已经过去的时间 time()：随机 24 小时时间 timedelta()：随机获取时间差 time_object()：随机 24 小时时间，time 对象 time_series()：随机 TimeSeries 对象 timezone()：随机时区 unix_time()：随机 Unix 时间 year()：随机年份 file_extension()：随机文件扩展名 file_name()：随机文件名（包含扩展名，不包含路径） file_path()：随机文件路径（包含文件名，扩展名） mime_type()：随机 mime Type ascii_company_email()：随机 ASCII 公司邮箱名 ascii_email()：随机 ASCII 邮箱 ascii_free_email()： ascii_safe_email()： company_email()： domain_name()：生成域名 domain_word()：域词(即，不包含后缀) email()： free_email()： free_email_domain()： f.safe_email()：安全邮箱 f.image_url()：随机 URL 地址 ipv4()：随机 IP4 地址 ipv6()：随机 IP6 地址 mac_address()：随机 MAC 地址 tld()：网址域名后缀 uri()：随机 URI 地址 uri_extension()：网址文件后缀 uri_page()：网址文件（不包含后缀） uri_path()：网址文件路径（不包含文件名） url()：随机 URL 地址 user_name()：随机用户名 isbn10()：随机 ISBN（10 位） isbn13()：随机 ISBN（13 位） job()：随机职位 paragraph()：随机生成一个段落 paragraphs()：随机生成多个段落，通过参数 nb 来控制段落数，返回数组 sentence()：随机生成一句话 sentences()：随机生成多句话，与段落类似 text()：随机生成一篇文章 word()：随机生成词语 words()：随机生成多个词语，用法与段落，句子，类似 binary()：随机生成二进制编码 boolean()：True/False language_code()：随机生成两位语言编码 locale()：随机生成语言/国际 信息 md5()：随机生成 MD5 null_boolean()：NULL/True/False password()：随机生成密码,可选参数：length：密码长度；special_chars：是否能使用特殊字符；digits：是否包含数字 upper_case：是否包含大写字母；lower_case：是否包含小写字母 sha1()：随机 SHA1 sha256()：随机 SHA256 uuid4()：随机 UUID first_name()： first_name_female()：女性名 first_name_male()：男性名 first_romanized_name()：罗马名 last_name()： last_name_female()：女 last_name_male()：男 last_romanized_name()： name()：随机生成姓名 name_female()：男性姓名 name_male()：女性姓名 romanized_name()：罗马名 msisdn()：移动台国际用户识别码，即移动用户的 ISDN 号码 phone_number()：随机生成手机号 phonenumber_prefix()：随机生成手机号段 profile()：随机生成档案信息 simple_profile()：随机生成简单档案信息 pybool()： pydecimal()： pydict()： pyfloat()：left_digits=2 #生成的整数位数, right_digits=1 #生成的小数位数, positive=True #是否只有正数 pyint()： pyiterable() pylist() pyset() pystr() pystruct() pytuple() ssn()：生成身份证号 chrome()：随机生成 Chrome 的浏览器 user_agent 信息 firefox()：随机生成 FireFox 的浏览器 user_agent 信息 internet_explorer()：随机生成 IE 的浏览器 user_agent 信息 opera()：随机生成 Opera 的浏览器 user_agent 信息 safari()：随机生成 Safari 的浏览器 user_agent 信息 linux_platform_token()：随机 Linux 信息 user_agent()：随机 user_agent 信息 ","link":"https://preszang.github.io/post/K6Iq63FrK/"},{"title":"使用yagmail发送邮件，就几行代码","content":" yagmail可以更简单的来实现自动发邮件功能。 github项目地址: https://github.com/kootenpv/yagmail 安装 pip install yagmail 简单例子 import yagmail # 链接邮箱服务器 yag = yagmail.SMTP(user=&quot;user@126.com&quot;, password=&quot;1234&quot;, host='smtp.126.com') #邮箱正文 contents = ['This is the body, and here is just text http://somedomain/image.png', 'You can find an audio file attached.', '/local/path/song.mp3'] # 发送邮件 yag.send('taaa@126.com', 'subject', contents) # 给多个用户发送邮件 只需要将接收邮箱 变成一个list即可。 yag.send(['aa@126.com','bb@qq.com','cc@gmail.com'], 'subject', contents) # 发送带附件的邮件只需要添加要发送的附件列表即可。 yag.send('aaaa@126.com', '发送附件', contents, [&quot;d://log.txt&quot;,&quot;d://baidu_img.jpg&quot;]) ","link":"https://preszang.github.io/post/8CoDqKwKu/"},{"title":"Python 调用钉钉和企业微信机器人发送消息","content":"Python 调用钉钉和企业企业微信机器人发送消息 企业微信 在终端某个群组添加机器人之后，可以获取到webhook地址，然后开发者用户按以下说明构造post data向这个地址发起HTTP POST 请求，即可实现给该群组发送消息。特别特别要注意：一定要保护好机器人的webhook地址，避免泄漏！ 以下是用 python 往群组推送文本消息的示例（注意要将url 替换成你的机器人webhook地址）： import json import requests # 向企业微信机器人发消息 def sendQyWechat(msg): token = '这是token' url = f'https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key={token}' data = {&quot;msgtype&quot;: &quot;text&quot;, &quot;text&quot;: {&quot;content&quot;: msg}} res = requests.post(url, json.dumps(data)) res.encoding = 'utf-8' return res.text 当前自定义机器人支持文本（text）、markdown（markdown）两种消息类型。 每个机器人发送的消息不能超过 20 条/分钟。 消息类型和数据格式 文本类型 { &quot;msgtype&quot;: &quot;text&quot;, &quot;text&quot;: { &quot;content&quot;: &quot;广州今日天气：29度，大部分多云，降雨概率：60%&quot;, &quot;mentioned_list&quot;: [&quot;wangqing&quot;, &quot;@all&quot;], &quot;mentioned_mobile_list&quot;: [&quot;13800001111&quot;, &quot;@all&quot;] } } 参数 是否必填 说明 msgtype 是 消息类型，此时固定为text content 是 文本内容，最长不超过 2048 个字节，必须是utf8编码 mentioned_list 否 userid的列表，提醒群中的指定成员(@某个成员)，@all 表示提醒所有人，如果开发者获取不到userid，可以使用mentioned_mobile_list mentioned_mobile_list 否 手机号列表，提醒手机号对应的群成员(@某个成员)，@all 表示提醒所有人 markdown 类型 { &quot;msgtype&quot;: &quot;markdown&quot;, &quot;markdown&quot;: { &quot;content&quot;: &quot;实时新增用户反馈&lt;font color=\\&quot;warning\\&quot;&gt;132例&lt;/font&gt;，请相关同事注意。\\n &gt;类型:&lt;font color=\\&quot;comment\\&quot;&gt;用户反馈&lt;/font&gt; \\n &gt;普通用户反馈:&lt;font color=\\&quot;comment\\&quot;&gt;117例&lt;/font&gt; \\n &gt;VIP用户反馈:&lt;font color=\\&quot;comment\\&quot;&gt;15例&lt;/font&gt;&quot; } } 参数 是否必填 说明 msgtype 是 消息类型，此时固定为markdown content 是 markdown内容，最长不超过 4096 个字节，必须是utf8编码 目前支持的 markdown 语法是如下的子集： 标题 （支持 1 至 6 级标题，注意#与文字中间要有空格） # 标题一 ## 标题二 ### 标题三 #### 标题四 ##### 标题五 ###### 标题六 加粗 **bold** 链接 [这是一个链接](http://work.weixin.qq.com/api/doc) 行内代码段（暂不支持跨行） `code` 引用 &gt; 引用文字 字体颜色(只支持 3 种内置颜色) &lt;font color=&quot;info&quot;&gt;绿色&lt;/font&gt; &lt;font color=&quot;comment&quot;&gt;灰色&lt;/font&gt; &lt;font color=&quot;warning&quot;&gt;橙红色&lt;/font&gt; 图片类型 { &quot;msgtype&quot;: &quot;image&quot;, &quot;image&quot;: { &quot;base64&quot;: &quot;DATA&quot;, &quot;md5&quot;: &quot;MD5&quot; } } 参数 是否必填 说明 msgtype 是 消息类型，此时固定为 image base64 是 图片内容的base64编码 md5 是 图片内容（base64编码前）的md5值 注：图片（base64编码前）最大不能超过2M，支持JPG,PNG格式 图文类型 { &quot;msgtype&quot;: &quot;news&quot;, &quot;news&quot;: { &quot;articles&quot;: [ { &quot;title&quot;: &quot;中秋节礼品领取&quot;, &quot;description&quot;: &quot;今年中秋节公司有豪礼相送&quot;, &quot;url&quot;: &quot;URL&quot;, &quot;picurl&quot;: &quot;http://res.mail.qq.com/node/ww/wwopenmng/images/independent/doc/test_pic_msg1.png&quot; } ] } } 参数 是否必填 说明 msgtype 是 消息类型，此时固定为 news articles 是 图文消息，一个图文消息支持 1 到 8 条图文 title 是 标题，不超过 128 个字节，超过会自动截断 description 否 描述，不超过 512 个字节，超过会自动截断 url 是 点击后跳转的链接。 picurl 否 图文消息的图片链接，支持JPG、PNG格式，较好的效果为大图 1068455，小图 150150。 钉钉 获取自定义机器人``webhook` 在机器人管理页面选择“自定义”机器人，输入机器人名字并选择要发送消息的群，同时可以为机器人设置机器人头像。 完成必要的安全设置（至少选择一种），勾选 我已阅读并同意《自定义机器人服务及免责条款》，点击“完成”。安全设置目前有3种方式，设置说明见下文介绍。 完成安全设置后，复制出机器人的Webhook地址，可用于向这个群发送消息 import json import requests # 向钉钉机器人发消息(安全设置为加签) def sendDingDing(msg): token = '这是token' timeStamp, sign = makeDingDingRobotSign() url = f'https://oapi.dingtalk.com/robot/send?access_token={token}&amp;timestamp={timeStamp}&amp;sign={sign}' headers = {'Content-Type': 'application/json'} data = {&quot;msgtype&quot;: &quot;text&quot;, &quot;text&quot;: {&quot;content&quot;: msg}} res = requests.post(url, json.dumps(data), headers=headers) res.encoding = 'utf-8' return res.text 安全设置 安全设置目前有3种方式： 方式一，自定义关键词 最多可以设置10个关键词，消息中至少包含其中1个关键词才可以发送成功。 例如：添加了一个自定义关键词：监控报警 则这个机器人所发送的消息，必须包含 监控报警 这个词，才能发送成功。 方式二，加签 把timestamp+&quot;\\n&quot;+密钥当做签名字符串，使用HmacSHA256算法计算签名，然后进行Base64 encode，最后再把签名参数再进行urlEncode，得到最终的签名（需要使用UTF-8字符集）。 参数 说明 timestamp 当前时间戳，单位是毫秒，与请求调用时间误差不能超过1小时 secret 密钥，机器人安全设置页面，加签一栏下面显示的SEC开头的字符串 python3生成签名和时间戳示例 import base64 import hashlib import hmac import time import urllib # 生成钉钉机器人的签名和时间戳 def makeDingDingRobotSign(): signKey = '这是secret' timeStamp = int(round(time.time() * 1000)) key = signKey.encode(&quot;utf-8&quot;) preSignStr = f'{timeStamp}\\n{signKey}'.encode(&quot;utf-8&quot;) hmacStr = hmac.new(key, preSignStr, digestmod=hashlib.sha256).digest() base64Str = base64.b64encode(hmacStr) sign = urllib.parse.quote_plus(base64Str) return timeStamp, sign 把timestamp和第一步得到的签名值拼接到URL中。 参数 说明 timestamp 第一步使用到的时间戳 sign 第一步得到的签名值 方式三，IP地址（段） 设定后，只有来自IP地址范围内的请求才会被正常处理。支持两种设置方式：IP、IP段，暂不支持IPv6地址白名单，格式如下: 注意：安全设置的上述三种方式，需要至少设置其中一种，以进行安全保护。校验不通过的消息将会发送失败，错误如下： //消息内容中不包含任何关键词 { &quot;errcode&quot;: 310000, &quot;errmsg&quot;: &quot;keywords not in content&quot; } //timestamp 无效 { &quot;errcode&quot;: 310000, &quot;errmsg&quot;: &quot;invalid timestamp&quot; } //签名不匹配 { &quot;errcode&quot;: 310000, &quot;errmsg&quot;: &quot;sign not match&quot; } //IP地址不在白名单 { &quot;errcode&quot;: 310000, &quot;errmsg&quot;: &quot;ip X.X.X.X not in whitelist&quot; } 消息类型及数据格式 text类型 { &quot;msgtype&quot;: &quot;text&quot;, &quot;text&quot;: { &quot;content&quot;: &quot;我就是我, 是不一样的烟火@156xxxx8827&quot; }, &quot;at&quot;: { &quot;atMobiles&quot;: [&quot;156xxxx8827&quot;, &quot;189xxxx8325&quot;], &quot;isAtAll&quot;: false } } 参数 参数类型 必须 说明 msgtype String 是 消息类型，此时固定为：text content String 是 消息内容 atMobiles Array 否 被@人的手机号(在content里添加@人的手机号) isAtAll bool 否 @所有人时：true，否则为：false link类型 { &quot;msgtype&quot;: &quot;link&quot;, &quot;link&quot;: { &quot;text&quot;: &quot;这个即将发布的新版本，创始人xx称它为“红树林”。 而在此之前，每当面临重大升级，产品经理们都会取一个应景的代号，这一次，为什么是“红树林”？&quot;, &quot;title&quot;: &quot;时代的火车向前开&quot;, &quot;picUrl&quot;: &quot;&quot;, &quot;messageUrl&quot;: &quot;https://www.dingtalk.com/s?__biz=MzA4NjMwMTA2Ng==&amp;mid=2650316842&amp;idx=1&amp;sn=60da3ea2b29f1dcc43a7c8e4a7c97a16&amp;scene=2&amp;srcid=09189AnRJEdIiWVaKltFzNTw&amp;from=timeline&amp;isappinstalled=0&amp;key=&amp;ascene=2&amp;uin=&amp;devicetype=android-23&amp;version=26031933&amp;nettype=WIFI&quot; } } 参数 参数类型 必须 说明 msgtype String 是 消息类型，此时固定为：link title String 是 消息标题 text String 是 消息内容。如果太长只会部分展示 messageUrl String 是 点击消息跳转的URL picUrl String 否 图片URL markdown类型 { &quot;msgtype&quot;: &quot;markdown&quot;, &quot;markdown&quot;: { &quot;title&quot;: &quot;杭州天气&quot;, &quot;text&quot;: &quot;#### 杭州天气 @156xxxx8827\\n&quot; + &quot;&gt; 9度，西北风1级，空气良89，相对温度73%\\n\\n&quot; + &quot;&gt; ![screenshot](https://gw.alicdn.com/tfs/TB1ut3xxbsrBKNjSZFpXXcXhFXa-846-786.png)\\n&quot; + &quot;&gt; ###### 10点20分发布 [天气](http://www.thinkpage.cn/) \\n&quot; }, &quot;at&quot;: { &quot;atMobiles&quot;: [&quot;156xxxx8827&quot;, &quot;189xxxx8325&quot;], &quot;isAtAll&quot;: false } } 参数 类型 必选 说明 msgtype String 是 此消息类型为固定markdown title String 是 首屏会话透出的展示内容 text String 是 markdown格式的消息 atMobiles Array 否 被@人的手机号(在text内容里要有@手机号) isAtAll bool 否 @所有人时：true，否则为：false 说明：目前只支持md语法的子集，具体支持的元素如下 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 &gt; A man who stands for nothing will fall for anything. **bold** *italic* [this is a link](http://name.com) ![](http://name.com/pic.jpg) - item1 - item2 1. item1 2. item2 整体跳转ActionCard类型 { &quot;actionCard&quot;: { &quot;title&quot;: &quot;乔布斯 20 年前想打造一间苹果咖啡厅，而它正是 Apple Store 的前身&quot;, &quot;text&quot;: &quot;![screenshot](@lADOpwk3K80C0M0FoA) ### 乔布斯 20 年前想打造的苹果咖啡厅 Apple Store 的设计正从原来满满的科技感走向生活化，而其生活化的走向其实可以追溯到 20 年前苹果一个建立咖啡馆的计划&quot;, &quot;hideAvatar&quot;: &quot;0&quot;, &quot;btnOrientation&quot;: &quot;0&quot;, &quot;singleTitle&quot;: &quot;阅读全文&quot;, &quot;singleURL&quot;: &quot;https://www.dingtalk.com/&quot; }, &quot;msgtype&quot;: &quot;actionCard&quot; } 参数 类型 必选 说明 msgtype string true 此消息类型为固定actionCard title string true 首屏会话透出的展示内容 text string true markdown格式的消息 singleTitle string true 单个按钮的方案。(设置此项和singleUR后btns无效) singleURL string true 点击singleTitle按钮触发的URL btnOrientation string false 0-按钮竖直排列，1-按钮横向排列 hideAvatar string false 0-正常发消息者头像，1-隐藏发消息者头像 通过整体跳转ActionCard类型消息发出的消息样式如下： 独立跳转ActionCard类型 { &quot;actionCard&quot;: { &quot;title&quot;: &quot;乔布斯 20 年前想打造一间苹果咖啡厅，而它正是 Apple Store 的前身&quot;, &quot;text&quot;: &quot;![screenshot](@lADOpwk3K80C0M0FoA)### 乔布斯20 年前想打造的苹果咖啡厅Apple Store的设计正从原来满满的科技感走向生活化，而其生活化的走向其实可以追溯到 20 年前苹果一个建立咖啡馆的计划&quot;, &quot;hideAvatar&quot;: &quot;0&quot;, &quot;btnOrientation&quot;: &quot;0&quot;, &quot;btns&quot;: [{ &quot;title&quot;: &quot;内容不错&quot;, &quot;actionURL&quot;: &quot;https://www.dingtalk.com/&quot; }, { &quot;title&quot;: &quot;不感兴趣&quot;, &quot;actionURL&quot;: &quot;https://www.dingtalk.com/&quot; }] }, &quot;msgtype&quot;: &quot;actionCard&quot; } 参数 类型 必选 说明 msgtype string true 此消息类型为固定actionCard title string true 首屏会话透出的展示内容 text string true markdown格式的消息 btns array true 按钮的信息：title-按钮方案，actionURL-点击按钮触发的URL btnOrientation string false 0-按钮竖直排列，1-按钮横向排列 hideAvatar string false 0-正常发消息者头像，1-隐藏发消息者头像 通过独立跳转ActionCard类型消息发出的消息样式如下： FeedCard类型 { &quot;feedCard&quot;: { &quot;links&quot;: [{ &quot;title&quot;: &quot;时代的火车向前开&quot;, &quot;messageURL&quot;: &quot;https://www.dingtalk.com/s?__biz=MzA4NjMwMTA2Ng==&amp;mid=2650316842&amp;idx=1&amp;sn=60da3ea2b29f1dcc43a7c8e4a7c97a16&amp;scene=2&amp;srcid=09189AnRJEdIiWVaKltFzNTw&amp;from=timeline&amp;isappinstalled=0&amp;key=&amp;ascene=2&amp;uin=&amp;devicetype=android-23&amp;version=26031933&amp;nettype=WIFI&quot;, &quot;picURL&quot;: &quot;https://www.dingtalk.com/&quot; }, { &quot;title&quot;: &quot;时代的火车向前开2&quot;, &quot;messageURL&quot;: &quot;https://www.dingtalk.com/s?__biz=MzA4NjMwMTA2Ng==&amp;mid=2650316842&amp;idx=1&amp;sn=60da3ea2b29f1dcc43a7c8e4a7c97a16&amp;scene=2&amp;srcid=09189AnRJEdIiWVaKltFzNTw&amp;from=timeline&amp;isappinstalled=0&amp;key=&amp;ascene=2&amp;uin=&amp;devicetype=android-23&amp;version=26031933&amp;nettype=WIFI&quot;, &quot;picURL&quot;: &quot;https://www.dingtalk.com/&quot; }] }, &quot;msgtype&quot;: &quot;feedCard&quot; } 参数 类型 必选 说明 msgtype string true 此消息类型为固定feedCard title string true 单条信息文本 messageURL string true 点击单条信息到跳转链接 picURL string true 单条信息后面图片的URL 通过FeedCard类型消息发出的消息样式如下： ","link":"https://preszang.github.io/post/8iH4xT1qu/"},{"title":" 一个测试dubbo接口的小工具","content":"测试dubbo接口的小工具 flask+kazoo+telnet kazoo是一个Python库，旨在使得Python能够轻松、便捷的使用zookeeper。 Flask是一个使用 Python 编写的轻量级 Web 应用框架。 从 2.0.5 版本开始，dubbo 开始支持通过 telnet 命令来进行服务治理。 一、启动说明 git clone https://gitee.com/prestest/dubboTestTool 修改配置文件[config.py] config = { 'zooKeeper': [ # 需要替换zk的地址 'zk.xxx.cn:2181' ], 'robot': { # status的状态表示是否发送消息 'dingTalk': { 'status': False, # 需要替换钉钉的签名key 'signKey': '[需要替换钉钉的签名key]', # 需要替换钉钉的webhook_key 'token': '[需要替换钉钉的webhook_key]' }, 'qyWechat': { 'status': False, # 需要替换企业微信的webhook_key 'token': '[需要替换企业微信的webhook_key]' } } 安装第三方库 # flask、kazoo、requests pip install -r requirements.txt 启动方式 python run.py 打开网页 localhost:5000 # 默认端口为5000，可在`run.py`中修改 app.run(host='0.0.0.0', port=5000, debug=True) 二、在页面上请求 选择需要测试的ServiceAPI，可模糊搜索，点击搜索。 出现方法列表后，选择要测试的Method，可模糊搜索 输入相应参数 具体参数要求内容可向研发咨询或查看代码或者接口文档。 参数顺序必须与接口的参数顺序保持一致 如 接口为 Method(String userid,Integer number)，则只需输入参数为 &quot;userid1&quot;,456 当参数为Map&lt;Integer,T&gt;，key的类型为Integer时，建议指定类型&quot;class&quot;:&quot;java.util.HashMap&quot; 当类型转换失败的时候，可以通过增加class属性指定需要转换类，类的路径查看代码或者向研发询问即可 { &quot;name&quot;:&quot;zhangsan&quot;, &quot;age&quot;:12, &quot;class&quot;:&quot;org.apache.dubbo.qos.legacy.service.Person&quot; } 需要测试其他api，则需要重新打开页面或者，点击左上角的刷新按钮。 三、以http的方式调用 可以在postman中发起http请求，去调用dubbo接口。将常用的请求通过postman保存下来，或者其他方式使用 请求方式：get/post 参数请求格式：raw ，参数用逗号隔开。或者直接在地址后追加原始参数 地址：http://localhost:5000/d2h/{service}/{method} ","link":"https://preszang.github.io/post/KST7ZTnOT/"},{"title":"解决  No module named 'pip'","content":"问题再现 今天 安装其它python包时，莫名报了这个错 Traceback (most recent call last): File &quot;d:\\program files\\python38\\lib\\runpy.py&quot;, line 194, in _run_module_as_main return _run_code(code, main_globals, None, File &quot;d:\\program files\\python38\\lib\\runpy.py&quot;, line 87, in _run_code exec(code, run_globals) File &quot;D:\\Program Files\\python38\\Scripts\\pip.exe\\__main__.py&quot;, line 5, in &lt;module&gt; ModuleNotFoundError: No module named 'pip' 解决方案 python -m ensurepip python -m pip install --upgrade pip 若第二步 更新太慢可更换软件源 python -m pip install --upgrade pip -i https://pypi.tuna.tsinghua.edu.cn/simple/ 问题解决 Downloading https://pypi.tuna.tsinghua.edu.cn/packages/5a/4a/39400ff9b36e719bdf8f31c99fe1fa7842a42fa77432e584f707a5080063/pip-20.2.2-py2.py3-none-any.whl (1.5MB) |████████████████████████████████| 1.5MB 130kB/s Installing collected packages: pip Found existing installation: pip 19.2.3 Uninstalling pip-19.2.3: Successfully uninstalled pip-19.2.3 Successfully installed pip-20.2.2 pip -V pip 20.2.2 from d:\\program files\\python38\\lib\\site-packages\\pip (python 3 ","link":"https://preszang.github.io/post/CmAoWM_xt/"},{"title":"在pypi上发布python包","content":"在pypi上发布python包 一、注册账号 到pypi（https://pypi.org/）上注册自己的用户, 点击“Register”，填写自己的用户名，密码，邮箱。 如果期望测试发布，同时需要注册pypitest账号（可以采用相同的用户名和密码）。pypitest官网：https://test.pypi.org/ 二、准备setup 文件 准备setup.py文件，它是放在你包的根目录的，这一步至关重要，包括要发布的包名字，版本，license，描述，特性（classifier)等等。 下面是setup.py文件的示例内容，基本上只需要在这个上面修改就行了，具体如下： #!/usr/bin/env python # coding:utf-8 from setuptools import find_packages, setup setup( name='&lt;项目的名称&gt;', version='&lt;项目的版本&gt;', description='&lt;项目的简单描述&gt;', long_description=open('README.rst').read(), author='&lt;项目的作者&gt;', author_email='&lt;作者邮箱&gt;', maintainer='&lt;维护人员的名字&gt;', maintainer_email='&lt;维护人员的邮箱&gt;', packages=find_packages(), platforms=[&quot;all&quot;], url='&lt;项目的网址，可以使用自己github的url&gt;', license='BSD License', classifiers=[ 'Development Status :: 4 - Beta', 'Operating System :: OS Independent', 'Intended Audience :: Developers', 'License :: OSI Approved :: BSD License', 'Programming Language :: Python', 'Programming Language :: Python :: 2.7', 'Programming Language :: Python :: Implementation :: CPython', 'Programming Language :: Python :: Implementation :: PyPy' ], ) version：这个简单，就是包的发布的版本，可以直接写在这，也可以从其他地方引用过来。 long_description：必须是rst（reStructuredText )格式的，因为这个里面的内容是显示在pypi包首页上 packages：申明你的包里面要包含的目录 install_requires：申明依赖包，安装包时pip会自动安装 大名鼎鼎的requests库的作者大神kennethreitz为大家准备了一个仓库作为一个setup.py的很好的模板，当然你也可以自己手写setup.py。 git clone https://github.com/kennethreitz/setup.py 三、最终的代码结构 │ LICENSE │ MANIFEST.in │ README.rst │ setup.py │ └─condition_chain core.py __init__.py __version__.py 四、编写核心代码 接下来我们就可以编写自己的代码了，要注意源代码文件夹（仓库里的my_package文件夹）的名字与setup.py里配置的包名（Name）要一致。 另外在重新上传之前我们要修改__version__.py里的版本号，以免覆盖了以前的上传（相信会有人是需要之前版本的库的）。 五、打包上传 打包一个wheels格式的包，使用下面的命令搞定： python setup.py bdist_wheel --universal 上传生成的包，可以使用twine上传 pip install twine twine upload dist/* 会提示你前面注册的用户名和密码。一切搞定，你的包现在可以通过pip在任何地方安装了。 六、报错解决 1.HTTPError: 403 Client Error: The user 'xxx' isn't allowed to upload to project '&lt;项目的名称&gt;'. See https://pypi.org/help/#project-name for more information. for url: https://upload.pypi.org/legacy/ 出现这个报错一般是python包名冲突，换个包名就可以了 2.HTTPError: 403 Client Error: Invalid or non-existent authentication information. for url: https://upload.pypi.org/legacy/ 出现这个报错一般是用户名和密码错误了，要去网站上验证一下你前面注册的用户名和密码。 ","link":"https://preszang.github.io/post/jyh3VyyYn/"},{"title":"selenium之破解腾讯滑块验证码","content":"selenium之破解腾讯滑块验证码 就是图中的这种滑块验证码 先贴源码，基本思路就是 用PIL，然后对比 验证码图片 有缺口和无缺口的不同，计算出偏移量，模拟滑块滑动。 import time import random import io from PIL import Image from urllib.request import urlopen from selenium.webdriver.common.action_chains import ActionChains def openImgUrl(src): # 打开图片链接 ImgUrl = urlopen(src, timeout=1).read() img = Image.open(io.BytesIO(ImgUrl)) # 恢复原始大小 imgResize = (int(i // 2) for i in img.size) return img.resize(imgResize, Image.ANTIALIAS) def getImg(dr): dr.switch_to.frame('tcaptcha_iframe') src1 = dr.find_element_by_id('slideBg').get_attribute('src') src2 = src1.replace('img_index=1', 'img_index=0') return openImgUrl(src1), openImgUrl(src2) # 比较两张图片同一点上的像数值，差距大于设置标准返回False def isPixel(img1, img2, x, y): i = 100 px1, px2 = img1.load()[x, y], img2.load()[x, y] r, g, b = [abs(p1 - p2) for p1, p2 in zip(px1, px2)] return True if r &lt; i and g &lt; i and b &lt; i else False # 获取缺口的偏移量，两张图片对比,(i,j)像素点的RGB差距，过大则该x为偏移值 def getOffset(img1, img2): offset, distance = None, 70 x, y = img1.size for i in range(distance, x): for j in range(y): if not isPixel(img1, img2, i, j): offset = i return offset return offset # 计算滑块的移动轨迹 滑块并不是从0开始移动，有一个初始值 def getTrack(offset): offset -= 30 return [offset / 4] * 4 # 模拟释放鼠标抖动 def shake(dr): ActionChains(dr).move_by_offset(xoffset=-2, yoffset=0).perform() ActionChains(dr).move_by_offset(xoffset=2, yoffset=0).perform() time.sleep(random.random()) # 按轨迹移动 def move(dr, track): for i in track: ActionChains(dr).move_by_offset(xoffset=i, yoffset=0).perform() time.sleep(random.random() / 100) time.sleep(random.random()) # 完成拖动操作 def sliderBtn(dr, track): btn = dr.find_element_by_id('tcaptcha_drag_thumb') ActionChains(dr).click_and_hold(btn).perform() # 按住按钮不放 move(dr, track) # 按正向轨迹移动 move(dr, [-1, -0.5, -1]) # 按逆向轨迹移动 shake(dr) # 模拟人手抖动 ActionChains(dr).release().perform() # 松开滑块按钮 # 处理验证码 def dealCaptcha(dr): time.sleep(3) img1, img2 = getImg(dr) offset = getOffset(img1, img2) track = getTrack(offset) sliderBtn(dr, track) 基于selenium的webdriver from selenium import webdriver if __name__ == '__main__': dr = webdriver.Chrome('chromedriver的地址') dealCaptcha(dr) ","link":"https://preszang.github.io/post/VseyNxd0Y/"},{"title":"2020 年最热的 Python 库年度 Top 10 ","content":"1、Typer Typer 跟 FastAPI 的原理相同，都是 Python 上用来构建 API 服务的一个高性能框架。 它是 FastAPI 的升级版，不仅能够准确地记录代码，还能够轻松地进行 CLI 验证。 Typer 易于学习和使用，不需要用户阅读复杂的教程文档即可上手。支持编辑器（如 VSCode）代码自动补全，提高开发人员的开发效率，减少 bug 的数量。 其次，Typer 还能配合命令行神器 Click 使用，就可以利用 Click 的优点和插件，实现更复杂的功能。 开源地址：https://github.com/tiangolo/typer 2、Rich 谁规定 CLI 界面一定得是黑白的？它也可以是彩色的。 Rich API 不仅能够在终端输出提供丰富的彩色文本和精美的格式，还提供了精美的表格、进度条、编辑器、追踪器、语法高亮等。如下图所示。 它还可以安装在 Python REPL 上，所有的数据结构都可以漂亮地输出或标注。 总而言之，它是彩色的、漂亮的、强大的。 Rich 兼容性也不错，适用于 Linux，Mac 和 Windows 等多种系统。真彩色/表情符号可与新的 Windows 终端一起使用。 但是请注意，Rich 必须要 Python 3.6.1 或以上版本。 开源地址：https://github.com/willmcgugan/rich 3、Dear PyGui 如上所示，虽然终端应用程序可以做成很漂亮的样子。但是，你可能还需要一个真正的 GUI。 Dear PyGui 是一个便于使用、功能强大的 Python GUI 框架。但是它与其他的 Python GUI 却有着根本上的不同。 它使用了即时模式范式和计算机的 GPU 来实现动态界面。即时模式范式在视频游戏中非常流行，这意味着它的动态 GUI 不需要保留任何数据，而是逐帧独立绘制的。同时，它还使用 GPU 来建构动态界面。 Dear PyGui 还可以绘图、创建主题、创建 2D 游戏，还拥有一些小工具，比如说内置文档、日志记录、源代码查看器之类的，这些小工具可以协助 App 的开发。 支持它的系统有：Windows 10（DirectX 11），Linux（OpenGL 3）和 macOS（Metal）等。 开源地址：https://github.com/hoffstadt/DearPyGui 4、PrettyErrors PrettyErrors 是一个精简 Python 错误信息的工具，特点是界面十分简洁友好。 它最显著的功能是支持在终端进行彩色输出，标注出文件栈踪迹，发现错误信息，过滤掉冗余信息，提取出关键部分，并且进行彩色标注，从而提高开发者的效率。 而且它可以不用安装，直接被导入项目中使用，但是需要先配置一些参数，其导入和配置的参数如下： 开源地址：https://github.com/onelivesleft/PrettyErrors 5、Diagrams 程序员在编程的时候，有时候需要跟同事解释他设计的程序代码之间复杂的结构关系，然而这不是一两句话能说清楚的，需要画表或者做脉络图。 一般情况下，程序员使用 GUI 工具处理图表，并将文稿进行可视化处理。但是还有更好的方法，比如说使用 Diagrams 库。 Diagrams 让不需要任何设计类工具，直接在 Python 代码中绘制云系统结构。它们的图标来自多家云服务商，包括 AWS, Azure, GCP 等。 仅需几行代码，就可以简单地创造出箭头符号和结构图。 由于它使用 Graphviz 来渲染图，所以还需要先安装好 Graphviz。 开源地址：https://github.com/mingrammer/diagrams 6、Hydra and OmegaConf 在做机器学习项目的时候，需要做一大堆的环境配置工作。因此，在一些复杂的应用程序中，配置管理工作也相应变得复杂。 Hydra 可以使配置工作变得简单。它能够从命令行或者配置文件中覆盖部分出来，无需维护相似的配置文件，用组合的方式进行配置，从而加快了实验运行速度。 Hydra 兼容性强，拥有含插件的结构，能够很好地与开发者的操作文件融合。它的插件还可以实现直接通过命令行，就把代码发布到 AWS 或者其他云端系统。 Hydra 也离不开 OmegaConf，两者关系密不可分，OmegaConf 为 Hydra 的分层配置系统提供了协同的 API，二者协同运作可支持 YAML、配置文件、对象、CLI 参数等。 开源地址：https://github.com/facebookresearch/hydra 开源地址：https://github.com/omry/omegaconf 7、PyTorch Lightning PyTorch Lightning 也是 Facebook 的一个研究成果。它是一个轻巧的 PyTorch 包装器，用于高性能 AI 研究，其最重要的特征是能够解析 PyTorch代码，让代码研究成分和工程成分的分离。 它的扩展模型可以在任何硬件（CPU、GPU、TPU）上运行，且容易被复制，删除了大量的文件样本，保持了自身的灵活性，运行速度快。 Lightning 能够使 DL / ML 研究的 40 多个部分实现自动化，例如 GPU训练、分布式 GPU（集群）训练、TPU 训练等等…… 因为 Lightning 将可以将文件自动导出到 ONNX 或T orchScript，所以它适用于进行快速推理的 AI 研究员、BERT 或者自监督学习的研究团队等。 开源地址：https://github.com/PyTorchLightning/PyTorch-lightning 8、Hummingbird Hummingbird 是微软的一项研究成果，它能够将已经训练好的 ML 模型汇编成张量计算，从而不需要设计新的模型。 还允许用户使用神经网络框架（例如 PyTorch）来加速传统的 ML 模型。 它的推理 API 跟 sklearn 范例十分相似，都可以重复使用现有的代码，但是它是用 Hummingbird 生成的代码去实现的。 Hummingbird 还在 Sklearn API 之后提供了一个方便的统一推理API。这样就可以将 Sklearn 模型与 Hummingbird 生成的模型互换，而无需更改推理代码。 它之所以被重点关注，还因为它能够支持多种多样的模型和格式。 到目前为止，Hummingbird 支持 PyTorch、TorchScript、ONNX 和 TVM 等各种 ML 模型。 开源地址：https://github.com/microsoft/hummingbird 9、HiPlot 由于 ML 模型变得越来越复杂，还有很多超参数，于是就需要用到 HiPlot。HiPlot 是今年 3 月 Facebook 发行的一个库，主要用于处理高维数据。 Facebook AI 通过几十个超参数和 10 万多个实验，利用 HiPlot，来分析深度神经网络。 它是用平行图和其他的图像方式，帮助AI研究者发现高维数据的相关性和模型，是一款轻巧的交互式可视化工具。 HiPlot 与其他可视化工具相比，有其特有的优点： 首先，它的互动性强，因为平行图是交互式的，所以能够满足多种情况下的图像可视化。 其次，它简单易用，可以通过 IPython Notebook 或者通过带有“ hiplot”命令的服务直接使用。 它还有具有可扩展性。默认情况下，HiPlot 的 Web 服务可以解析 CSV 或 JSON 文件，还可以为其提供自定义 Python 解析器，将实验转换为 HiPlot 实验。 开源地址：https://github.com/facebookresearch/hiplot 参考链接：https://ai.facebook.com/blog/hiplot-high-dimensional-interactive-plots-made-easy 10、Scalene Scalene 是一个用于 Python 脚本的 CPU 和内存分析器，能够正确处理多线程代码，还能区分 Python 代码和本机代码的运行时间。 你不需要修改代码，只需运行 Scalene 脚本，它就会生成一个文本形式的报告，显示出每一行代码的 CPU 和内存的使用情况。通过这个文本报告，开发人员可以提高代码的效率。 Scalene 的速度快、准确率高，还能够对高耗能的代码行进行标注。 开源地址https://github.com/emeryberger/scalene 除了以上 10 个，还有多个高性能的 Python 库被点名了，例如 Norfair、Quart、Alibi-detect、Einops……等等。 那么，你今年有发现好用的 Python 库吗？ 参考链接：https://tryolabs.com/blog/2020/12/21/top-10-python-libraries-of-2020/ 参考链接：https://www.upgrad.com/blog/reasons-why-python-popular-with-developers/ ","link":"https://preszang.github.io/post/eeYWta-p7/"},{"title":"python+selenium自动化UI测试基本教程","content":"一、安装selenium 1. 安装python 打开 Python官网，找到Download, 安装最新版python，python 的安装方法再此不详细介绍了。 2. 安装selenium 确保pip命令可用，如果提示“pip不是内部或外部命令”，需要将将pip的安装目录添加到环境变量PATH下面。 接下来通过pip命令安装Selenium: pip install selenium Collecting selenium Downloading selenium-3.4.3-py2.py3-none-any.whl (931kB) 26% |████████ | 245kB 576kB/s eta 0:00:02 27% |█████████ | 256kB 570kB/s eta 0:00:02 28% |██████████ | 266kB 536kB/s eta 0:00:0 29% |███████████ | 276kB 530kB/s eta 0:00:0 30% |████████████ | 286kB 586kB/s eta 0:00:0 …… 打开编辑器，输入以下代码，如果执行报错，请看下一节 from selenium import webdriver driver = webdriver.Chrome() driver.get('https://www.baidu.com') print(driver.title) driver.quit() 二、selenium3 浏览器驱动 下载浏览器驱动 当selenium升级到3.0之后，对不同的浏览器驱动进行了规范。如果想使用selenium驱动不同的浏览器，必须单独下载并设置不同的浏览器驱动。（注：部分浏览器驱动地址需要科学上网。） Firefox浏览器驱动：geckodriver Chrome浏览器驱动：chromedriver , taobao备用地址[常用] IE浏览器驱动：IEDriverServer Edge浏览器驱动：MicrosoftWebDriver Opera浏览器驱动：operadriver PhantomJS浏览器驱动：phantomjs 设置浏览器驱动 设置浏览器的地址非常简单。 我们可以手动创建一个存放浏览器驱动的目录，如： C:\\driver , 将下载的浏览器驱动文件（例如：chromedriver、geckodriver）丢到该目录下。 验证不同的浏览器驱动是否正常使用。 from selenium import webdriver driver = webdriver.Firefox() # Firefox浏览器 driver = webdriver.Chrome() # Chrome浏览器 driver = webdriver.Ie() # Internet Explorer浏览器 driver = webdriver.Edge() # Edge浏览器 driver = webdriver.Opera() # Opera浏览器 driver = webdriver.PhantomJS() # PhantomJS 三、selenium元素定位 selenium定位方法 Selenium提供了8种定位方式。 id、name、class name、tag name、link text、partial link text、xpath、css selector 这8种定位方式在Python selenium中所对应的方法为： find_element_by_id() find_element_by_name() find_element_by_class_name() find_element_by_tag_name() find_element_by_link_text() find_element_by_partial_link_text() find_element_by_xpath() find_element_by_css_selector() 定位方法的用法 假如我们有一个Web页面，通过前端工具（如，Firebug）查看到一个元素的属性是这样的。 &lt;html&gt; &lt;head&gt; &lt;body link=&quot;#0000cc&quot;&gt; &lt;a id=&quot;result_logo&quot; href=&quot;/&quot; onmousedown=&quot;return c({'fm':'tab','tab':'logo'})&quot;&gt; &lt;form id=&quot;form&quot; class=&quot;fm&quot; name=&quot;f&quot; action=&quot;/s&quot;&gt; &lt;span class=&quot;soutu-btn&quot;&gt;&lt;/span&gt; &lt;input id=&quot;kw&quot; class=&quot;s_ipt&quot; name=&quot;wd&quot; value=&quot;&quot; maxlength=&quot;255&quot; autocomplete=&quot;off&quot;&gt; 我们的目的是要定位input标签的输入框。 通过id定位: dr.find_element_by_id(&quot;kw&quot;) 通过name定位: dr.find_element_by_name(&quot;wd&quot;) 通过class name定位: dr.find_element_by_class_name(&quot;s_ipt&quot;) 通过tag name定位: dr.find_element_by_tag_name(&quot;input&quot;) 通过xpath定位，xpath定位有N种写法，这里列几个常用写法: dr.find_element_by_xpath(&quot;//*[@id='kw']&quot;) dr.find_element_by_xpath(&quot;//*[@name='wd']&quot;) dr.find_element_by_xpath(&quot;//input[@class='s_ipt']&quot;) dr.find_element_by_xpath(&quot;/html/body/form/span/input&quot;) dr.find_element_by_xpath(&quot;//span[@class='soutu-btn']/input&quot;) dr.find_element_by_xpath(&quot;//form[@id='form']/span/input&quot;) dr.find_element_by_xpath(&quot;//input[@id='kw' and @name='wd']&quot;) 通过css定位，css定位有N种写法，这里列几个常用写法: dr.find_element_by_css_selector(&quot;#kw&quot;) dr.find_element_by_css_selector(&quot;[name=wd]&quot;) dr.find_element_by_css_selector(&quot;.s_ipt&quot;) dr.find_element_by_css_selector(&quot;html &gt; body &gt; form &gt; span &gt; input&quot;) dr.find_element_by_css_selector(&quot;span.soutu-btn&gt; input#kw&quot;) dr.find_element_by_css_selector(&quot;form#form &gt; span &gt; input&quot;) 接下来，我们的页面上有一组文本链接。 &lt;a class=&quot;mnav&quot; href=&quot;http://news.baidu.com&quot; name=&quot;tj_trnews&quot;&gt;新闻&lt;/a&gt; &lt;a class=&quot;mnav&quot; href=&quot;http://www.hao123.com&quot; name=&quot;tj_trhao123&quot;&gt;hao123&lt;/a&gt; 通过link text定位: dr.find_element_by_link_text(&quot;新闻&quot;) dr.find_element_by_link_text(&quot;hao123&quot;) 通过link text定位: dr.find_element_by_partial_link_text(&quot;新&quot;) dr.find_element_by_partial_link_text(&quot;hao&quot;) dr.find_element_by_partial_link_text(&quot;123&quot;) 关于xpaht和css的定位比较复杂，请参考xpath语法、css选择器 四、控制浏览器操作 控制浏览器窗口大小 有时候我们希望能以某种浏览器尺寸打开，让访问的页面在这种尺寸下运行。例如可以将浏览器设置成移动端大小(480* 800)，然后访问移动站点，对其样式进行评估；WebDriver提供了set_window_size()方法来设置浏览器的大小。 from selenium import webdriver driver = webdriver.Firefox() driver.get(&quot;http://m.baidu.com&quot;) # 参数数字为像素点 print(&quot;设置浏览器宽480、高800显示&quot;) driver.set_window_size(480, 800) driver.quit() 在PC端执行自动化测试脚本大多的情况下是希望浏览器在全屏幕模式下执行，那么可以使用maximize_window()方法使打开的浏览器全屏显示，其用法与set_window_size() 相同，但它不需要参数。 控制浏览器后退、前进 在使用浏览器浏览网页时，浏览器提供了后退和前进按钮，可以方便地在浏览过的网页之间切换，WebDriver也提供了对应的back()和forward()方法来模拟后退和前进按钮。下面通过例子来演示这两个方法的使用。 from selenium import webdriver driver = webdriver.Firefox() #访问百度首页 first_url= 'http://www.baidu.com' print(&quot;now access %s&quot; %(first_url)) driver.get(first_url) #访问新闻页面 second_url='http://news.baidu.com' print(&quot;now access %s&quot; %(second_url)) driver.get(second_url) #返回（后退）到百度首页 print(&quot;back to %s &quot;%(first_url)) driver.back() #前进到新闻页 print(&quot;forward to %s&quot;%(second_url)) driver.forward() driver.quit() 为了看清脚本的执行过程，下面每操作一步都通过print()来打印当前的URL地址。 刷新页面 driver.refresh() #刷新当前页面 五、WebDriver常用方法 点击和输入 前面已经学习了定位元素， 定位只是第一步， 定位之后需要对这个元素进行操作， 或单击（按钮） 或输入（输入框） ， 下面就来认识 WebDriver 中最常用的几个方法： clear()： 清除文本。 send_keys (value)： 模拟按键输入。 click()： 单击元素。 from selenium import webdriver driver = webdriver.Chrome() driver.get(&quot;https://www.baidu.com&quot;) driver.find_element_by_id(&quot;kw&quot;).clear() driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;selenium&quot;) driver.find_element_by_id(&quot;su&quot;).click() driver.quit() 提交 submit()方法用于提交表单。 例如， 在搜索框输入关键字之后的“回车” 操作， 就可以通过该方法模拟。 from selenium import webdriver driver = webdriver.Chrome() driver.get(&quot;https://www.baidu.com&quot;) search_text = driver.find_element_by_id('kw') search_text.send_keys('selenium') search_text.submit() driver.quit() 有时候 submit()可以与 click()方法互换来使用， submit()同样可以提交一个按钮， 但 submit()的应用范围远不及 click()广泛。 其他常用方法 size： 返回元素的尺寸。 text： 获取元素的文本。 get_attribute(name)： 获得属性值。 is_displayed()： 设置该元素是否用户可见。 from selenium import webdriver driver = webdriver.Chrome() driver.get(&quot;http://www.baidu.com&quot;) # 获得输入框的尺寸 size = driver.find_element_by_id('kw').size print(size) # 返回百度页面底部备案信息 text = driver.find_element_by_id(&quot;cp&quot;).text print(text) # 返回元素的属性值， 可以是 id、 name、 type 或其他任意属性 attribute = driver.find_element_by_id(&quot;kw&quot;).get_attribute('type') print(attribute) # 返回元素的结果是否可见， 返回结果为 True 或 False result = driver.find_element_by_id(&quot;kw&quot;).is_displayed() print(result) driver.quit() 输出结果： {'width': 500, 'height': 22} ©2015 Baidu 使用百度前必读 意见反馈 京 ICP 证 030173 号 text True 执行上面的程序并查看结果： size 方法用于获取百度输入框的宽、 高， text 方法用于获得百度底部的备案信息 get_attribute()用于获得百度输入的 type 属性的值， is_displayed()用于返回一个元素是否可见， 如果可见则返回 True， 否则返回 False。 六、鼠标事件 在 WebDriver 中， 将这些关于鼠标操作的方法封装在ActionChains 类提供。 ActionChains类提供了鼠标操作的常用方法： perform()： 执行所有 ActionChains 中存储的行为； context_click()： 右击； double_click()： 双击； drag_and_drop()： 拖动； move_to_element()： 鼠标悬停。 鼠标悬停操作 from selenium import webdriver # 引入 ActionChains 类 from selenium.webdriver.common.action_chains import ActionChains driver = webdriver.Chrome() driver.get(&quot;https://www.baidu.cn&quot;) # 定位到要悬停的元素 above = driver.find_element_by_link_text(&quot;设置&quot;) # 对定位到的元素执行鼠标悬停操作 ActionChains(driver).move_to_element(above).perform() from selenium.webdriver import ActionChains 导入提供鼠标操作的 ActionChains 类。 ActionChains(driver) 调用 ActionChains()类， 将浏览器驱动 driver 作为参数传入。 move_to_element(above) context_click()方法用于模拟鼠标右键操作， 在调用时需要指定元素定位。 perform() 执行所有 ActionChains 中存储的行为， 可以理解成是对整个操作的提交动作。 七、键盘事件 Keys()类提供了键盘上几乎所有按键的方法。 前面了解到， send_keys()方法可以用来模拟键盘输入， 除此 之外， 我们还可以用它来输入键盘上的按键， 甚至是组合键， 如 Ctrl+A、 Ctrl+C 等。 from selenium import webdriver # 引入 Keys 模块 from selenium.webdriver.common.keys import Keys driver = webdriver.Chrome() driver.get(&quot;http://www.baidu.com&quot;) # 输入框输入内容 driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;seleniumm&quot;) # 删除多输入的一个 m driver.find_element_by_id(&quot;kw&quot;).send_keys(Keys.BACK_SPACE) # 输入空格键+“教程” driver.find_element_by_id(&quot;kw&quot;).send_keys(Keys.SPACE) driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;教程&quot;) # ctrl+a 全选输入框内容 driver.find_element_by_id(&quot;kw&quot;).send_keys(Keys.CONTROL, 'a') # ctrl+x 剪切输入框内容 driver.find_element_by_id(&quot;kw&quot;).send_keys(Keys.CONTROL, 'x') # ctrl+v 粘贴内容到输入框 driver.find_element_by_id(&quot;kw&quot;).send_keys(Keys.CONTROL, 'v') # 通过回车键来代替单击操作 driver.find_element_by_id(&quot;su&quot;).send_keys(Keys.ENTER) driver.quit() 需要说明的是， 上面的脚本没有什么实际意义， 仅向我们展示模拟键盘各种按键与组合键的用法。 from selenium.webdriver.common.keys import Keys 在使用键盘按键方法前需要先导入 keys 类。 以下为常用的键盘操作： send_keys(Keys.BACK_SPACE) 删除键（BackSpace） send_keys(Keys.SPACE) 空格键(Space) send_keys(Keys.TAB) 制表键(Tab) send_keys(Keys.ESCAPE) 回退键（Esc） send_keys(Keys.ENTER) 回车键（Enter） send_keys(Keys.CONTROL,'a') 全选（Ctrl+A） send_keys(Keys.CONTROL,'c') 复制（Ctrl+C） send_keys(Keys.CONTROL,'x') 剪切（Ctrl+X） send_keys(Keys.CONTROL,'v') 粘贴（Ctrl+V） send_keys(Keys.F1) 键盘 F1 send_keys(Keys.F12) 键盘 F12 八、获取断言信息 不管是在做功能测试还是自动化测试，最后一步需要拿实际结果与预期进行比较。这个比较的称之为断言。 我们通常可以通过获取title 、URL和text等信息进行断言。text方法在前面已经讲过，它用于获取标签对之间的文本信息。 下面同样以百度为例，介绍如何获取这些信息。 from selenium import webdriver from time import sleep driver = webdriver.Firefox() driver.get(&quot;https://www.baidu.com&quot;) print('Before search================') # 打印当前页面title title = driver.title print(title) # 打印当前页面URL now_url = driver.current_url print(now_url) driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;selenium&quot;) driver.find_element_by_id(&quot;su&quot;).click() sleep(1) print('After search================') # 再次打印当前页面title title = driver.title print(title) # 打印当前页面URL now_url = driver.current_url print(now_url) # 获取结果数目 user = driver.find_element_by_class_name('nums').text print(user) driver.quit() 脚本运行结果如下： Before search================ 百度一下，你就知道 https://www.baidu.com/ After search================ selenium_百度搜索 https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=0&amp;rsv_idx... 搜索工具 百度为您找到相关结果约5,380,000个 title：用于获得当前页面的标题。 current_url：用户获得当前页面的URL。 text：获取搜索条目的文本信息。 九、设置元素等待 WebDriver提供了两种类型的等待：显式等待和隐式等待。 显式等待 显式等待使WebdDriver等待某个条件成立时继续执行，否则在达到最大时长时抛出超时异常（TimeoutException）。 from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC driver = webdriver.Firefox() driver.get(&quot;http://www.baidu.com&quot;) element = WebDriverWait(driver, 5, 0.5).until( EC.presence_of_element_located((By.ID, &quot;kw&quot;)) ) element.send_keys('selenium') driver.quit() WebDriverWait类是由WebDirver 提供的等待方法。在设置时间内，默认每隔一段时间检测一次当前页面元素是否存在，如果超过设置时间检测不到则抛出异常。具体格式如下： WebDriverWait(driver, timeout, poll_frequency=0.5, ignored_exceptions=None) driver ：浏览器驱动。 timeout ：最长超时时间，默认以秒为单位。 poll_frequency ：检测的间隔（步长）时间，默认为0.5S。 ignored_exceptions ：超时后的异常信息，默认情况下抛NoSuchElementException异常。 WebDriverWait()一般由until()或until_not()方法配合使用，下面是until()和until_not()方法的说明。 until(method, message='') 调用该方法提供的驱动程序作为一个参数，直到返回值为True。 until_not(method, message='') 调用该方法提供的驱动程序作为一个参数，直到返回值为False。 在本例中，通过as关键字将expected_conditions 重命名为EC，并调用presence_of_element_located()方法判断元素是否存在。 隐式等待 WebDriver提供了implicitly_wait()方法来实现隐式等待，默认设置为0。它的用法相对来说要简单得多。 from selenium import webdriver from selenium.common.exceptions import NoSuchElementException from time import ctime driver = webdriver.Firefox() # 设置隐式等待为10秒 driver.implicitly_wait(10) driver.get(&quot;http://www.baidu.com&quot;) try: print(ctime()) driver.find_element_by_id(&quot;kw22&quot;).send_keys('selenium') except NoSuchElementException as e: print(e) finally: print(ctime()) driver.quit() implicitly_wait() 默认参数的单位为秒，本例中设置等待时长为10秒。首先这10秒并非一个固定的等待时间，它并不影响脚本的执行速度。其次，它并不针对页面上的某一元素进行等待。当脚本执行到某个元素定位时，如果元素可以定位，则继续执行；如果元素定位不到，则它将以轮询的方式不断地判断元素是否被定位到。假设在第6秒定位到了元素则继续执行，若直到超出设置时长（10秒）还没有定位到元素，则抛出异常。 十、定位一组元素 WebDriver还提供了8种用于定位一组元素的方法。 find_elements_by_id() find_elements_by_name() find_elements_by_class_name() find_elements_by_tag_name() find_elements_by_link_text() find_elements_by_partial_link_text() find_elements_by_xpath() find_elements_by_css_selector() 定位一组元素的方法与定位单个元素的方法类似，唯一的区别是在单词element后面多了一个s表示复数。 接下来通过例子演示定位一组元素的使用： from selenium import webdriver from time import sleep driver = webdriver.Chrome() driver.get(&quot;https://www.baidu.com&quot;) driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;selenium&quot;) driver.find_element_by_id(&quot;su&quot;).click() sleep(1) # 定位一组元素 texts = driver.find_elements_by_xpath('//div/h3/a') # 循环遍历出每一条搜索结果的标题 for t in texts: print(t.text) driver.quit() 十一、多表单切换 在Web应用中经常会遇到frame/iframe表单嵌套页面的应用，WebDriver只能在一个页面上对元素识别与定位，对于frame/iframe表单内嵌页面上的元素无法直接定位。这时就需要通过switch_to.frame()方法将当前定位的主体切换为frame/iframe表单的内嵌页面中。 &lt;html&gt; &lt;body&gt; ... &lt;iframe id=&quot;x-URS-iframe&quot; ...&gt; &lt;html&gt; &lt;body&gt; ... &lt;input name=&quot;email&quot; &gt; 126邮箱登录框的结构大概是这样子的，想要操作登录框必须要先切换到iframe表单。 from selenium import webdriver driver = webdriver.Chrome() driver.get(&quot;http://www.126.com&quot;) driver.switch_to.frame('x-URS-iframe') driver.find_element_by_name(&quot;email&quot;).clear() driver.find_element_by_name(&quot;email&quot;).send_keys(&quot;username&quot;) driver.find_element_by_name(&quot;password&quot;).clear() driver.find_element_by_name(&quot;password&quot;).send_keys(&quot;password&quot;) driver.find_element_by_id(&quot;dologin&quot;).click() driver.switch_to.default_content() driver.quit() switch_to.frame() 默认可以直接取表单的id 或name属性。如果iframe没有可用的id和name属性，则可以通过下面的方式进行定位。 …… #先通过xpth定位到iframe xf = driver.find_element_by_xpath('//*[@id=&quot;x-URS-iframe&quot;]') #再将定位对象传给switch_to.frame()方法 driver.switch_to.frame(xf) …… driver.switch_to.parent_frame() 除此之外，在进入多级表单的情况下，还可以通过switch_to.default_content()跳回最外层的页面。 十二、多窗口切换 在页面操作过程中有时候点击某个链接会弹出新的窗口，这时就需要主机切换到新打开的窗口上进行操作。WebDriver提供了switch_to.window()方法，可以实现在不同的窗口之间切换。 以百度首页和百度注册页为例，在两个窗口之间的切换如下图。 from selenium import webdriver import time driver = webdriver.Firefox() driver.implicitly_wait(10) driver.get(&quot;http://www.baidu.com&quot;) # 获得百度搜索窗口句柄 sreach_windows = driver.current_window_handle driver.find_element_by_link_text('登录').click() driver.find_element_by_link_text(&quot;立即注册&quot;).click() # 获得当前所有打开的窗口的句柄 all_handles = driver.window_handles # 进入注册窗口 for handle in all_handles: if handle != sreach_windows: driver.switch_to.window(handle) print('now register window!') driver.find_element_by_name(&quot;account&quot;).send_keys('username') driver.find_element_by_name('password').send_keys('password') time.sleep(2) driver.quit() 在本例中所涉及的新方法如下： current_window_handle：获得当前窗口句柄。 window_handles：返回所有窗口的句柄到当前会话。 switch_to.window()：用于切换到相应的窗口，与上一节的switch_to.frame()类似，前者用于不同窗口的切换，后者用于不同表单之间的切换。 十三、警告框处理 在WebDriver中处理JavaScript所生成的alert、confirm以及prompt十分简单，具体做法是使用 switch_to.alert 方法定位到 alert/confirm/prompt，然后使用text/accept/dismiss/ send_keys等方法进行操作。 text：返回 alert/confirm/prompt 中的文字信息。 accept()：接受现有警告框。 dismiss()：解散现有警告框。 send_keys(keysToSend)：发送文本至警告框。keysToSend：将文本发送至警告框。 如下图，百度搜索设置弹出的窗口是不能通过前端工具对其进行定位的，这个时候就可以通过switch_to_alert()方法接受这个弹窗。 from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains import time driver = webdriver.Firefox() driver.implicitly_wait(10) driver.get('http://www.baidu.com') # 鼠标悬停至“设置”链接 link = driver.find_element_by_link_text('设置') ActionChains(driver).move_to_element(link).perform() # 打开搜索设置 driver.find_element_by_link_text(&quot;搜索设置&quot;).click() # 保存设置 driver.find_element_by_class_name(&quot;prefpanelgo&quot;).click() time.sleep(2) # 接受警告框 driver.switch_to.alert.accept() driver.quit() 通过switch_to_alert()方法获取当前页面上的警告框，并使用accept()方法接受警告框。 十四、下拉框选择 有时我们会碰到下拉框，WebDriver提供了Select类来处理下拉框。 如百度搜索设置的下拉框 from selenium import webdriver from selenium.webdriver.support.select import Select from time import sleep driver = webdriver.Chrome() driver.implicitly_wait(10) driver.get('http://www.baidu.com') # 鼠标悬停至“设置”链接 driver.find_element_by_link_text('设置').click() sleep(1) # 打开搜索设置 driver.find_element_by_link_text(&quot;搜索设置&quot;).click() sleep(2) # 搜索结果显示条数 sel = driver.find_element_by_xpath(&quot;//select[@id='nr']&quot;) Select(sel).select_by_value('50') # 显示50条 driver.quit() Select类用于定位select标签。 select_by_value() 方法用于定位下接选项中的value值。 十五、文件上传 对于通过input标签实现的上传功能，可以将其看作是一个输入框，即通过send_keys()指定本地文件路径的方式实现文件上传。 创建upfile.html文件，代码如下： &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot; /&gt; &lt;title&gt;upload_file&lt;/title&gt; &lt;link href=&quot;http://cdn.bootcss.com/bootstrap/3.3.0/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;row-fluid&quot;&gt; &lt;div class=&quot;span6 well&quot;&gt; &lt;h3&gt;upload_file&lt;/h3&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=&quot;http://cdn.bootcss.com/bootstrap/3.3.0/css/bootstrap.min.js&quot;&gt;&lt;/scrip&gt; &lt;/html&gt; 通过浏览器打开upfile.html文件，接下来通过send_keys()方法来实现文件上传。 from selenium import webdriver import os driver = webdriver.Firefox() file_path = 'file:///' + os.path.abspath('upfile.html') driver.get(file_path) # 定位上传按钮，添加本地文件 driver.find_element_by_name(&quot;file&quot;).send_keys('D:\\\\upload_file.txt') driver.quit() 十六、cookie操作 有时候我们需要验证浏览器中cookie是否正确，因为基于真实cookie的测试是无法通过白盒和集成测试进行的。 WebDriver提供了操作Cookie的相关方法，可以读取、添加和删除cookie信息。 WebDriver操作cookie的方法： get_cookies()： 获得所有cookie信息。 get_cookie(name)： 返回字典的key为“name”的cookie信息。 add_cookie(cookie_dict) ： 添加cookie。“cookie_dict”指字典对象，必须有name 和value 值。 delete_cookie(name,optionsString)：删除cookie信息。“name”是要删除的cookie的名称，“optionsString”是该cookie的选项，目前支持的选项包括“路径”，“域”。 delete_all_cookies()： 删除所有cookie信息。 下面通过get_cookies()来获取当前浏览器的cookie信息。 from selenium import webdriver driver = webdriver.Firefox() driver.get(&quot;http://www.youdao.com&quot;) # 获得cookie信息 cookie= driver.get_cookies() # 将获得cookie的信息打印 print(cookie) driver.quit() 从执行结果可以看出，cookie数据是以字典的形式进行存放的。知道了cookie的存放形式，接下来我们就可以按照这种形式向浏览器中写入cookie信息。 from selenium import webdriver driver = webdriver.Firefox() driver.get(&quot;http://www.youdao.com&quot;) # 向cookie的name 和value中添加会话信息 driver.add_cookie({'name': 'key-aaaaaaa', 'value': 'value-bbbbbb'}) # 遍历cookies中的name 和value信息并打印，当然还有上面添加的信息 for cookie in driver.get_cookies(): print(&quot;%s -&gt; %s&quot; % (cookie['name'], cookie['value'])) driver.quit() 输出结果： ======================== RESTART: ========================= YOUDAO_MOBILE_ACCESS_TYPE -&gt; 1 _PREF_ANONYUSER__MYTH -&gt; aGFzbG9nZ2VkPXRydWU= OUTFOX_SEARCH_USER_ID -&gt; -1046383847@218.17.158.115 JSESSIONID -&gt; abc7qSE_SBGsVgnVLBvcu key-aaaaaaa -&gt; value-bbbbbb 从执行结果可以看到，最后一条cookie信息是在脚本执行过程中通过add_cookie()方法添加的。通过遍历得到所有的cookie信息，从而找到key为“name”和“value”的特定cookie的value。 十七、调用JS代码 虽然WebDriver提供了操作浏览器的前进和后退方法，但对于浏览器滚动条并没有提供相应的操作方法。在这种情况下，就可以借助JavaScript来控制浏览器的滚动条。WebDriver提供了execute_script()方法来执行JavaScript代码。 用于调整浏览器滚动条位置的JavaScript代码如下： &lt;!-- window.scrollTo(左边距,上边距); --&gt; window.scrollTo(0,450); window.scrollTo()方法用于设置浏览器窗口滚动条的水平和垂直位置。方法的第一个参数表示水平的左间距，第二个参数表示垂直的上边距。其代码如下： from selenium import webdriver from time import sleep # 访问百度 driver=webdriver.Firefox() driver.get(&quot;http://www.baidu.com&quot;) # 设置浏览器窗口大小 driver.set_window_size(500, 500) # 搜索 driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;selenium&quot;) driver.find_element_by_id(&quot;su&quot;).click() sleep(2) # 通过javascript设置浏览器窗口的滚动条位置 js=&quot;window.scrollTo(100,450);&quot; driver.execute_script(js) sleep(3) driver.quit() 通过浏览器打开百度进行搜索，并且提前通过set_window_size()方法将浏览器窗口设置为固定宽高显示，目的是让窗口出现水平和垂直滚动条。然后通过execute_script()方法执行JavaScripts代码来移动滚动条的位置。 十八、窗口截图 自动化用例是由程序去执行的，因此有时候打印的错误信息并不十分明确。如果在脚本执行出错的时候能对当前窗口截图保存，那么通过图片就可以非常直观地看出出错的原因。WebDriver提供了截图函数get_screenshot_as_file()来截取当前窗口。 from selenium import webdriver from time import sleep driver = webdriver.Firefox() driver.get('http://www.baidu.com') driver.find_element_by_id('kw').send_keys('selenium') driver.find_element_by_id('su').click() sleep(2) # 截取当前窗口，并指定截图图片的保存位置 driver.get_screenshot_as_file(&quot;D:\\\\baidu_img.jpg&quot;) driver.quit() 脚本运行完成后打开D盘，就可以找到baidu_img.jpg图片文件了。 十九、关闭浏览器 在前面的例子中我们一直使用quit()方法，其含义为退出相关的驱动程序和关闭所有窗口。除此之外，WebDriver还提供了close()方法，用来关闭当前窗口。例多窗口的处理，在用例执行的过程中打开了多个窗口，我们想要关闭其中的某个窗口，这时就要用到close()方法进行关闭了。 close() 关闭单个窗口 quit() 关闭所有窗口 二十、Selenium踩坑指北 众所周知，我们应该把合适的工具用在合适的场景，这跟杀鸡的时候不需要用到宰牛刀是一样的道理。 selenium比较好的使用场景是验收测试/回归测试/TDD/BDD，一些同学喜欢把selenium用到某些selenium难以承受的场景，这种方式官方是不推荐的。下面这些是官方给出的各种神坑。 验证码 一般来说我们不需要用selenium去处理各种验证码，有兴趣的同学可以逆向思维，亲自试试。 那么遇到验证码怎么办？ 测试环境就关掉验证码 留个后门，比如万能验证码 下载文件 尽管我们可以使用selenium去点击下载按钮，从而达到下载文件的目的，但是这样做其实并不好。首先处理起来可能比较麻烦，另外关于下载时间下载速度以及下载完整性的验证我们是不太好做的。 HTTP 请求的响应码 这一part官方苦口婆心的解释了很多，大意是selenium是站在用户角度去自动化测试，对于终端用户来说，他们并不直接关注请求的返回码，他们关注的是能不能看到404的错误页面之类的可以直接感受到信息。 下面是非官方的建议 如果你真的关注响应的状态码，那么别在UI自动化层去做，试着去在非UI层，比如接口层做 放弃在UI自动化用例中断言状态码的努力，有舍才有得嘛 第三方登陆 使用selenium去自动化第三方登陆原则上是不推荐的。因为 增加了用例的复杂度和运行时间，用例容易跑失败 第三方登录是不稳定的，这会让你的登录变得不稳定 在国外一般第三方登录的提供方会提供对应的API，我们可以把登录API集成到用例里，这些API相当稳定，比用selenium去自动化登录过程要好。 国内可以通过类似的思路去做，比如微信登录就有自己的API，这种实现比较硬核，并且跟ui自动化结合起来也有一定难度，有需求的同学可以尝试一下。 用例依赖 selenium team说了，用例直接不要有依赖，要可以用任意顺序运行 性能测试 简而言之，selenium不适合做性能测试，原因我就不详细说了，总之不合适的话咱就不要强求，有情人总会终成眷属。 如果需要做性能测试，可以看看jmeter，官方推荐，值得信赖。 链接爬虫 用selenium去遍历一些链接从而达到爬虫的效果官方是不推荐的，理由是慢，有很多更好的替代方案。 ","link":"https://preszang.github.io/post/XfbZQSvJ5/"},{"title":"pytest接口测试基本教程","content":"1.快速开始 pytest测试框架可以让我们很方便的编写测试用例，这些用例写起来虽然简单，但仍然可以规模化以及编写更加复杂的测试用例。官方文档 安装 pip install -U pytest 用下面的命令去检查一下pytest是否成功安装 $ pytest --version This is pytest version 3.x.y, imported from $PYTHON_PREFIX/lib/python3.5/site-packages/pytest.py 快速开始 创建名为test_quick_start.py的文件，敲如下内容 def reverse(string): return string[::-1] def test_reverse(): string = &quot;good&quot; assert reverse(string) == &quot;doog&quot; another_string = &quot;itest&quot; assert reverse(another_string) == &quot;tseti&quot; 上面的代码做了2件事情 定义了名为reverse(string)的全局函数，作用是把string反转并返回。比如输入&quot;abc&quot;会反转成&quot;cba&quot; 定义了名为test_reverse()的函数，包含了2个断言，用来测试reverse()方法的正确性 在命令行中使用下面的命令去运行用例 pytest 结果应该大致如下 ========================================================================= test session starts ========================================================================= platform darwin -- Python 2.7.12, pytest-3.2.3, py-1.4.34, pluggy-0.4.0 rootdir: /Users/easonhan/code/testclass.net/src/pytest, inifile: collected 1 item test_quick_start.py . ====================================================================== 1 passed in 0.01 seconds ======================================================================= 总结 这是最简单的单元测试实例，实现了用代码去测试代码的目的。 2.运行多个文件 在现实的测试活动中，我们经常会定义多个用例文件，用来实现业务逻辑或其他逻辑上用例的物理分隔，比如 login_test.py # 登录相关功能的测试用例 cart_test.py # 购物车相关功能的测试用例 checkout_test.py # 结算相关功能的用例 order_test.py # 订单相关功能的用例 使用pytest可以很方便的执行批量执行一组文件中定义的用例。 潜规则 在批量执行用例之前，我们需要了解一下pytest的潜规则，注意，由于pytest可以支持丰富的定制选项，下面的潜规则是在没有定制的默认情况下的缺省规则 pytest会找当前以及递查找子文件夹下面所有的test_*.py或*_test.py的文件，把其当作测试文件 在这些文件里，pytest会收集下面的一些函数或方法，当作测试用例 不在类定义中的以test_开头的函数或方法 在以Test开头的类中(不能包含__init__方法)，以test_开头的方法 pytest也支持unittest模式的用例定义 实例 新建test_calc.py文件，与上一节的test_quick_start.py放在同一文件夹下，敲入下面的内容 def add(x, y): return x + y def test_add(): assert add(1, 0) == 1 assert add(1, 1) == 2 assert add(1, 99) == 100 现在当前文件夹下应该有2个文件 test_calc.py test_quick_start.py 运行 在当前文件夹敲下面的命令 pytest 结果大致应该如下所示 $ pytest ========================================================================= test session starts ========================================================================= platform darwin -- Python 2.7.12, pytest-3.2.3, py-1.4.34, pluggy-0.4.0 rootdir: /Users/easonhan/code/testclass.net/src/pytest, inifile: collected 2 items test_calc.py . test_quick_start.py . ====================================================================== 2 passed in 0.01 seconds ======================================================================= 总结 上面的例子里 所有以test_开头的py文件都被当成了测试文件 所有测试文件中以test开头的方法被当成了测试用例执行 3.Assert Assert就是断言，每个测试用例都需要断言。 与unittest不同，pytest使用的是python自带的assert关键字来进行断言，大大降低了学习成本。 assert关键字后面可以接一个表达式，只要表达式的最终结果为True，那么断言通过，用例执行成功，否则用例执行失败。 详尽的用例失败描述 pytest的用例失败描述非常详尽，一目了人。考虑下面的例子 # content of test_assert1.py def f(): return 3 def test_function(): assert f() == 4 执行上面的用例 $ pytest test_assert1.py ======= test session starts ======== platform linux -- Python 3.x.y, pytest-3.x.y, py-1.x.y, pluggy-0.x.y rootdir: $REGENDOC_TMPDIR, inifile: collected 1 item test_assert1.py F ======= FAILURES ======== _______ test_function ________ def test_function(): &gt; assert f() == 4 E assert 3 == 4 E + where 3 = f() test_assert1.py:5: AssertionError ======= 1 failed in 0.12 seconds ======== 可以很明显的看出，pytest给出的错误提示是：f()的值是3，也就是实际结果是3，而预期结果是4，3不等于4，因此断言未通过，用例失败。 断言异常抛出 pytest有自己的异常抛出断言套路，下面是最简单的形式 import pytest def test_zero_division(): with pytest.raises(ZeroDivisionError): 1 / 0 上面代码的意思是: 1/0的时候应该抛出ZeroDivisionError，否则用例失败，断言不通过。 另外pytest还允许我们访问异常的具体信息，如下面的例子 def test_recursion_depth(): with pytest.raises(RuntimeError) as excinfo: def f(): f() f() assert 'maximum recursion' in str(excinfo.value) 我们还可以定制断言异常的错误信息，比如 &gt;&gt;&gt; with raises(ZeroDivisionError, message=&quot;Expecting ZeroDivisionError&quot;): ... pass ... Failed: Expecting ZeroDivisionError 总结 更多断言异常以及定制assert中比较方式的例子，请参阅官方文档 4.Fixture 我们可以简单的把Fixture理解为准备测试数据和初始化测试对象的阶段。 一般我们对测试数据和测试对象的管理有这样的一些场景 所有用例开始之前初始化测试数据或对象 所有用例结束之后销毁测试数据或对象 每个用例开始之前初始化测试数据或对象 每个用例结束之后销毁测试数据或对象 在每个／所有module的用例开始之前初始化数据或对象 在每个／所有module的用例开始之后销毁数据或对象 ...... ...... pytest的fixture特性可以满足上面的需求。 简单的例子 考虑这种场景，我们需要判断用户的密码中包含简单密码，规则是这样的，密码必须至少6位，满足6位的话判断用户的密码不是password123或者password之类的弱密码。 我们将用户的信息导出成名为users.dev.json的文件，该文件如下所示 [ {&quot;name&quot;:&quot;jack&quot;,&quot;password&quot;:&quot;Iloverose&quot;}, {&quot;name&quot;:&quot;rose&quot;,&quot;password&quot;:&quot;Ilovejack&quot;}, {&quot;name&quot;:&quot;tom&quot;,&quot;password&quot;:&quot;password123&quot;} ] 新建名为test_user_password.py的文件，键入以下内容，一定要保证users.dev.json文件与该文件在同一路径下 import pytest import json class TestUserPassword(object): @pytest.fixture def users(self): return json.loads(open('./users.dev.json', 'r').read()) # 读取当前路径下的users.dev.json文件，返回的结果是dict def test_user_password(self, users): # 遍历每条user数据 for user in users: passwd = user['password'] assert len(passwd) &gt;= 6 msg = &quot;user %s has a weak password&quot; %(user['name']) assert passwd != 'password', msg assert passwd != 'password123', msg 运行 pytest可以通过指定文件名的方式运行单个用例文件，这里我们只运行test_user_password.py文件 pytest test_user_password.py 运行结果 $ pytest test_user_password.py ========================================================================= test session starts ========================================================================= platform darwin -- Python 2.7.12, pytest-3.2.3, py-1.4.34, pluggy-0.4.0 rootdir: /Users/easonhan/code/testclass.net/src/pytest, inifile: collected 1 item test_user_password.py F ============================================================================== FAILURES =============================================================================== _________________________________________________________________ TestUserPassword.test_user_password _________________________________________________________________ self = &lt;test_user_password.TestUserPassword object at 0x1046e3290&gt; users = [{'name': 'jack', 'password': 'Iloverose'}, {'name': 'rose', 'password': 'Ilovejack'}, {'name': 'tom', 'password': 'password123'}] def test_user_password(self, users): for user in users: passwd = user['password'] assert len(passwd) &gt;= 6 msg = &quot;user %s has a weak password&quot; %(user['name']) assert passwd != 'password', msg &gt; assert passwd != 'password123', msg E AssertionError: user tom has a weak password E assert 'password123' != 'password123' test_user_password.py:14: AssertionError ====================================================================== 1 failed in 0.03 seconds ======================================================================= 分析 使用@pytest.fixture装饰器可以定义feature 在用例的参数中传递fixture的名称以便直接调用fixture，拿到fixture的返回值 3个assert是递进关系，前1个assert断言失败后，后面的assert是不会运行的，因此重要的assert放到前面 E AssertionError: user tom has a weak password可以很容易的判断出是哪条数据出了问题，所以定制可读性好的错误信息是很必要的 任何1个断言失败以后，for循环就会退出，所以上面的用例1次只能发现1条错误数据，换句话说任何1个assert失败后，用例就终止运行了 执行顺序 pytest是这样运行上面的用例的 pytest找到以test_开头的方法，也就是test_user_password方法，执行该方法时发现传入的参数里有跟fixture users名称相同的参数 pytest认定users是fixture，执行该fixture，读取json文件解析成dict实例 test_user_password方法真正被执行，users fixture被传入到该方法 注意 我们可以使用下面的命令来查看用例中可用的fixtures pytest --fixtures test_user_password.py 数据清理 有时候我们需要在用例结束的时候去清理一些测试数据，或清除测试过程中创建的对象，我们可以使用下面的方式 import smtplib import pytest @pytest.fixture(scope=&quot;module&quot;) def smtp(): smtp = smtplib.SMTP(&quot;smtp.gmail.com&quot;, 587, timeout=5) yield smtp # provide the fixture value print(&quot;teardown smtp&quot;) smtp.close() yield 关键字返回了fixture中实例化的对象smtp module中的用例执行完成后smtp.close()方法会执行，无论用例的运行状态是怎么样的,都会执行 更多的数据清理方式 addfinalizer 也可以完成数据清理的工作，具体见这里 5.参数化的Fixture 继续上一节的测试需求，在上一节里，任何1条测试数据导致断言不通过后测试用例就会停止运行，这样每次只能检查出1条不符合规范的数据，有没有什么办法可以一次性把所有的不符合结果都测出来呢？ 这时候我们就需要用到参数化的fixture特性了 更新数据文件 新建users.test.json文件，内容如下 [ {&quot;name&quot;:&quot;jack&quot;,&quot;password&quot;:&quot;Iloverose&quot;}, {&quot;name&quot;:&quot;rose&quot;,&quot;password&quot;:&quot;Ilovejack&quot;} {&quot;name&quot;:&quot;tom&quot;,&quot;password&quot;:&quot;password123&quot;}, {&quot;name&quot;:&quot;mike&quot;,&quot;password&quot;:&quot;password&quot;}, {&quot;name&quot;:&quot;james&quot;,&quot;password&quot;:&quot;AGoodPasswordWordShouldBeLongEnough&quot;} ] 我们增加了2条用户信息，其中mike的密码是弱密码。 参数化fixture 参数化fixture允许我们向fixture提供参数，参数可以是list，该list中有几条数据，fixture就会运行几次，相应的测试用例也会运行几次。 参数化fixture的语法是 @pytest.fixture(params=[&quot;smtp.gmail.com&quot;, &quot;mail.python.org&quot;]) 其中len(params)的值就是用例执行的次数 在fixture的定义中，可以使用request.param来获取每次传入的参数，如下: @pytest.fixture(scope=&quot;module&quot;, params=[&quot;smtp.gmail.com&quot;, &quot;mail.python.org&quot;]) def smtp(request): smtp = smtplib.SMTP(request.param, 587, timeout=5) yield smtp print (&quot;finalizing %s&quot; % smtp) smtp.close() 上面的代码smtp fixture会执行2次 第1次request.param == 'smtp.gmail.com' 第2次request.param == 'mail.python.org' 实现用例 我们现在使用参数化fixtures来实现一次性检查出弱密码的用例。 新建文件test_user_password_with_params.py，内容如下: import pytest import json users = json.loads(open('./users.test.json', 'r').read()) class TestUserPasswordWithParam(object): @pytest.fixture(params=users) def user(self, request): return request.param def test_user_password(self, user): passwd = user['password'] assert len(passwd) &gt;= 6 msg = &quot;user %s has a weak password&quot; %(user['name']) assert passwd != 'password', msg assert passwd != 'password123', msg 上面的例子里，我们先把所有用户信息读到users变量里，注意users这时候是list类型，可以直接传入到fixture的params 运行及结果 运行 pytest test_user_password_with_params.py 结果 $ pytest test_user_password_with_params.py ========================================================================= test session starts ========================================================================= platform darwin -- Python 2.7.12, pytest-3.2.3, py-1.4.34, pluggy-0.4.0 rootdir: /Users/easonhan/code/testclass.net/src/pytest, inifile: collected 5 items test_user_password_with_params.py ..FF. ============================================================================== FAILURES =============================================================================== _________________________________________________________ TestUserPasswordWithParam.test_user_password[user2] _________________________________________________________ self = &lt;test_user_password_with_params.TestUserPasswordWithParam object at 0x10de1d790&gt;, user = {'name': 'tom', 'password': 'password123'} def test_user_password(self, user): passwd = user['password'] assert len(passwd) &gt;= 6 msg = &quot;user %s has a weak password&quot; %(user['name']) assert passwd != 'password', msg &gt; assert passwd != 'password123', msg E AssertionError: user tom has a weak password E assert 'password123' != 'password123' test_user_password_with_params.py:15: AssertionError _________________________________________________________ TestUserPasswordWithParam.test_user_password[user3] _________________________________________________________ self = &lt;test_user_password_with_params.TestUserPasswordWithParam object at 0x10de1df50&gt;, user = {'name': 'mike', 'password': 'password'} def test_user_password(self, user): passwd = user['password'] assert len(passwd) &gt;= 6 msg = &quot;user %s has a weak password&quot; %(user['name']) &gt; assert passwd != 'password', msg E AssertionError: user mike has a weak password E assert 'password' != 'password' test_user_password_with_params.py:14: AssertionError ================================================================= 2 failed, 3 passed in 0.05 seconds ================================================================== 稍微留意一下, 可以看出tom和mike使用了弱密码。总共运行了5个用例,3个成功,2个失败。 fixture的更多特性 fixture还有很多更加灵活和深入的用法，具体见这里 6.Parametrize Fixture @pytest.mark.parametrize 装饰器可以让我们每次参数化fixture的时候传入多个项目。回忆上一节，我们参数化的时候只能传入传入1个字符串或者是其他的数据对象，parametrize每次多个参数，更加灵活。 例子 import pytest @pytest.mark.parametrize(&quot;test_input,expected&quot;, [ (&quot;3+5&quot;, 8), (&quot;2+4&quot;, 6), (&quot;6*9&quot;, 42), ]) def test_eval(test_input, expected): assert eval(test_input) == expected test_eval方法中传入了2个参数，就如同@pytest.mark.parametrize装饰器中定义的那样，因此简单理解，我们可以把parametrize装饰器想象成是数据表格，有表头(test_input,expected)以及具体的数据。 运行结果 $ pytest ======= test session starts ======== platform linux -- Python 3.x.y, pytest-3.x.y, py-1.x.y, pluggy-0.x.y rootdir: $REGENDOC_TMPDIR, inifile: collected 3 items test_expectation.py ..F ======= FAILURES ======== _______ test_eval[6*9-42] ________ test_input = '6*9', expected = 42 @pytest.mark.parametrize(&quot;test_input,expected&quot;, [ (&quot;3+5&quot;, 8), (&quot;2+4&quot;, 6), (&quot;6*9&quot;, 42), ]) def test_eval(test_input, expected): &gt; assert eval(test_input) == expected E AssertionError: assert 54 == 42 E + where 54 = eval('6*9') test_expectation.py:8: AssertionError ======= 1 failed, 2 passed in 0.12 seconds ======== 7.常见套路 在使用pytest的时候，下面这些问题我们可能会经常遇到，这里给出官方的解决方案，按照套路来执行就可以了。 基础用法 把命令行参数传入到用例 动态添加命令行参数 根据命令行参数来忽略用例执行 编写集成度更好的辅助断言 判断是否由pytest执行 在测试报告的头部添加内容 统计用例运行时间 定义测试步骤，也就是让用例按照一定的顺序执行 Package/Directory-level fixtures (setups) 在报告和用例失败之前添加钩子 在fixtures中访问测试结果 PYTEST_CURRENT_TEST环境变量 冻结pytest 参数化 根据命令行参数来组合测试参数 配置test ID 快速创建测试场景的功能 延迟参数资源加载 间接参数 为不同的方法设置不同的参数 在多个fixture中使用间接参数 Indirect parametrization of optional implementations/imports 单独的为每个参数化用例设置标记和ID 8.使用pytest做简单的接口测试 我们现在需要测试v2ex网站的查看论坛节点信息的api。具体如下: 节点信息：获得指定节点的名字，简介，URL 及头像图片的地址。 https://www.v2ex.com/api/nodes/show.json Method: GET Authentication: None 接受参数： name: 节点名（V2EX 的节点名全是半角英文或者数字） 例如：https://www.v2ex.com/api/nodes/show.json?name=python 接口返回 { &quot;id&quot; : 90, &quot;name&quot; : &quot;python&quot;, &quot;url&quot; : &quot;http://www.v2ex.com/go/python&quot;, &quot;title&quot; : &quot;Python&quot;, &quot;title_alternative&quot; : &quot;Python&quot;, &quot;topics&quot; : 7963, &quot;stars&quot; : 5138, &quot;header&quot; : &quot;这里讨论各种 Python 语言编程话题，也包括 Django，Tornado 等框架的讨论。这里是一个能够帮助你解决实际问题的地方。&quot;, &quot;footer&quot; : null, &quot;created&quot; : 1278683336, &quot;avatar_mini&quot; : &quot;//v2ex.assets.uxengine.net/navatar/8613/985e/90_mini.png?m=1509941286&quot;, &quot;avatar_normal&quot; : &quot;//v2ex.assets.uxengine.net/navatar/8613/985e/90_normal.png?m=1509941286&quot;, &quot;avatar_large&quot; : &quot;//v2ex.assets.uxengine.net/navatar/8613/985e/90_large.png?m=1509941286&quot; } 需求分析 该接口是获取数据的接口，一般来说，这种接口我们的测试重点是验证数据的准确性。 根据3A原则，我们可以设计如下的用例 测试数据: 节点的名称:python 接口地址: https://www.v2ex.com/api/nodes/show.json 断言: 返回的结果里，id必须是90,name必须等于python，大家想一想为什么？ 代码 新建名为v2ex_api_test.py的文件，键入如下内容 import requests class TestV2exApi(object): domain = 'https://www.v2ex.com/' def test_node(self): path = 'api/nodes/show.json?name=python' url = self.domain + pathpython res = requests.get(url).json() assert res['id'] == 90 assert res['name'] == 'python' 需要注意的点 使用requests库来简化发送get请求并将返回值的json字符串转换成python字典 使用domain变量来参数化测试的地址，因为不同环境的地址可能不一样，使用domain变量之后只需要改动这个变量就可以切换测试环境了 断言id为90是因为测试数据是静态的，id不会发生变化 运行 $ pytest v2ex_api_test.py ======================================================================== test session starts ======================================================================== platform darwin -- Python 2.7.12, pytest-3.2.3, py-1.4.34, pluggy-0.4.0 rootdir: /Users/easonhan/code/testclass.net/src/pytest, inifile: collected 1 item v2ex_api_test.py . ===================================================================== 1 passed in 1.39 seconds ====================================================================== 用例执行成功，我们实现了最简单的接口测试场景。 9.使用fixture参数化接口入参 接上一节v2ex网站的查看论坛节点信息的api。具体如下: 节点信息：获得指定节点的名字，简介，URL 及头像图片的地址。 https://www.v2ex.com/api/nodes/show.json Method: GET Authentication: None 接受参数： name: 节点名（V2EX 的节点名全是半角英文或者数字） 例如：https://www.v2ex.com/api/nodes/show.json?name=python 我们试一下，通过传入不同的name，我们可以获取不同的节点信息。上面例子里我们获取了python讨论区的信息。现在我们把name改成java，该接口会返回java讨论区节点的信息，如下所示https://www.v2ex.com/api/nodes/show.json?name=python { &quot;id&quot; : 63, &quot;name&quot; : &quot;java&quot;, &quot;url&quot; : &quot;http://www.v2ex.com/go/java&quot;, &quot;title&quot; : &quot;Java&quot;, &quot;title_alternative&quot; : &quot;Java&quot;, &quot;topics&quot; : 1219, &quot;stars&quot; : 1547, &quot;header&quot; : &quot;The most popular programming language.&quot;, &quot;footer&quot; : null, &quot;created&quot; : 1272669207, &quot;avatar_mini&quot; : &quot;//v2ex.assets.uxengine.net/navatar/03af/dbd6/63_mini.png?m=1509589840&quot;, &quot;avatar_normal&quot; : &quot;//v2ex.assets.uxengine.net/navatar/03af/dbd6/63_normal.png?m=1509589840&quot;, &quot;avatar_large&quot; : &quot;//v2ex.assets.uxengine.net/navatar/03af/dbd6/63_large.png?m=1509589840&quot; } 那么新的需求来了，现在我们要测试给定的几个节点名称(python/java/go/nodejs)，v2ex的节点api可以正确返回节点的名字 需求分析 根据3A原则，我们可以设计如下的用例 测试数据: 节点的名称:python/java/go/nodejs 接口地址: https://www.v2ex.com/api/nodes/show.json 断言: 返回的结果里，name字段的值必须等于传入的节点名称 代码 在v2ex_api_test.py的文件中添加如下内容 import requests import pytest class TestV2exApiWithParams(object): domain = 'https://www.v2ex.com/' @pytest.fixture(params=['python', 'java', 'go', 'nodejs']) def lang(self, request): return request.param def test_node(self, lang): path = 'api/nodes/show.json?name=%s' %(lang) url = self.domain + path res = requests.get(url).json() assert res['name'] == lang assert 0 需要注意的点 每次都可以用request.param来访问本次传入fixture中的参数 在测试方法中传入同名的fixture方法名可以直接访问fixture 使用assert(0)强制用例失败，这样可以看到每次fixture的参数值 运行 $ pytest v2ex_api_test.py ======================================================================== test session starts ======================================================================== platform darwin -- Python 2.7.12, pytest-3.2.3, py-1.4.34, pluggy-0.4.0 rootdir: /Users/easonhan/code/testclass.net/src/pytest, inifile: collected 5 items v2ex_api_test.py .FFFF ============================================================================= FAILURES ============================================================================== ______________________________________________________________ TestV2exApiWithParams.test_node[python] ______________________________________________________________ self = &lt;v2ex_api_test.TestV2exApiWithParams object at 0x105e0edd0&gt;, lang = 'python' def test_node(self, lang): path = 'api/nodes/show.json?name=%s' %(lang) url = self.domain + path res = requests.get(url).json() assert res['name'] == lang &gt; assert 0 E assert 0 v2ex_api_test.py:27: AssertionError _______________________________________________________________ TestV2exApiWithParams.test_node[java] _______________________________________________________________ self = &lt;v2ex_api_test.TestV2exApiWithParams object at 0x1075e2750&gt;, lang = 'java' def test_node(self, lang): path = 'api/nodes/show.json?name=%s' %(lang) url = self.domain + path res = requests.get(url).json() assert res['name'] == lang &gt; assert 0 E assert 0 v2ex_api_test.py:27: AssertionError ________________________________________________________________ TestV2exApiWithParams.test_node[go] ________________________________________________________________ self = &lt;v2ex_api_test.TestV2exApiWithParams object at 0x107636190&gt;, lang = 'go' def test_node(self, lang): path = 'api/nodes/show.json?name=%s' %(lang) url = self.domain + path res = requests.get(url).json() assert res['name'] == lang &gt; assert 0 E assert 0 v2ex_api_test.py:27: AssertionError ______________________________________________________________ TestV2exApiWithParams.test_node[nodejs] ______________________________________________________________ self = &lt;v2ex_api_test.TestV2exApiWithParams object at 0x1075e2790&gt;, lang = 'nodejs' def test_node(self, lang): path = 'api/nodes/show.json?name=%s' %(lang) url = self.domain + path res = requests.get(url).json() assert res['name'] == lang &gt; assert 0 E assert 0 v2ex_api_test.py:27: AssertionError ================================================================ 4 failed, 1 passed in 1.91 seconds ================================================================= 用例执行失败，但是每次运行时lang的值我们可以看的很明白。 10.使用fixture参数化测试预期结果 接上一节v2ex网站的查看论坛节点信息的api。 我们在上一节的测试用例里只断言了返回值的name字段必须与我们传入的入参相同，但是返回值的id却没有进行判定。这一节里我们加强一下测试脚本，实现判断id的功能。 测试数据 python, id=90 java, id=63 nodejs, id=436 go, id=375 代码实现 在v2ex_api_test.py的文件中加入如下内容: class TestV2exApiWithExpectation(object): domain = 'https://www.v2ex.com/' @pytest.mark.parametrize('name,node_id', [('python', 90), ('java', 63), ('go', 375), ('nodejs', 436)]) def test_node(self, name, node_id): path = 'api/nodes/show.json?name=%s' %(name) url = self.domain + path res = requests.get(url).json() assert res['name'] == name assert res['id'] == node_id assert 0 运行及结果 $ pytest v2ex_api_test.py ======================================================================== test session starts ======================================================================== platform darwin -- Python 2.7.12, pytest-3.2.3, py-1.4.34, pluggy-0.4.0 rootdir: /Users/easonhan/code/testclass.net/src/pytest, inifile: collected 9 items v2ex_api_test.py .FFFFFFFF ============================================================================= FAILURES ============================================================================== ______________________________________________________________ TestV2exApiWithParams.test_node[python] ______________________________________________________________ self = &lt;v2ex_api_test.TestV2exApiWithParams object at 0x10618eb10&gt;, lang = 'python' def test_node(self, lang): path = 'api/nodes/show.json?name=%s' %(lang) url = self.domain + path res = requests.get(url).json() assert res['name'] == lang &gt; assert 0 E assert 0 v2ex_api_test.py:27: AssertionError _______________________________________________________________ TestV2exApiWithParams.test_node[java] _______________________________________________________________ self = &lt;v2ex_api_test.TestV2exApiWithParams object at 0x106691790&gt;, lang = 'java' def test_node(self, lang): path = 'api/nodes/show.json?name=%s' %(lang) url = self.domain + path res = requests.get(url).json() assert res['name'] == lang &gt; assert 0 E assert 0 v2ex_api_test.py:27: AssertionError ________________________________________________________________ TestV2exApiWithParams.test_node[go] ________________________________________________________________ self = &lt;v2ex_api_test.TestV2exApiWithParams object at 0x10666dc50&gt;, lang = 'go' def test_node(self, lang): path = 'api/nodes/show.json?name=%s' %(lang) url = self.domain + path res = requests.get(url).json() assert res['name'] == lang &gt; assert 0 E assert 0 v2ex_api_test.py:27: AssertionError ______________________________________________________________ TestV2exApiWithParams.test_node[nodejs] ______________________________________________________________ self = &lt;v2ex_api_test.TestV2exApiWithParams object at 0x106691890&gt;, lang = 'nodejs' def test_node(self, lang): path = 'api/nodes/show.json?name=%s' %(lang) url = self.domain + path res = requests.get(url).json() assert res['name'] == lang &gt; assert 0 E assert 0 v2ex_api_test.py:27: AssertionError __________________________________________________________ TestV2exApiWithExpectation.test_node[python-90] __________________________________________________________ self = &lt;v2ex_api_test.TestV2exApiWithExpectation object at 0x1066d20d0&gt;, name = 'python', node_id = 90 @pytest.mark.parametrize('name,node_id', [('python', 90), ('java', 63), ('go', 375), ('nodejs', 436)]) def test_node(self, name, node_id): path = 'api/nodes/show.json?name=%s' %(name) url = self.domain + path res = requests.get(url).json() assert res['name'] == name assert res['id'] == node_id &gt; assert 0 E assert 0 v2ex_api_test.py:40: AssertionError ___________________________________________________________ TestV2exApiWithExpectation.test_node[java-63] ___________________________________________________________ self = &lt;v2ex_api_test.TestV2exApiWithExpectation object at 0x1066e9690&gt;, name = 'java', node_id = 63 @pytest.mark.parametrize('name,node_id', [('python', 90), ('java', 63), ('go', 375), ('nodejs', 436)]) def test_node(self, name, node_id): path = 'api/nodes/show.json?name=%s' %(name) url = self.domain + path res = requests.get(url).json() assert res['name'] == name assert res['id'] == node_id &gt; assert 0 E assert 0 v2ex_api_test.py:40: AssertionError ___________________________________________________________ TestV2exApiWithExpectation.test_node[go-375] ____________________________________________________________ self = &lt;v2ex_api_test.TestV2exApiWithExpectation object at 0x10666d790&gt;, name = 'go', node_id = 375 @pytest.mark.parametrize('name,node_id', [('python', 90), ('java', 63), ('go', 375), ('nodejs', 436)]) def test_node(self, name, node_id): path = 'api/nodes/show.json?name=%s' %(name) url = self.domain + path res = requests.get(url).json() assert res['name'] == name assert res['id'] == node_id &gt; assert 0 E assert 0 v2ex_api_test.py:40: AssertionError _________________________________________________________ TestV2exApiWithExpectation.test_node[nodejs-436] __________________________________________________________ self = &lt;v2ex_api_test.TestV2exApiWithExpectation object at 0x1066d2710&gt;, name = 'nodejs', node_id = 436 @pytest.mark.parametrize('name,node_id', [('python', 90), ('java', 63), ('go', 375), ('nodejs', 436)]) def test_node(self, name, node_id): path = 'api/nodes/show.json?name=%s' %(name) url = self.domain + path res = requests.get(url).json() assert res['name'] == name assert res['id'] == node_id &gt; assert 0 E assert 0 v2ex_api_test.py:40: AssertionError ================================================================ 8 failed, 1 passed in 1.81 seconds ================================================================= 11.生成xml格式的测试报告 pytest有非常友好的命令行报告输出，在做用例开发的时候，这是极好的。然而我们在运行用例后经常会需要将测试结果广而告之，发送给相关责任人浏览，所以生成简洁美观的测试报告是很有必要的。 生成junit格式的xml报告 pytest可以生成junit格式的xml报告，在命令行中加入--junit-xml=path 参数就可以了。 pytest test_quick_start.py --junit-xml=report.xml 上面的命令在当前文件夹中生成了名为report.xml的测试报告 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;testsuite errors=&quot;0&quot; failures=&quot;0&quot; name=&quot;pytest&quot; skips=&quot;0&quot; tests=&quot;1&quot; time=&quot;0.009&quot;&gt;&lt;testcase classname=&quot;test_quick_start&quot; file=&quot;test_quick_start.py&quot; line=&quot;3&quot; name=&quot;test_reverse&quot; time=&quot;0.000499725341797&quot;&gt;&lt;/testcase&gt;&lt;/testsuite&gt;% ci集成 jenkins在build后可以通过插件展示junit格式的测试报告，具体步骤就不描述了。 ","link":"https://preszang.github.io/post/3oHikQsbE/"},{"title":"关于软件测试和软件测试人员","content":"一、软件测试人员应该居安思危 身为测试人员，虽然我们平常的工作相对比较安逸。 但是千万不能温水煮青蛙。 应该自强不息， 要像开发人员一样， 不断学习，提高自己的编程水平。 二、测试人员应该比开发人员更熟悉业务需求 1. 测试人员的水平主要体现在测试用例的设计上。 要设计出全面，覆盖广的测试用例，需要测试人员对自己所测试的项目的业务需求非常熟悉，甚至要比开发人员还要熟悉。 2. 这些业务知识非常有用的，学习起来比较有激情。 3. 要熟读功能需求文档， 任何有疑问的地方都要去和PM确认。 4. 把自己当成最终用户， 经常使用自己所测试的软件。模拟用户的行为。 5. 熟记软件的每个功能。 三、学会如何跟开发人员相处 1. 测试人员必须跟开发人员密切合作， 所以跟开发人员搞好关系是相当重要的。 2. 和开发人员成为朋友，熟悉了干啥都方便 3. 不要打扰开发人员，看到开发在聚精会神写代码的时候，千万不要去打扰人家。 写代码需要集中精力，如果被打扰，就会中断思考。 4. 集中问问题。把需要问的问题都总结起来， 集中起来问开发，这样能节省大量的时间。 5. 提好的Bug，不被开发人员烦。如果开发人员看到一个Bug 描述不清楚，还无法重现，他肯定会骂测试人员。 所以测试人员一定要写好Bug，描述精确，简洁，没有歧义，详细简洁的重现步骤，加截图。 四、测试人员应该懂一些基本的编程 1. 你的产品是用`php` 开发的，那测试人员应该有`php`的入门知识。 如果架构是微服务，那起码要懂得一些`RPC`相关的东西吧。 2. 你测试web程序，你起码要了解`HTML`、`CSS`、 `Javascript`、` Jquery`吧，否则你测了一两年web程序，都不知道这东西是怎么做的，悲剧了吧。 3. 只有懂代码你才能和开发人员交流，不被开发鄙视。 五、测试人员搭建开发环境 1. 项目的代码是最好的学习资料了，我们不能总跟在开发屁股后面做测试，不能老是等开发`build`一个版本后，我们就测试这个版本，开发`commit`了什么代码，测试人员一点都不知道。 2. 偶尔我们应该了解下产品代码是怎么设计的，了解下开发人员是如何修复bug的。 3. 说不定编程水平高了，还能帮开发做`code review`。 4. 使用工具把代码`check out`到本机。 经常看看代码，尤其是经常看看开发修复bug时候提交的代码，事半功倍。 六、写文档是测试人员的核心能力 1. 多写写博客，写写文档，多总结。 2. 测试后期应该做交叉测试，就是指两个测试工程师，互相交换下测试的项目。 这样做有很多好处。 3. 有利于找出bug, 测试工程师测久了自己的项目，容易形成眼盲。会对一些Bug熟视无睹。 4. 有利于知识和业务共享，避免人员离职，请假，造成无人测试的情况。 5. 测试思想不一样，可以互相找出很多问题 七、测试人员的瓶颈 黑盒测试工作做个两三年，基本上就能掌握测试需要的大部分知识， 很多人就感觉到发展瓶颈了，每天重复测试，学不到东西，很快就会对测试工作失去激情。 学不到东西，技术水平低下，是测试这个行业最大的毛病。 如何突破瓶颈？ 我也不知道。 八、尽量实现自动化 1. 抽时间尽量把自己的测试工作实现自动化，可以节省测试的时间，提高自己的技术水平，也可以避免老是重复测试，~~也为了更方便的摸鱼~~ 九、自动化测试VS手动测试 1. 自动化是趋势， 只会做手工测试的人，以后肯定会失去竞争力。 2. 自动化测试的技术和开发用到的技术相差太远。 3. 努力学习编码，然后用于测试，才是正道 十、优秀的测试人员非常稀少 1. 想把测试做好非常不容易 2. 优秀的测试人员需要很广的知识面，良好的沟通能力（不但要和开发人员和项目经理打交道，还要跟其他组的人交流）。 3. 丰富的测试经验，对测试工作有极大的热情， 耐心。 4. 还需要测试人员有丰富的业务知识 5. 还要会写代码。 十一、尽量少用UI自动化测试，多使用单元测试，接口测试 1. 能找到`bug`的自动化测试，才是有用的，否则就是个噱头 2. `UI`自动化测试比较不稳定，对于测试结果的分析也困难。 3. 而且`UI`改动也大。 所以应该尽量多做一些底层的的自动化测试， ","link":"https://preszang.github.io/post/关于软件测试和软件测试人员/"},{"title":"【女儿情】叶锐文版本","content":" ","link":"https://preszang.github.io/post/nu-er-qing-xie-rui-wen-ban-ben/"},{"title":"Pyunit测试框架基本教程","content":"1. 基本概念 unittest是python自带的单元测试框架，有时候又被称为&quot;PyUnit&quot;，是python版本的JUint实现。 该框架的作者是 Kent Beck和Erich Gamma，感谢祖师爷赏饭吃。 在学习使用unittest库之前，我们需要了解一下unittest库的一些重要概念: test fixture: 代表了用例执行前的准备工作和用例执行之后的清理工作。比如在用例执行前创建临时文件和文件夹，又或者启动1个server进程等； test case: 测试用例，这个相信大家都不陌生。是测试的最小单位，一般检查一组输入的响应(输出)是否符合预期。unittest模块提供了TestCase类来帮助我们创建测试用例； test suite: 经常被翻译成&quot;测试套件&quot;，也有人称为&quot;测试套&quot;，是测试用例或测试套件的集合，一般用来把需要一起执行的用例组合到一起; test runner: 用来执行测试用例并输出测试结果的组件。可以是图形界面或命令行界面; test fixture的功能可以理解成是初始化和清理测试数据及环境 test case是测试用例 test suite是用例集合 test runner的作用是运行用例并返回结果 2. 基本用法 我们通过最简单的例子来看一下unittest的基本用法，下面的代码测试了3个python字符串方法，基本上满足了大部分情况下的测试需求 import unittest class TestStringMethods(unittest.TestCase): def test_upper(self): self.assertEqual('foo'.upper(), 'FOO') def test_isupper(self): self.assertTrue('FOO'.isupper()) self.assertFalse('Foo'.isupper()) def test_split(self): s = 'hello world' self.assertEqual(s.split(), ['hello', 'world']) # check that s.split fails when the separator is not a string with self.assertRaises(TypeError): s.split(2) if __name__ == '__main__': unittest.main() 解释一下关键点 可以通过继承unittest.TestCase类来定义我们自己的测试用例，1个测试用例类下面可以有多个测试方法(test)或者叫做测试点 记住这个套路：测试用例中方法名以test开头的方法才是测试方法，比如上面的例子里定义了3个以test开头的方法，分别是test_upper，test_isupper和test_split。非测试方法是不会被test runner执行的 断言是测试用例的核心。我们使用assertEqual()来判断预期结果，用assertTrue()和assertFalse来做是非判断，以及用assertRaises()来判断预期的异常是否有被抛出。这些unittest提供的以assert开头的方法就是断言，一般情况下,每个测试方法里都必须有断言 最后, unittest.main提供了最简单的运行用例的方式。当我们从命令行运行上面的代码时，我们可以看到如下的输出 ... ---------------------------------------------------------------------- Ran 3 tests in 0.000s OK 除了使用unittest.main，还有其他的方式可以运行测试用例，比如把最后2行替换为 suite = unittest.TestLoader().loadTestsFromTestCase(TestStringMethods) unittest.TextTestRunner(verbosity=2).run(suite) 运行用例，结果将会如下所示 test_isupper (__main__.TestStringMethods) ... ok test_split (__main__.TestStringMethods) ... ok test_upper (__main__.TestStringMethods) ... ok ---------------------------------------------------------------------- Ran 3 tests in 0.001s OK 3. 实例: 测试弱密码 我们需要判断用户的密码中包含简单密码，规则是这样的，密码必须至少6位，满足6位的话判断用户的密码不是password123或者password之类的弱密码。 对于如下的测试数据，我们要如何使用unittest来进行相关测试呢？ [ {&quot;name&quot;:&quot;jack&quot;,&quot;password&quot;:&quot;Iloverose&quot;}, {&quot;name&quot;:&quot;rose&quot;,&quot;password&quot;:&quot;Ilovejack&quot;}, {&quot;name&quot;:&quot;tom&quot;,&quot;password&quot;:&quot;password123&quot;} ] Test fixture 前文我们也说过，text fixture的主要功能是初始化测试数据或环境以及清理测试数据或环境。 考虑上面的例子，对我们而言，在用例执行之前初始化上面的测试数据是有必要的，我们可以把上面的数据用python的数据结构来表示，比较合适的数据结构是python的字典。这样做有如下的好处 统一初始化一些需要在多个用例之间共享的数据 可以在初始化的时候做一些数据的处理工作，比如过滤一些无效数据等 Test fixture最简单的实现方式是通过自定义下面的2个方法: TestCase.setUp方法在每个测试方法运行之前都会运行一次，适合为每个用例都初始化一遍数据 TestCase.tearDown方法在每个测试方法运行之后都会运行一次，适合为每个用例都清理一遍数据 代码 新建名为test_password_1.py的文本文件，输入如下内容 import unittest class PasswordTestCase(unittest.TestCase): def setUp(self): print('set up') self.test_data = [ dict(name='jack', password='Iloverose'), dict(name='rose', password='Ilovejack'), dict(name='tom', password='password123') ] def test_weak_password(self): for data in self.test_data: passwd = data['password'] self.assertTrue(len(passwd) &gt;= 6) msg = &quot;user %s has a weak password&quot; %(data['name']) self.assertTrue(passwd != 'password', msg) self.assertTrue(passwd != 'password123', msg) def test_dummy(self): pass if __name__ == '__main__': unittest.main() 运行 在命令行里输入 python test_password_1.py来运行用例，结果如下 $ python test_password_1.py set up .set up F ====================================================================== FAIL: test_week_password (__main__.PasswordTestCase) ---------------------------------------------------------------------- Traceback (most recent call last): File &quot;test_password_1.py&quot;, line 21, in test_week_password self.assertTrue(passwd != 'password123', msg) AssertionError: False is not true : user tom has a weak password ---------------------------------- Ran 2 tests in 0.001s FAILED (failures=1) 解释一下 setUp方法运行了2次，所以打印出了2次'set up'，这是因为上面的用例中有2个测试方法(2个方法名以test开头的方法)，setUp会在每个测试方法执行之前执行1次 由于用户tom的密码是弱密码password123，所以上面的用例运行失败了，打印出1个&quot;F&quot;，有几个F就代表有几个测试用例失败 测试方法运行失败时测试结果里会打印出失败方法的方法名，因此好的测试方法名可以方便我们快速找出失败用例 为了让错误信息更加容易理解，我们经常会自定义断言出错提示消息，比如msg = &quot;user %s has a weak password&quot; %(data['name'])。一旦断言失败，我们一眼就能看出是哪个用户的密码强度不够 亲自动手试一试 假设我们增加1条测试数据，如下所示 [ {&quot;name&quot;:&quot;jack&quot;,&quot;password&quot;:&quot;Iloverose&quot;}, {&quot;name&quot;:&quot;rose&quot;,&quot;password&quot;:&quot;Ilovejack&quot;}, {&quot;name&quot;:&quot;tom&quot;,&quot;password&quot;:&quot;password123&quot;}, {&quot;name&quot;:&quot;jerry&quot;,&quot;password&quot;:&quot;password&quot;} ] 再运行上面的用例，观察一下测试结果是否会有不同？如果没有不同，那是为什么？ 4. 实例: 读取测试数据并测试弱密码 接上一节的弱密码例子，我们的用例尽管运行的不错，但还是有点问题。 假如我们需要增加一些测试数据，那么我们就必须去修改setUp方法，在test_data列表中增加数据，\b频繁修改代码以适应一些不变的测试场景，这是没有必要的开销，可以想办法去优化。 我们可以把测试数据保存在文件里，通过读取文件的方式，每次动态从测试用例读取数据，这样数据的改变并不会影响用例，用例逻辑相对稳定，维护成本得到一定的降低。 设计测试数据 我们可以把测试数据保存成json格式，json格式的数据在各个语言间有较好的通用性，比较适合复用。 新建user_data.json文件，内容如下 [ {&quot;name&quot;:&quot;jack&quot;,&quot;password&quot;:&quot;Iloverose&quot;}, {&quot;name&quot;:&quot;rose&quot;,&quot;password&quot;:&quot;Ilovejack&quot;}, {&quot;name&quot;:&quot;tom&quot;,&quot;password&quot;:&quot;password123&quot;} ] 使用python的json库解析上面的json文件，可以得到如上节中test_data一致的数据。 代码 新建test_password_2.py，内容如下 import unittest import json class PasswordWithJsonTestCase(unittest.TestCase): data_file_path = './user_data.json' def setUp(self): print('set up') self.test_data = json.loads(open(self.data_file_path).read()) def test_weak_password(self): for data in self.test_data: passwd = data['password'] self.assertTrue(len(passwd) &gt;= 6) msg = &quot;user %s has a weak password&quot; %(data['name']) self.assertTrue(passwd != 'password', msg) self.assertTrue(passwd != 'password123', msg) def test_dummy(self): pass if __name__ == '__main__': unittest.main() 跟上一节相比，最大的不同点是现在test_data通过解析json文件的方式来赋值self.test_data = json.loads(open(self.data_file_path).read())。 执行测试文件，结果应该与上一节一致。 发现问题 上面的代码有2个测试方法:test_week_password和test_dummy。由于setUp会在每个测试方法执行之前执行一次，那么setUp方法会执行2次，相应的json文件也会读取2次。如果测试方法多的话，那么反复读取json文件对性能来说是一个巨大的挑战。 优化 对于上面的测试数据读取场景，我们可以在所有测试方法执行前读取一次数据，毕竟测试数据在所有测试方法执行过程中是保持不变的。 setUpClass()和tearDownClass() setUpClass方法在每个测试用例类执行之前会执行一次，接收该class作为唯一的参数，并且必须使用装饰器classmethod() tearDownClass: 在所有测试方法执行完之后被调用1次，调用方式跟上面的方法类似 重构 下面我们重构代码以达到只读取1次测试数据的目的，新建文件``test_password_3.py`，内容如下 import unittest import json class WeakPasswordTestCase(unittest.TestCase): @classmethod def setUpClass(kls): data_file_path = './user_data.json' print('before all test methods') with open(data_file_path) as f: kls.test_data = json.loads(f.read()) def test_weak_password(self): for data in self.test_data: passwd = data['password'] self.assertTrue(len(passwd) &gt;= 6) msg = &quot;user %s has a weak password&quot; %(data['name']) self.assertTrue(passwd != 'password', msg) 5. 实例: 找出所有是弱密码的用户 当我们的测试数据是下面这些的时候，我们的用例是有问题的。 [ {&quot;name&quot;:&quot;jack&quot;,&quot;password&quot;:&quot;Iloverose&quot;}, {&quot;name&quot;:&quot;rose&quot;,&quot;password&quot;:&quot;Ilovejack&quot;}, {&quot;name&quot;:&quot;tom&quot;,&quot;password&quot;:&quot;password123&quot;}, {&quot;name&quot;:&quot;jerry&quot;,&quot;password&quot;:&quot;password&quot;} ] 我们的用例只能找出tom是弱密码的用户，jerry这个用户会成为漏网之鱼。 为什么 这是因为在unittest中，一旦某个测试方法中的断言失败，后续的断言都不会被执行。 还原一下上面的例子，当用例在断言tom失败后，for循环就退出了，测试方法也执行完毕了，后面jerry这条数据就不会被断言。 怎么办 我们可以重构一下我们的用例，让整个用例只断言1次，断言失败以后就把弱密码的用户打印出来。 代码 修改user_data.json文件，加入一些测试数据，修改后的user_data.json文件应该是 [ {&quot;name&quot;:&quot;jack&quot;,&quot;password&quot;:&quot;Iloverose&quot;}, {&quot;name&quot;:&quot;rose&quot;,&quot;password&quot;:&quot;Ilovejack&quot;}, {&quot;name&quot;:&quot;tom&quot;,&quot;password&quot;:&quot;password123&quot;}, {&quot;name&quot;:&quot;jerry&quot;,&quot;password&quot;:&quot;password&quot;}, {&quot;name&quot;:&quot;fred&quot;,&quot;password&quot;:&quot;123456&quot;}, {&quot;name&quot;:&quot;elma&quot;,&quot;password&quot;:&quot;654321&quot;} ] 新建test_password_4.py文件，内容如下 import unittest import json class WeakPasswordTestCase1(unittest.TestCase): @classmethod def setUpClass(kls): data_file_path = './user_data.json' print('before all test methods') with open(data_file_path) as f: kls.test_data = json.loads(f.read()) def test_weak_password(self): res = True msg = [] for data in self.test_data: passwd = data['password'] tmp_res = True tmp_res = tmp_res and (len(passwd) &gt;= 6) tmp_res = tmp_res and (passwd != 'password') tmp_res = tmp_res and (passwd != 'password123') if not tmp_res: msg.append(&quot;user %s has a weak password %s&quot; %(data['name'], data['password'])) res = res and tmp_res self.assertTrue(res, &quot;\\n&quot;.join(msg)) def test_dummy(self): pass if __name__ == '__main__': unittest.main() 运行及结果 在命令行中运行python test_password_4.py，结果如下 $ python test_password_4.py before all test methods .F ====================================================================== FAIL: test_weak_password (__main__.WeakPasswordTestCase1) ---------------------------------------------------------------------- Traceback (most recent call last): File &quot;test_password_4.py&quot;, line 27, in test_week_password self.assertTrue(res, &quot;\\n&quot;.join(msg)) AssertionError: user tom has a weak password password123 user jerry has a weak password password ---------------------------------------------------------------------- Ran 2 tests in 0.001s FAILED (failures=1) 我们能学到什么 断言一旦失败之后测试方法就会结束运行，所以一般来说1个测试方法推荐只有1个断言 如果一个测试方法里面必须要有多个断言，那么要确保前面的断言失败之后，后面的断言就算不运行也不会影响测试的范围和结果 for循环中的断言一旦失败，for循环就退出了 上面演示的测试用例写法其实具备了一定的数据驱动测试的思想 6. 命令行接口 unittest支持命令行接口，我们可以在命令行里指定运行具体的测试用例。 在test_password_1.py中定义了PasswordTeseCase用例，我们可以从命令行中指定只运行该用例。 $ python -m unittest test_password_1.PasswordTeseCase set up .set up F ====================================================================== FAIL: test_week_password (test_password_1.PasswordTeseCase) ---------------------------------------------------------------------- Traceback (most recent call last): File &quot;/Users/aaa/code/test_password_1.py&quot;, line 21, in test_week_password self.assertTrue(passwd != 'password123', msg) AssertionError: False is not true : user tom has a weak password ---------------------------------------------------------------------- Ran 2 tests in 0.001s FAILED (failures=1) 还可以使用-v参数来获得更详细的输出 $ python -m unittest test_password_1.PasswordTeseCase -v test_dummy (test_password_1.PasswordTeseCase) ... set up ok test_week_password (test_password_1.PasswordTeseCase) ... set up FAIL ====================================================================== ### FAIL: test_week_password (test_password_1.PasswordTeseCase) Traceback (most recent call last): File &quot;/Users/aaa/code/test_password_1.py&quot;, line 21, in test_week_password self.assertTrue(passwd != 'password123', msg) AssertionError: False is not true : user tom has a weak password ---------------------------------------------------------------------- Ran 2 tests in 0.001s FAILED (failures=1) 7. 各种断言方法 unittest支持各种断言方法。 断言列表---官方文档 方法 检查点 assertEqual(a, b) a == b assertNotEqual(a, b) a != b assertTrue(x) bool(x) is True assertFalse(x) bool(x) is False assertIs(a, b) a is b assertIsNot(a, b) a is not b assertIsNone(x) x is None assertIsNotNone(x) x is not None assertIn(a, b) a in b assertNotIn(a, b) a not in b assertIsInstance(a, b) isinstance(a, b) assertNotIsInstance(a, b) not isinstance(a, b) assertRaises(exc, fun, *args, **kwds) fun(*args, **kwds) raises exc assertRaisesRegexp(exc, r, fun, *args, **kwds) fun(*args, **kwds) raises exc and the message matches regex r assertAlmostEqual(a, b) round(a-b, 7) == 0 assertNotAlmostEqual(a, b) round(a-b, 7) != 0 assertGreater(a, b) a &gt; b 2.7 assertGreaterEqual(a, b) a &gt;= b assertLess(a, b) a &lt; b assertLessEqual(a, b) a &lt;= b assertRegexpMatches(s, r) r.search(s) assertNotRegexpMatches(s, r) not r.search(s) assertItemsEqual(a, b) sorted(a) == sorted(b) 也支持unhashable对象 assertDictContainsSubset(a, b) a里面所有的键值对都在b中存在 8. 断言异常 我们有时候需要断言一些方法会抛出异常，这些异常需要符合我们的预期。 新建test_exception.py文件，内容如下 import unittest class DivZeroTestCase(unittest.TestCase): def test_should_raise_exception(self): with self.assertRaises(ZeroDivisionError): 1 / 0 if __name__ == '__main__': unittest.main() 运行及结果 $ python test_exception.py ---------------------------------------------------------------------- Ran 1 test in 0.000s OK 上面的例子断言了当0作为除数的时候会抛出ZeroDivisionError 断言异常是有套路的，使用with语句加assertRaises，assertRaises的参数中传入预期的异常(这些异常可能需要先import进来)，在with的子句中放上会抛出异常的语句或表达式。 ","link":"https://preszang.github.io/post/Pyunit测试框架基本教程/"},{"title":"Python 第三方日志框架 loguru 使用","content":"Python 第三方日志框架 loguru 使用 看到了一个不错的 python 第三方日志框架 loguru，优雅的记录日志 Github: https://github.com/Delgan/loguru 文档：https://loguru.readthedocs.io/en/stable/index.html 1、安装 pip install loguru 2、输出日志 from loguru import logger logger.debug(&quot;这是一条debug日志&quot;) # 终端执行后出现带颜色的日志，挺酷的 3、输出到文件 from loguru import logger logger.add(&quot;file_{time}.log&quot;) logger.debug(&quot;这是一条debug日志&quot;) logger.info(&quot;这是一条info日志&quot;) # 目录下多出一个日志文件 ：file_2019-03-14_19-53-25_661314.log 4、日志规则 from loguru import logger # 设置日志格式，过滤器，日志级别 logger.add(&quot;file.log&quot;, format=&quot;{time} {level} {message}&quot;, filter=&quot;&quot;, level=&quot;INFO&quot;) logger.debug(&quot;这是一条debug日志&quot;) logger.info(&quot;这是一条info日志&quot;) #输出 # 2019-03-14T20:01:25.392454+0800 INFO 这是一条info日志 5、日志文件 # 文件管理方式 logger.add(&quot;file_1.log&quot;, rotation=&quot;500 MB&quot;) # 文件过大就会重新生成一个文件 logger.add(&quot;file_2.log&quot;, rotation=&quot;12:00&quot;) # 每天12点创建新文件 logger.add(&quot;file_3.log&quot;, rotation=&quot;1 week&quot;) # 文件时间过长就会创建新文件 logger.add(&quot;file_X.log&quot;, retention=&quot;10 days&quot;) # 一段时间后会清空 logger.add(&quot;file_Y.log&quot;, compression=&quot;zip&quot;) # 保存zip格式 6、其他参数 logger.add(&quot;somefile.log&quot;, enqueue=True) # 异步写入 logger.add(&quot;somefile.log&quot;, serialize=True) # 序列化为json 7、时间格式化 logger.add(&quot;file.log&quot;, format=&quot;{time:YYYY-MM-DD at HH:mm:ss} | {level} | {message}&quot;) 配合 notifiers 模块 github： https://github.com/notifiers/notifiers 文档：https://notifiers.readthedocs.io/en/latest/ 8、在工程中创建多个文件处理器对象并解决中文乱码问题 # coding=utf-8 import os import sys from loguru import logger BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) log_file_path = os.path.join(BASE_DIR, 'Log/my.log') err_log_file_path = os.path.join(BASE_DIR, 'Log/err.log') logger.add(sys.stderr, format=&quot;{time} {level} {message}&quot;, filter=&quot;my_module&quot;, level=&quot;INFO&quot;) # logger.add(s) logger.add(log_file_path, rotation=&quot;500 MB&quot;, encoding='utf-8') # Automatically rotate too big file logger.add(err_log_file_path, rotation=&quot;500 MB&quot;, encoding='utf-8',level='ERROR') # Automatically rotate too big file logger.debug(&quot;That's it, beautiful and simple logging!&quot;) logger.debug(&quot;中文日志可以不&quot;) logger.error(&quot;严重错误&quot;) ","link":"https://preszang.github.io/post/Python 第三方日志框架 loguru 使用/"},{"title":"【山雀】万能青年旅店","content":" ","link":"https://preszang.github.io/post/shan-que-wan-neng-qing-nian-lu-dian/"}]}