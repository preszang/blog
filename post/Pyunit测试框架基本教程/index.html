<html>
<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>Pyunit测试框架基本教程 | 霜序五</title>

<link rel="shortcut icon" href="https://preszang.github.io/favicon.ico?v=1612774214992">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://preszang.github.io/styles/main.css">
<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css"> -->

<style>
    hr {
        margin-top: 1rem;
        margin-bottom: 1rem;
        border: 0;
        border-top: 1px solid rgba(0, 0, 0, 0.1);
    }
</style>

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>

<!-- <script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script> -->
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->


    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <style>
    /* 导航栏样式 */
    .navbar {
        position: relative;
        display: -ms-flexbox;
        display: flex;
        -ms-flex-wrap: wrap;
        flex-wrap: wrap;
        -ms-flex-align: center;
        align-items: center;
        -ms-flex-pack: justify;
        justify-content: space-between;
        padding: 0.5rem 1rem;
    }

    .navbar-brand {
        display: inline-block;
        padding-top: 0.3125rem;
        padding-bottom: 0.3125rem;
        margin-right: 1rem;
        font-size: 1.25rem;
        line-height: inherit;
        white-space: nowrap;
    }

    .navbar-brand:hover,
    .navbar-brand:focus {
        text-decoration: none;
    }

    .navbar-nav {
        display: -ms-flexbox;
        display: flex;
        -ms-flex-direction: column;
        flex-direction: column;
        padding-left: 0;
        margin-bottom: 0;
        list-style: none;
    }

    .navbar-collapse {
        -ms-flex-preferred-size: 100%;
        flex-basis: 100%;
        -ms-flex-positive: 1;
        flex-grow: 1;
        -ms-flex-align: center;
        align-items: center;
    }

    .navbar-toggler {
        padding: 0.25rem 0.75rem;
        font-size: 1.25rem;
        line-height: 1;
        background-color: transparent;
        border: 1px solid transparent;
        border-radius: 0.25rem;
    }

    .navbar-toggler:hover,
    .navbar-toggler:focus {
        text-decoration: none;
    }

    @media (min-width: 992px) {
        .navbar-expand-lg {
            -ms-flex-flow: row nowrap;
            flex-flow: row nowrap;
            -ms-flex-pack: start;
            justify-content: flex-start;
        }

        .navbar-expand-lg .navbar-nav {
            -ms-flex-direction: row;
            flex-direction: row;
        }

        .navbar-expand-lg .navbar-collapse {
            display: -ms-flexbox !important;
            display: flex !important;
            -ms-flex-preferred-size: auto;
            flex-basis: auto;
        }

        .navbar-expand-lg .navbar-toggler {
            display: none;
        }
    }

    @media (max-width: 991px) {
        #navbarSupportedContent {
            display: none;
        }
    }
</style>
<nav class="navbar navbar-expand-lg">
    <div class="navbar-brand">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            霜序五
        </div>
    </div>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
        aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
            <div class="nav-item">
                
                <a href="/" class="menu gt-a-link">
                    首页
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/archives" class="menu gt-a-link">
                    归档
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/tags" class="menu gt-a-link">
                    标签
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/post/about" class="menu gt-a-link">
                    关于
                </a>
                
            </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1612774214992"
                action="/search/index.html">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>
<script>
    /* 移动端导航栏展开/收起切换 */
    document.getElementById('changeNavbar').onclick = function () {
        var element = document.getElementById('navbarSupportedContent');
        if (element.style.display === 'none' || element.style.display === '') {
            element.style.display = 'block';
        } else {
            element.style.display = 'none';
        }
    }
</script>
    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    Pyunit测试框架基本教程
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2021-02-08 ·
                    </time>
                    
                        <a href="https://preszang.github.io/tag/ruan-jian-ce-shi/" class="post-tags">
                            # 软件测试
                        </a>
                    
                </div>
                <div class="post-content">
                    <h3 id="1-基本概念">1. 基本概念</h3>
<blockquote>
<p><a href="https://docs.python.org/3/library/unittest.html#module-unittest">unittest</a>是python自带的单元测试框架，有时候又被称为&quot;PyUnit&quot;，是python版本的<a href="http://junit.org/">JUint</a>实现。</p>
<p>该框架的作者是 Kent Beck和Erich Gamma，感谢祖师爷赏饭吃。</p>
<p>在学习使用unittest库之前，我们需要了解一下unittest库的一些重要概念:</p>
<ul>
<li><strong>test fixture</strong>: 代表了用例执行前的准备工作和用例执行之后的清理工作。比如在用例执行前创建临时文件和文件夹，又或者启动1个server进程等；</li>
<li><strong>test case</strong>: 测试用例，这个相信大家都不陌生。是测试的最小单位，一般检查一组输入的响应(输出)是否符合预期。<a href="https://docs.python.org/3/library/unittest.html#module-unittest">unittest</a>模块提供了<a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase">TestCase</a>类来帮助我们创建测试用例；</li>
<li><strong>test suite</strong>: 经常被翻译成&quot;测试套件&quot;，也有人称为&quot;测试套&quot;，是测试用例或测试套件的集合，一般用来把需要一起执行的用例组合到一起;</li>
<li><strong>test runner</strong>: 用来执行测试用例并输出测试结果的组件。可以是图形界面或命令行界面;</li>
</ul>
</blockquote>
<ul>
<li>test fixture的功能可以理解成是初始化和清理测试数据及环境</li>
<li>test case是测试用例</li>
<li>test suite是用例集合</li>
<li>test runner的作用是运行用例并返回结果</li>
</ul>
<h3 id="2-基本用法">2. 基本用法</h3>
<blockquote>
<p>我们通过最简单的例子来看一下unittest的基本用法，下面的代码测试了3个python字符串方法，基本上满足了大部分情况下的测试需求</p>
</blockquote>
<pre><code class="language-python">import unittest

class TestStringMethods(unittest.TestCase):

    def test_upper(self):
        self.assertEqual('foo'.upper(), 'FOO')

    def test_isupper(self):
        self.assertTrue('FOO'.isupper())
        self.assertFalse('Foo'.isupper())

    def test_split(self):
        s = 'hello world'
        self.assertEqual(s.split(), ['hello', 'world'])
        # check that s.split fails when the separator is not a string
        with self.assertRaises(TypeError):
            s.split(2)

if __name__ == '__main__':
    unittest.main()
</code></pre>
<p>解释一下关键点</p>
<ul>
<li>可以通过继承<a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase">unittest.TestCase</a>类来定义我们自己的测试用例，1个测试用例类下面可以有多个测试方法(test)或者叫做测试点</li>
<li>记住这个套路：测试用例中方法名以<code>test</code>开头的方法才是测试方法，比如上面的例子里定义了3个以test开头的方法，分别是<code>test_upper</code>，<code>test_isupper</code>和<code>test_split</code>。非测试方法是不会被test runner执行的</li>
<li>断言是测试用例的核心。我们使用<a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertEqual">assertEqual()</a>来判断预期结果，用<a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertTrue">assertTrue()</a>和<a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertFalse">assertFalse</a>来做是非判断，以及用<a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertRaises">assertRaises()</a>来判断预期的异常是否有被抛出。这些unittest提供的以assert开头的方法就是断言，一般情况下,每个测试方法里都必须有断言</li>
<li>最后, <a href="https://docs.python.org/3/library/unittest.html#unittest.main">unittest.main</a>提供了最简单的运行用例的方式。当我们从命令行运行上面的代码时，我们可以看到如下的输出</li>
</ul>
<pre><code class="language-bash">...
----------------------------------------------------------------------
Ran 3 tests in 0.000s

OK
</code></pre>
<p>除了使用<a href="https://docs.python.org/3/library/unittest.html#unittest.main">unittest.main</a>，还有其他的方式可以运行测试用例，比如把最后2行替换为</p>
<pre><code class="language-bash">suite = unittest.TestLoader().loadTestsFromTestCase(TestStringMethods)
unittest.TextTestRunner(verbosity=2).run(suite)
</code></pre>
<p>运行用例，结果将会如下所示</p>
<pre><code class="language-bash">test_isupper (__main__.TestStringMethods) ... ok
test_split (__main__.TestStringMethods) ... ok
test_upper (__main__.TestStringMethods) ... ok

----------------------------------------------------------------------
Ran 3 tests in 0.001s

OK
</code></pre>
<h3 id="3-实例-测试弱密码">3. 实例: 测试弱密码</h3>
<blockquote>
<p>我们需要判断用户的密码中包含简单密码，规则是这样的，密码必须至少6位，满足6位的话判断用户的密码不是password123或者password之类的弱密码。</p>
<p>对于如下的测试数据，我们要如何使用unittest来进行相关测试呢？</p>
</blockquote>
<pre><code class="language-json">[
  {&quot;name&quot;:&quot;jack&quot;,&quot;password&quot;:&quot;Iloverose&quot;},
  {&quot;name&quot;:&quot;rose&quot;,&quot;password&quot;:&quot;Ilovejack&quot;},
  {&quot;name&quot;:&quot;tom&quot;,&quot;password&quot;:&quot;password123&quot;}
]
</code></pre>
<h4 id="test-fixture">Test fixture</h4>
<p>前文我们也说过，text fixture的主要功能是初始化测试数据或环境以及清理测试数据或环境。</p>
<p>考虑上面的例子，对我们而言，在用例执行之前初始化上面的测试数据是有必要的，我们可以把上面的数据用python的数据结构来表示，比较合适的数据结构是python的字典。这样做有如下的好处</p>
<ul>
<li>统一初始化一些需要在多个用例之间共享的数据</li>
<li>可以在初始化的时候做一些数据的处理工作，比如过滤一些无效数据等</li>
</ul>
<p>Test fixture最简单的实现方式是通过自定义下面的2个方法:</p>
<ul>
<li><code>TestCase.setUp</code>方法在每个测试方法运行之前都会运行一次，适合为每个用例都初始化一遍数据</li>
<li><code>TestCase.tearDown</code>方法在每个测试方法运行之后都会运行一次，适合为每个用例都清理一遍数据</li>
</ul>
<h4 id="代码">代码</h4>
<p>新建名为<code>test_password_1.py</code>的文本文件，输入如下内容</p>
<pre><code class="language-python">import unittest

class PasswordTestCase(unittest.TestCase):

    def setUp(self):
        print('set up')
        self.test_data = [
            dict(name='jack', password='Iloverose'),
            dict(name='rose', password='Ilovejack'),
            dict(name='tom', password='password123')
        ]

    def test_weak_password(self):
        for data in self.test_data:
            passwd = data['password']

            self.assertTrue(len(passwd) &gt;= 6)

            msg = &quot;user %s has a weak password&quot; %(data['name'])
            self.assertTrue(passwd != 'password', msg)
            self.assertTrue(passwd != 'password123', msg)

    def test_dummy(self):
        pass

if __name__ == '__main__':
    unittest.main()
</code></pre>
<h4 id="运行">运行</h4>
<p>在命令行里输入 <code>python test_password_1.py</code>来运行用例，结果如下</p>
<pre><code class="language-bash">$ python test_password_1.py
set up
.set up
F
======================================================================
FAIL: test_week_password (__main__.PasswordTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File &quot;test_password_1.py&quot;, line 21, in test_week_password
    self.assertTrue(passwd != 'password123', msg)
AssertionError: False is not true : user tom has a weak password

----------------------------------
Ran 2 tests in 0.001s

FAILED (failures=1)
</code></pre>
<h4 id="解释一下">解释一下</h4>
<ul>
<li>setUp方法运行了2次，所以打印出了2次'set up'，这是因为上面的用例中有2个测试方法(2个方法名以test开头的方法)，setUp会在每个测试方法执行之前执行1次</li>
<li>由于用户tom的密码是弱密码password123，所以上面的用例运行失败了，打印出1个&quot;F&quot;，有几个F就代表有几个测试用例失败</li>
<li>测试方法运行失败时测试结果里会打印出失败方法的方法名，因此好的测试方法名可以方便我们快速找出失败用例</li>
<li>为了让错误信息更加容易理解，我们经常会自定义断言出错提示消息，比如<code>msg = &quot;user %s has a weak password&quot; %(data['name'])</code>。一旦断言失败，我们一眼就能看出是哪个用户的密码强度不够</li>
</ul>
<h4 id="亲自动手试一试">亲自动手试一试</h4>
<p>假设我们增加1条测试数据，如下所示</p>
<pre><code class="language-json">[
  {&quot;name&quot;:&quot;jack&quot;,&quot;password&quot;:&quot;Iloverose&quot;},
  {&quot;name&quot;:&quot;rose&quot;,&quot;password&quot;:&quot;Ilovejack&quot;},
  {&quot;name&quot;:&quot;tom&quot;,&quot;password&quot;:&quot;password123&quot;},
  {&quot;name&quot;:&quot;jerry&quot;,&quot;password&quot;:&quot;password&quot;}
]
</code></pre>
<p>再运行上面的用例，观察一下测试结果是否会有不同？如果没有不同，那是为什么？</p>
<h3 id="4-实例-读取测试数据并测试弱密码">4. 实例: 读取测试数据并测试弱密码</h3>
<blockquote>
<p>接上一节的弱密码例子，我们的用例尽管运行的不错，但还是有点问题。</p>
<p>假如我们需要增加一些测试数据，那么我们就必须去修改<code>setUp</code>方法，在<code>test_data</code>列表中增加数据，频繁修改代码以适应一些不变的测试场景，这是没有必要的开销，可以想办法去优化。</p>
<p>我们可以把测试数据保存在文件里，通过读取文件的方式，每次动态从测试用例读取数据，这样数据的改变并不会影响用例，用例逻辑相对稳定，维护成本得到一定的降低。</p>
</blockquote>
<h4 id="设计测试数据">设计测试数据</h4>
<p>我们可以把测试数据保存成json格式，json格式的数据在各个语言间有较好的通用性，比较适合复用。</p>
<p>新建user_data.json文件，内容如下</p>
<pre><code>[
  {&quot;name&quot;:&quot;jack&quot;,&quot;password&quot;:&quot;Iloverose&quot;},
  {&quot;name&quot;:&quot;rose&quot;,&quot;password&quot;:&quot;Ilovejack&quot;},
  {&quot;name&quot;:&quot;tom&quot;,&quot;password&quot;:&quot;password123&quot;}
]
</code></pre>
<p>使用python的json库解析上面的json文件，可以得到如上节中<code>test_data</code>一致的数据。</p>
<h4 id="代码-2">代码</h4>
<p>新建<code>test_password_2.py</code>，内容如下</p>
<pre><code class="language-python">import unittest
import json

class PasswordWithJsonTestCase(unittest.TestCase):
    data_file_path = './user_data.json'

    def setUp(self):
        print('set up')
        self.test_data = json.loads(open(self.data_file_path).read())

    def test_weak_password(self):
        for data in self.test_data:
            passwd = data['password']

            self.assertTrue(len(passwd) &gt;= 6)

            msg = &quot;user %s has a weak password&quot; %(data['name'])
            self.assertTrue(passwd != 'password', msg)
            self.assertTrue(passwd != 'password123', msg)

    def test_dummy(self):
        pass

if __name__ == '__main__':
    unittest.main()
</code></pre>
<p>跟上一节相比，最大的不同点是现在test_data通过解析json文件的方式来赋值<code>self.test_data = json.loads(open(self.data_file_path).read())</code>。</p>
<p>执行测试文件，结果应该与上一节一致。</p>
<h4 id="发现问题">发现问题</h4>
<p>上面的代码有2个测试方法:<code>test_week_password</code>和<code>test_dummy</code>。由于<code>setUp</code>会在每个测试方法执行之前执行一次，那么setUp方法会执行2次，相应的json文件也会读取2次。如果测试方法多的话，那么反复读取json文件对性能来说是一个巨大的挑战。</p>
<h4 id="优化">优化</h4>
<p>对于上面的测试数据读取场景，我们可以在所有测试方法执行前读取一次数据，毕竟测试数据在所有测试方法执行过程中是保持不变的。</p>
<h4 id="setupclass和teardownclass">setUpClass()和tearDownClass()</h4>
<ul>
<li><a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.setUpClass">setUpClass</a>方法在每个测试用例类执行之前会执行一次，接收该class作为唯一的参数，并且必须使用装饰器<a href="https://docs.python.org/3/library/functions.html#classmethod">classmethod()</a></li>
<li>tearDownClass: 在所有测试方法执行完之后被调用1次，调用方式跟上面的方法类似</li>
</ul>
<h4 id="重构">重构</h4>
<p>下面我们重构代码以达到只读取1次测试数据的目的，新建文件``test_password_3.py`，内容如下</p>
<pre><code class="language-python">import unittest
import json

class WeakPasswordTestCase(unittest.TestCase):

    @classmethod
    def setUpClass(kls):
        data_file_path = './user_data.json'
        print('before all test methods')
        with open(data_file_path) as f:
            kls.test_data = json.loads(f.read())

    def test_weak_password(self):
        for data in self.test_data:
            passwd = data['password']

            self.assertTrue(len(passwd) &gt;= 6)

            msg = &quot;user %s has a weak password&quot; %(data['name'])
            self.assertTrue(passwd != 'password', msg)
</code></pre>
<h3 id="5-实例-找出所有是弱密码的用户">5. 实例: 找出所有是弱密码的用户</h3>
<blockquote>
<p>当我们的测试数据是下面这些的时候，我们的用例是有问题的。</p>
</blockquote>
<pre><code class="language-json">[
    {&quot;name&quot;:&quot;jack&quot;,&quot;password&quot;:&quot;Iloverose&quot;},
    {&quot;name&quot;:&quot;rose&quot;,&quot;password&quot;:&quot;Ilovejack&quot;},
    {&quot;name&quot;:&quot;tom&quot;,&quot;password&quot;:&quot;password123&quot;},
    {&quot;name&quot;:&quot;jerry&quot;,&quot;password&quot;:&quot;password&quot;}
]

</code></pre>
<blockquote>
<p>我们的用例只能找出tom是弱密码的用户，jerry这个用户会成为漏网之鱼。</p>
</blockquote>
<h4 id="为什么">为什么</h4>
<p>这是因为在unittest中，一旦某个测试方法中的断言失败，后续的断言都不会被执行。</p>
<p>还原一下上面的例子，当用例在断言tom失败后，for循环就退出了，测试方法也执行完毕了，后面jerry这条数据就不会被断言。</p>
<h4 id="怎么办">怎么办</h4>
<p>我们可以重构一下我们的用例，让整个用例只断言1次，断言失败以后就把弱密码的用户打印出来。</p>
<h4 id="代码-3">代码</h4>
<p>修改user_data.json文件，加入一些测试数据，修改后的user_data.json文件应该是</p>
<pre><code class="language-json">[
  {&quot;name&quot;:&quot;jack&quot;,&quot;password&quot;:&quot;Iloverose&quot;},
  {&quot;name&quot;:&quot;rose&quot;,&quot;password&quot;:&quot;Ilovejack&quot;},
  {&quot;name&quot;:&quot;tom&quot;,&quot;password&quot;:&quot;password123&quot;},
  {&quot;name&quot;:&quot;jerry&quot;,&quot;password&quot;:&quot;password&quot;},
  {&quot;name&quot;:&quot;fred&quot;,&quot;password&quot;:&quot;123456&quot;},
  {&quot;name&quot;:&quot;elma&quot;,&quot;password&quot;:&quot;654321&quot;}
]
</code></pre>
<p>新建<code>test_password_4.py</code>文件，内容如下</p>
<pre><code class="language-python">import unittest
import json

class WeakPasswordTestCase1(unittest.TestCase):

    @classmethod
    def setUpClass(kls):
        data_file_path = './user_data.json'
        print('before all test methods')
        with open(data_file_path) as f:
            kls.test_data = json.loads(f.read())
    
    def test_weak_password(self):
        res = True
        msg = []
        for data in self.test_data:
            passwd = data['password']
            tmp_res = True
    
            tmp_res = tmp_res and (len(passwd) &gt;= 6)
            tmp_res = tmp_res and (passwd != 'password')
            tmp_res = tmp_res and (passwd != 'password123')
            if not tmp_res:
                msg.append(&quot;user %s has a weak password %s&quot; %(data['name'], data['password']))
            res = res and tmp_res
    
        self.assertTrue(res, &quot;\n&quot;.join(msg))
    
    def test_dummy(self):
        pass

if __name__ == '__main__':
    unittest.main()
</code></pre>
<h4 id="运行及结果">运行及结果</h4>
<p>在命令行中运行<code>python test_password_4.py</code>，结果如下</p>
<pre><code class="language-bash">$ python test_password_4.py
before all test methods
.F
======================================================================
FAIL: test_weak_password (__main__.WeakPasswordTestCase1)
----------------------------------------------------------------------
Traceback (most recent call last):
  File &quot;test_password_4.py&quot;, line 27, in test_week_password
    self.assertTrue(res, &quot;\n&quot;.join(msg))
AssertionError: user tom has a weak password password123
user jerry has a weak password password

----------------------------------------------------------------------
Ran 2 tests in 0.001s

FAILED (failures=1)
</code></pre>
<h4 id="我们能学到什么">我们能学到什么</h4>
<ul>
<li>断言一旦失败之后测试方法就会结束运行，所以一般来说1个测试方法推荐只有1个断言</li>
<li>如果一个测试方法里面必须要有多个断言，那么要确保前面的断言失败之后，后面的断言就算不运行也不会影响测试的范围和结果</li>
<li>for循环中的断言一旦失败，for循环就退出了</li>
<li>上面演示的测试用例写法其实具备了一定的数据驱动测试的思想</li>
</ul>
<h3 id="6-命令行接口">6. 命令行接口</h3>
<blockquote>
<p>unittest支持命令行接口，我们可以在命令行里指定运行具体的测试用例。</p>
</blockquote>
<p>在<code>test_password_1.py</code>中定义了<code>PasswordTeseCase</code>用例，我们可以从命令行中指定只运行该用例。</p>
<pre><code class="language-bash">$ python -m unittest test_password_1.PasswordTeseCase
set up
.set up
F
======================================================================
FAIL: test_week_password (test_password_1.PasswordTeseCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File &quot;/Users/aaa/code/test_password_1.py&quot;, line 21, in test_week_password
    self.assertTrue(passwd != 'password123', msg)
AssertionError: False is not true : user tom has a weak password

----------------------------------------------------------------------
Ran 2 tests in 0.001s

FAILED (failures=1)
</code></pre>
<p>还可以使用-v参数来获得更详细的输出</p>
<pre><code class="language-bash">$ python -m unittest test_password_1.PasswordTeseCase -v
test_dummy (test_password_1.PasswordTeseCase) ... set up
ok
test_week_password (test_password_1.PasswordTeseCase) ... set up
FAIL

======================================================================
### FAIL: test_week_password (test_password_1.PasswordTeseCase)
Traceback (most recent call last):
  File &quot;/Users/aaa/code/test_password_1.py&quot;, line 21, in test_week_password
    self.assertTrue(passwd != 'password123', msg)
AssertionError: False is not true : user tom has a weak password

----------------------------------------------------------------------
Ran 2 tests in 0.001s

FAILED (failures=1)
</code></pre>
<h3 id="7-各种断言方法">7. 各种断言方法</h3>
<blockquote>
<p>unittest支持各种断言方法。</p>
</blockquote>
<p>断言列表---<a href="https://docs.python.org/3/library/unittest.html">官方文档</a></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>检查点</th>
</tr>
</thead>
<tbody>
<tr>
<td>assertEqual(a, b)</td>
<td>a == b</td>
</tr>
<tr>
<td>assertNotEqual(a, b)</td>
<td>a != b</td>
</tr>
<tr>
<td>assertTrue(x)</td>
<td>bool(x) is True</td>
</tr>
<tr>
<td>assertFalse(x)</td>
<td>bool(x) is False</td>
</tr>
<tr>
<td>assertIs(a, b)</td>
<td>a is b</td>
</tr>
<tr>
<td>assertIsNot(a, b)</td>
<td>a is not b</td>
</tr>
<tr>
<td>assertIsNone(x)</td>
<td>x is None</td>
</tr>
<tr>
<td>assertIsNotNone(x)</td>
<td>x is not None</td>
</tr>
<tr>
<td>assertIn(a, b)</td>
<td>a in b</td>
</tr>
<tr>
<td>assertNotIn(a, b)</td>
<td>a not in b</td>
</tr>
<tr>
<td>assertIsInstance(a, b)</td>
<td>isinstance(a, b)</td>
</tr>
<tr>
<td>assertNotIsInstance(a, b)</td>
<td>not isinstance(a, b)</td>
</tr>
<tr>
<td>assertRaises(exc, fun, *args, **kwds)</td>
<td>fun(*args, **kwds) raises exc</td>
</tr>
<tr>
<td>assertRaisesRegexp(exc, r, fun, *args, **kwds)</td>
<td>fun(*args, **kwds) raises exc and the message matches regex r</td>
</tr>
<tr>
<td>assertAlmostEqual(a, b)</td>
<td>round(a-b, 7) == 0</td>
</tr>
<tr>
<td>assertNotAlmostEqual(a, b)</td>
<td>round(a-b, 7) != 0</td>
</tr>
<tr>
<td>assertGreater(a, b)</td>
<td>a &gt; b 2.7</td>
</tr>
<tr>
<td>assertGreaterEqual(a, b)</td>
<td>a &gt;= b</td>
</tr>
<tr>
<td>assertLess(a, b)</td>
<td>a &lt; b</td>
</tr>
<tr>
<td>assertLessEqual(a, b)</td>
<td>a &lt;= b</td>
</tr>
<tr>
<td>assertRegexpMatches(s, r)</td>
<td>r.search(s)</td>
</tr>
<tr>
<td>assertNotRegexpMatches(s, r)</td>
<td>not r.search(s)</td>
</tr>
<tr>
<td>assertItemsEqual(a, b)</td>
<td>sorted(a) == sorted(b) 也支持unhashable对象</td>
</tr>
<tr>
<td>assertDictContainsSubset(a, b)</td>
<td>a里面所有的键值对都在b中存在</td>
</tr>
</tbody>
</table>
<h3 id="8-断言异常">8. 断言异常</h3>
<blockquote>
<p>我们有时候需要断言一些方法会抛出异常，这些异常需要符合我们的预期。</p>
</blockquote>
<p>新建<code>test_exception.py</code>文件，内容如下</p>
<pre><code class="language-python">import unittest

class DivZeroTestCase(unittest.TestCase):

    def test_should_raise_exception(self):
        with self.assertRaises(ZeroDivisionError):
            1 / 0

if __name__ == '__main__':
    unittest.main()
</code></pre>
<h4 id="运行及结果-2">运行及结果</h4>
<pre><code class="language-bash">$ python test_exception.py
----------------------------------------------------------------------
Ran 1 test in 0.000s

OK
</code></pre>
<p>上面的例子断言了当0作为除数的时候会抛出<code>ZeroDivisionError</code></p>
<p>断言异常是有套路的，使用<code>with</code>语句加<code>assertRaises</code>，assertRaises的参数中传入预期的异常(这些异常可能需要先import进来)，在with的子句中放上会抛出异常的语句或表达式。</p>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://preszang.github.io/post/Python 第三方日志框架 loguru 使用/" class="post-title gt-a-link">
                    Python 第三方日志框架 loguru 使用
                </a>
            </div>
        

        

        

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">啦啦啦啦啦啦啦啦啦啦啦啦</div>
    <div class="social-container">
        
            
        
            
        
            
        
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        是谁来自山川湖海，却囿于昼夜、厨房与爱。
    </div>

<!--    <div>
        Theme by <a href="https://imhanjie.com/" target="_blank">imhanjie</a>, Powered by <a
                href="https://github.com/getgridea/gridea" target="_blank">Gridea | <a href="https://preszang.github.io/atom.xml" target="_blank">RSS</a></a>
    </div> -->
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
</div>
</body>
</html>
